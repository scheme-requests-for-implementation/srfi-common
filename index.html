<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Scheme Requests for Implementation</title>
    <link rel="preload" href="srfi.js" as="script">
    <link href="favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" type="text/css" href="admin.css">
    <link rel="stylesheet" type="text/css" href="home.css">
    <link rel="stylesheet" type="text/css" href="list.css">
    <link rel="alternate" type="application/rss+xml" href="/srfi.rss">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
     });
    </script>
    <script crossorigin="anonymous" integrity=
            "sha384-Ra6zh6uYMmH5ydwCqqMoykyf1T/+ZcnOQfFPhDrp2kI4OIxadnhsvvA2vv9A7xYv" src=
            "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head>
  <body>
    <h1><img class="srfi-logo" src="srfi-logo.svg" alt="SRFI surfboard logo" />Scheme Requests for Implementation</h1>

    <p class="hide">SRFIs extend the Scheme programming language.  You
      can help. <a href="about.html">Learn more</a>.</p>

    <section class="announcement">
    <h2>New mailing list: <a href="srfi-list-subscribe.html#schemeorg"><code>schemeorg</code></a></h2>
    <p>As of <b>November, 2020</b>, there is another new Scheme Topics mailing
      list: <a
    href="srfi-list-subscribe.html#schemeorg"><code>Schemeorg</code></a>.
    <code>Schemeorg</code> is for discussing the <code>scheme.org</code>
    domain and its subdomains and how they will be organized.</p></section>

    <h2>The SRFIs</h2>

    <noscript><p>Javascript is not enabled in your browser, so
      filtering, searching, and sorting the list of SRFIs is turned
      off.</p></noscript>

    <div id="srfis">
      <div class="invisible" id="parameters">
        <div>
          <span>Search for</span>
          <input class="search" id="search" placeholder="numbers or words" tabindex="1" /></div>
        <div>
          <span>Sort by</span>
          <button class="controls sort" data-sort="authors" tabindex="2" >authors</button>
          <button class="controls sort" data-sort="date" tabindex="3" >date</button>
          <button class="controls sort" data-sort="name" tabindex="4" >name</button>
          <button class="controls sort" data-sort="number" tabindex="5" >number</button>
          <button class="controls sort" data-sort="status" tabindex="6" >status</button></div>
        <div>
          <span>Filter by </span>
          <div class="dropdown" id="statuses">
            <button class="controls">status<span> ×</span></button>
            <div class="options">
              <select multiple size="4">
                <option selected value="any">any</option>
                <option value="draft">Draft</option>
                <option value="final">Final</option>
                <option value="withdrawn">Withdrawn</option></select></div>
            <span class="chosen"></span></div>
          <div class="dropdown" id="keywords">
            <button class="controls">keywords<span> ×</span></button>
            <div class="options">
              <select multiple size="35">
                <option selected value="any">any</option>
                <option value="algorithm">Algorithm</option>
                <option value="assignment">Assignment</option>
                <option value="binding">Binding</option>
                <option value="comparison">Comparison</option>
                <option value="concurrency">Concurrency</option>
                <option value="continuations">Continuations</option>
                <option value="control-flow">Control Flow</option>
                <option value="data-structure">Data Structure</option>
                <option value="error-handling">Error Handling</option>
                <option value="exceptions">Exceptions</option>
                <option value="features">Features</option>
                <option value="i/o">I/O</option>
                <option value="internationalization">Internationalization</option>
                <option value="introspection">Introspection</option>
                <option value="lazy-evaluation">Lazy Evaluation</option>
                <option value="miscellaneous">Miscellaneous</option>
                <option value="modules">Modules</option>
                <option value="multiple-value-returns">Multiple-Value Returns</option>
                <option value="numbers">Numbers</option>
                <option value="operating-system">Operating System</option>
                <option value="optimization">Optimization</option>
                <option value="parameters">Parameters</option>
                <option value="pattern-matching">Pattern Matching</option>
                <option value="r6rs-process">R6RS process</option>
                <option value="r7rs-large">R7RS Large</option>
                <option value="r7rs-large-red">R7RS Large: Red Edition</option>
                <option value="r7rs-large-tangerine">R7RS Large: Tangerine Edition</option>
                <option value="randomness">Randomness</option>
                <option value="reader-syntax">Reader Syntax</option>
                <option value="sicp">SICP</option>
                <option value="superseded">Superseded</option>
                <option value="syntax">Syntax</option>
                <option value="testing">Testing</option>
                <option value="type-checking">Type Checking</option></select></div>
            <span class="chosen"></span></div></div>
        <div>
          <span>Show</span>
          <label class="checkbox-label controls">
            <input class="controls" id="abstracts-control" tabindex="7" type="checkbox">
            abstracts</label></div></div>
      <ul class="summary list">

      <li class="card draft"><a class="card-anchor" href="srfi-224/"></a><a href="srfi-224/"><span class="number">224</span></a>: <span class="name">Integer Mappings</span><span class="authors">, by Wolfgang Corcoran-Mathe</span><span class="based-on"></span><span class="date-group">Draft: <span class="date">2021-03-24</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="draft"></span><span class="see-also">See also <a href="/srfi-146/">SRFI 146: Mappings</a> and <a href="/srfi-189/">SRFI 189: Maybe and Either: optional container types</a>.</span><div class="abstract"><p>Integer maps, or <em>imappings</em>, are finite sets, where each element is
an association between an exact-integer key and an arbitrary Scheme
object.  They are similar to the general mappings of
<a href="https://srfi.schemers.org/srfi-146/">SRFI
146</a>, but the restricted key-type allows implementations of
imappings to benefit from optimized structures and algorithms.  This
library provides a rich set of operations on imappings, including
analogues of most of the forms provided by SRFI 146.  Imappings have
no intrinsic order, but may be treated as ordered sets, using the
natural ordering on keys; a substantial sublibrary for working with
imappings in this fashion is included.</p></div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-223/"></a><a href="srfi-223/"><span class="number">223</span></a>: <span class="name">Generalized binary search procedures</span><span class="authors">, by Daphne Preston-Kendal</span><span class="based-on"></span><span class="date-group">Draft: <span class="date">2021-03-14</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="draft"></span><span class="see-also">See also <a href="/srfi-43/">SRFI 43: Vector library</a> and <a href="/srfi-133/">SRFI 133: Vector Library (R7RS-compatible)</a>.</span><div class="abstract"><p>Generalized procedures for binary search of vector-like data structures are provided which can be applied to any sequence type, including ones defined by the user, together with applications of these procedures for Scheme’s built-in vector and bytevector types.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-222/"></a><a href="srfi-222/"><span class="number">222</span></a>: <span class="name">Compound Objects</span><span class="authors">, by John Cowan (text) and Arvydas Silanskas (implementation)</span><span class="based-on"></span><span class="date-group">Draft: <span class="date">2021-03-05</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="draft"></span><div class="abstract"><p>Compound objects are a generalization of R6RS compound conditions,
and are suitable for use in creating and handling conditions among other purposes.
They encapsulate an immutable sequence of subobjects, which can be
any object except another compound object.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-221/"></a><a href="srfi-221/"><span class="number">221</span></a>: <span class="name">Generator/accumulator sub-library</span><span class="authors">, by John Cowan (text) and Arvydas Silanskas (implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-05-28</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-158/">SRFI 158: Generators and Accumulators</a>.</span><div class="abstract"><p>This is a set of convenience routines for generators and accumulators
intended to blend in with
<a href="https://srfi.schemers.org/srfi-158/srfi-158.html">SRFI 158</a>.
The authors recommend that they be added to the
<code>(srfi 158)</code> library provided by
users or implementations.
If they are approved by the R7RS-large process,
they can also be added to <code>(r7rs generator)</code>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-220/"></a><a href="srfi-220/"><span class="number">220</span></a>: <span class="name">Line directives</span><span class="authors">, by Lassi Kortela</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2021-04-20</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">  <p>Many language-agnostic programming tools rely on specially
  formatted source code comments to annotate the code with
  metadata. Such "magic comments" are hard for both humans and
  computers to parse reliably, as the purpose of a comment is to be
  free-form text that is not interpreted by machine.</p>
  <p>This SRFI extends the standard Scheme directive syntax
  (<code>#!</code>) to support <em>line directives</em>. They look
  like magic comments to language-agnostic tools but read as
  S-expressions in Scheme, combining the portability of magic
  comments with the well-defined syntax and easy parsing of
  ordinary Scheme code.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-219/"></a><a href="srfi-219/"><span class="number">219</span></a>: <span class="name">Define higher-order lambda</span><span class="authors">, by Lassi Kortela</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-04-04</span></span><span class="keywords" data-keywords="binding,syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-201/">SRFI 201: Syntactic Extensions to the Core Scheme Bindings</a>.</span><div class="abstract"><p>This SRFI codifies the following shorthand syntax, which some
  Scheme implementations have had for a long time.</p>
  <pre>(define ((outer-name outer-args ...) inner-args ...)
  inner-body ...)</pre></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-218/"></a><a href="srfi-218/"><span class="number">218</span></a>: <span class="name">Unicode Numerals</span><span class="authors">, by John Cowan (text) and Arvydas Silanskas (implementation)</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2021-01-30</span></span><span class="keywords" data-keywords="internationalization">Keywords: <a href="https://srfi.schemers.org/?keywords=internationalization">Internationalization</a></span><span class="status" data-status="withdrawn"></span><div class="abstract"><p>These procedures allow the creation and interpretation of numerals
using any set of Unicode digits that support positional notation.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-217/"></a><a href="srfi-217/"><span class="number">217</span></a>: <span class="name">Integer Sets</span><span class="authors">, by John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-02-15</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-113/">SRFI 113: Sets and bags</a>.</span><div class="abstract"><p>Integer sets, or <em>iset</em>s, are unordered collections of
fixnums.  (Fixnums are exact integers within certain
implementation-specified bounds.)</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-216/"></a><a href="srfi-216/"><span class="number">216</span></a>: <span class="name">SICP Prerequisites (Portable)</span><span class="authors">, by Vladimir Nikishkin</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-01-21</span></span><span class="keywords" data-keywords="sicp">Keywords: <a href="https://srfi.schemers.org/?keywords=sicp">SICP</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-203/">SRFI 203: A Simple Picture Language in the Style of SICP</a>.</span><div class="abstract"><p>
   This SRFI follows
    <a href="https://srfi.schemers.org/srfi-203/">
     SRFI 203
    </a>
   in providing "out-of-the-box" support for hosting the exercises suggested by
    <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">
     Structure and Interpretation of Computer Programs
    </a>
   in portable Scheme.
</p>

<p>
Whereas SRFI 203 focused on the necessarily non-portable aspects of the problem set (the graphics), this SRFI aims to provide support for the rest of the features, which are far more widespread, often already provided, and in reality mostly need just a common vocabulary.
</p>

<p>
This SRFI provides procedures for working with time data, multi-threading, and streams, as well as SICP names for <code>true</code> and <code>false</code>.
</p>

<p>
None of these procedures is fit for production use.  They are only designed for pedagogical purposes.
</p>

<p>
Students, however, are expected to be able to just write</p>
 <pre>
 (include (srfi sicp))</pre>
 <p>and have the code from the book run without problems (apart from those intended by the book authors).
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-215/"></a><a href="srfi-215/"><span class="number">215</span></a>: <span class="name">Central Log Exchange</span><span class="authors">, by Göran Weinholt</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-01-11</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><div class="abstract">    <p>
      This SRFI specifies a central log exchange for Scheme that
      connects log producers with log consumers. It allows multiple
      logging systems to interoperate and co-exist in the same
      program. Library code can produce log messages without knowledge
      of which log system is actually used. Simple applications can
      easily get logs on standard output, while more advanced
      applications can send them to a full logging system.
    </p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-214/"></a><a href="srfi-214/"><span class="number">214</span></a>: <span class="name">Flexvectors</span><span class="authors">, by Adam Nelson</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-03-18</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-117/">SRFI 117: Queues based on lists</a>, <a href="/srfi-125/">SRFI 125: Intermediate hash tables</a>, <a href="/srfi-133/">SRFI 133: Vector Library (R7RS-compatible)</a>, <a href="/srfi-134/">SRFI 134: Immutable Deques</a>, and <a href="/srfi-158/">SRFI 158: Generators and Accumulators</a>.</span><div class="abstract"><p>A <em>flexvector</em>, also known as a dynamic array or an arraylist, is a mutable vector-like data structure with an adjustable size. Flexvectors allow fast random access and fast insertion/removal at the end. This SRFI defines a suite of operations on flexvectors, modeled after <a href="https://srfi.schemers.org/srfi-133/srfi-133.html">SRFI 133</a>'s vector operations.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-213/"></a><a href="srfi-213/"><span class="number">213</span></a>: <span class="name">Identifier Properties</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-03-21</span></span><span class="keywords" data-keywords="binding,syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract"><p>Using the <code>define-property</code> definition described in
  this SRFI, expand-time properties can be associated with
  identifiers in a referentially transparent and lexically scoped way.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-212/"></a><a href="srfi-212/"><span class="number">212</span></a>: <span class="name">Aliases</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-02-12</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract"><p>This SRFI introduces <em>alias definitions</em>, a syntactic
extension.  An alias definition transfers the binding of one
identifier to another, effectively aliasing the identifier.</p></div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-211/"></a><a href="srfi-211/"><span class="number">211</span></a>: <span class="name">Scheme Macro Libraries</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Draft: <span class="date">2020-09-12</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="draft"></span><div class="abstract"><p>This SRFI defines library name spaces where common extensions
  of the <code>syntax-rules</code> macro facility can be located
  and which can be tested against in <code>cond-expand</code> forms.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-210/"></a><a href="srfi-210/"><span class="number">210</span></a>: <span class="name">Procedures and Syntax for Multiple Values</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-02-12</span></span><span class="keywords" data-keywords="binding,multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-8/">SRFI 8: receive: Binding to multiple values</a>, <a href="/srfi-11/">SRFI 11: Syntax for receiving multiple values</a>, and <a href="/srfi-71/">SRFI 71: Extended LET-syntax for multiple values</a>.</span><div class="abstract"><p>
  This SRFI extends the Scheme standard with procedures and syntax
  dealing with multiple values, including syntax to create lists and
  vectors from expressions returning multiple values and procedures
  returning the elements of a list or vector as multiple values.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-209/"></a><a href="srfi-209/"><span class="number">209</span></a>: <span class="name">Enums and Enum Sets</span><span class="authors">, by John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-12-17</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract"><p>Enums are objects that serve to form sets of distinct classes
that specify different modes of operation for a procedure.
Their use fosters portable and readable code.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-208/"></a><a href="srfi-208/"><span class="number">208</span></a>: <span class="name">NaN procedures</span><span class="authors">, by Emmanuel Medernach (design), John Cowan (editor), and Wolfgang Corcoran-Mathe (implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-02-23</span></span><span class="keywords" data-keywords="data-structure,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><div class="abstract"><p>This SRFI provides procedures that dissect NaN (Not a Number) inexact values.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-207/"></a><a href="srfi-207/"><span class="number">207</span></a>: <span class="name">String-notated bytevectors</span><span class="authors">, by Daphne Preston-Kendal (external notation), John Cowan (procedure design), and Wolfgang Corcoran-Mathe (implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-10-29</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract"><p>To ease the human reading and writing of Scheme code involving
binary data that for mnemonic reasons corresponds
as a whole or in part to ASCII-coded text, a notation
for bytevectors is defined which allows printable ASCII characters
to be used literally without being converted to their corresponding
integer forms. In addition, this SRFI provides a set of procedures
known as the bytestring library
for constructing a bytevector from a sequence of integers,
characters, strings, and/or bytevectors, and for manipulating
bytevectors as if they were strings as far as possible.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-206/"></a><a href="srfi-206/"><span class="number">206</span></a>: <span class="name">Auxiliary Syntax Keywords</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-12-21</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-139/">SRFI 139: Syntax parameters</a> and <a href="/srfi-213/">SRFI 213: Identifier Properties</a>.</span><div class="abstract">This SRFI defines a mechanism for defining auxiliary syntax
keywords independently in different modules in such a way that
they still have the same binding so that they can be used
interchangeably as literal identifiers in
<code>syntax-rules</code> and <code>syntax-case</code> expressions
and can be both imported under the same name without conflicts.</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-205/"></a><a href="srfi-205/"><span class="number">205</span></a>: <span class="name">POSIX Terminal Fundamentals</span><span class="authors">, by John Cowan (author) and Harold Ancell (author and editor)</span><span class="based-on"></span><span class="date-group">Draft: <span class="date">2020-07-23</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="draft"></span><span class="see-also">See also <a href="/srfi-170/">SRFI 170: POSIX API</a> and <a href="/srfi-198/">SRFI 198: Foreign Interface Status</a>.</span><div class="abstract"><p>
This SRFI describes procedures for command-line and terminal interface
programs to safely change and reset terminal modes, for example from
cooked to raw and back, and for serial-line device manipulation for
interfacing with embedded hardware and the like.
</p>
<p>
It is intended to provide all the
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/termios.h.html">termios structure</a>
functionality a modern Scheme programmer might desire by supplying a
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/stty.html">stty</a>
procedure, and simple abstractions on top of it.
</p>
</div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-204/"></a><a href="srfi-204/"><span class="number">204</span></a>: <span class="name">Wright-Cartwright-Shinn Pattern Matcher</span><span class="authors">, by Felix Thibault</span><span class="based-on"></span><span class="date-group">Draft: <span class="date">2020-07-15</span></span><span class="keywords" data-keywords="pattern-matching">Keywords: <a href="https://srfi.schemers.org/?keywords=pattern-matching">Pattern Matching</a></span><span class="status" data-status="draft"></span><span class="see-also">See also <a href="/srfi-200/">SRFI 200: Pattern Matching</a> and <a href="/srfi-201/">SRFI 201: Syntactic Extensions to the Core Scheme Bindings</a>.</span><div class="abstract"><p>Pattern matching decomposes a compound data structure
into parts and assigns those parts to variables. This
SRFI describes a pattern-matching library already in use by
several scheme implementations which can match many common
compound data structures.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-203/"></a><a href="srfi-203/"><span class="number">203</span></a>: <span class="name">A Simple Picture Language in the Style of SICP</span><span class="authors">, by Vladimir Nikishkin</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-09-17</span></span><span class="keywords" data-keywords="sicp">Keywords: <a href="https://srfi.schemers.org/?keywords=sicp">SICP</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-216/">SRFI 216: SICP Prerequisites (Portable)</a>.</span><div class="abstract"><p>This SRFI proposes a simple library for programmatic drawing of
pictures compatible with Section 2.2.4 of <cite>Structure and
Interpretation of Computer Programs</cite>.</p>

<p>It aims to close the gap between the Scheme suggested for study in
the book and portable Scheme.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-202/"></a><a href="srfi-202/"><span class="number">202</span></a>: <span class="name">Pattern-matching Variant of the and-let* Form that Supports Multiple Values</span><span class="authors">, by Panicz Maciej Godek</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-11-28</span></span><span class="keywords" data-keywords="binding,control-flow,pattern-matching">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=control-flow">Control Flow</a>, <a href="https://srfi.schemers.org/?keywords=pattern-matching">Pattern Matching</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-2/">SRFI 2: AND-LET*: an AND with local bindings, a guarded LET* special form</a> and <a href="/srfi-200/">SRFI 200: Pattern Matching</a>.</span><div class="abstract"><p>The SRFI-2 library introduced the <code>and-let*</code> form
  for short-circuited evaluation in the style of the <code>and</code>
  form, with the ability to capture the (non-<code>#f</code>) results
  in the style of the <code>let*</code> form.  This document extends
  the <code>and-let*</code> form with the ability to pattern-match (or
  "destructurally bind") the values of evaluated expressions (where
  the match failure causes short-circuiting rather than raising an
  error) and the ability to handle multiple values (where only the
  falsehood of the first value causes short-circuiting).
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-201/"></a><a href="srfi-201/"><span class="number">201</span></a>: <span class="name">Syntactic Extensions to the Core Scheme Bindings</span><span class="authors">, by Panicz Maciej Godek</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2021-01-13</span></span><span class="keywords" data-keywords="binding,pattern-matching,syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=pattern-matching">Pattern Matching</a>, <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-8/">SRFI 8: receive: Binding to multiple values</a>, <a href="/srfi-11/">SRFI 11: Syntax for receiving multiple values</a>, <a href="/srfi-71/">SRFI 71: Extended LET-syntax for multiple values</a>, <a href="/srfi-200/">SRFI 200: Pattern Matching</a>, and <a href="/srfi-219/">SRFI 219: Define higher-order lambda</a>.</span><div class="abstract"><p>This document describes a handful of syntactic extensions
  to the core bindings of the Scheme programming language.
  In particular, it proposes to extend the binding forms
  <code>lambda</code>, <code>let</code>,
  <code>let*</code> with pattern matching capabilities, to extend the forms <code>let</code>
  and <code>or</code> with the ability
  to handle multiple values, and to extend the form <code>define</code> with
  the ability of defining "curried" functions.</p></div></li>
      <li class="card draft"><a class="card-anchor" href="srfi-200/"></a><a href="srfi-200/"><span class="number">200</span></a>: <span class="name">Pattern Matching</span><span class="authors">, by Panicz Maciej Godek</span><span class="based-on"></span><span class="date-group">Draft: <span class="date">2020-06-25</span></span><span class="keywords" data-keywords="pattern-matching">Keywords: <a href="https://srfi.schemers.org/?keywords=pattern-matching">Pattern Matching</a></span><span class="status" data-status="draft"></span><div class="abstract"><p>This SRFI discusses the most widespread existing pattern matching libraries
  for the Scheme programming language - namely, the pattern matcher
  presented by Andrew K. Wright and Robert Cartwright in the paper "A Soft
  Type System for Scheme", the pattern matcher developed by Dan Friedman,
  Erik Hilsdale and Kent Dybvig, and the <code>racket/match</code> module
  distributed with the Racket programming environment.
  It then extracts a pattern syntax which is compatible with two of
  those implementations and provides extrinsic rationale for that syntax.
  It also provides a simple implementation of a pattern matcher
  which conforms to the specification of a pattern language provided
  in this document.</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-199/"></a><a href="srfi-199/"><span class="number">199</span></a>: <span class="name">POSIX errno manipulation</span><span class="authors">, by Harold Ancell</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2020-07-19</span></span><span class="keywords" data-keywords="error-handling,operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=error-handling">Error Handling</a>, <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-170/">SRFI 170: POSIX API</a> and <a href="/srfi-198/">SRFI 198: Foreign Interface Status</a>.</span><div class="abstract"><p>The majority of P<small>OSIX</small> system and library calls
  require accessing <code>errno</code> to discern the specific cause
  of an error, and some require setting it to 0 before being called.
  This SRFI specifies procedures to both retrieve its value, and to
  set it.
</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-198/"></a><a href="srfi-198/"><span class="number">198</span></a>: <span class="name">Foreign Interface Status</span><span class="authors">, by John Cowan (editor and shepherd), Harold Ancell (implementer and editor), and Lassi Kortela (architect)</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2020-09-12</span></span><span class="keywords" data-keywords="error-handling,operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=error-handling">Error Handling</a>, <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-170/">SRFI 170: POSIX API</a>.</span><div class="abstract"><p>
This SRFI provides means to construct, return or signal, and extract
information from Scheme interfaces with "foreign" systems such as the
P<small>OSIX</small> API, databases, and libraries.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-197/"></a><a href="srfi-197/"><span class="number">197</span></a>: <span class="name">Pipeline Operators</span><span class="authors">, by Adam Nelson</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-09-12</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract"><p>Many functional languages provide pipeline operators, like Clojure's <code>-&gt;</code> or OCaml's <code>|&gt;</code>. Pipelines are a simple, terse, and readable way to write deeply-nested expressions. This SRFI defines a family of <code>chain</code> and <code>nest</code> pipeline operators, which can rewrite nested expressions like <code>(a b (c d (e f g)))</code> as a sequence of operations: <code>(chain g (e f _) (c d _) (a b _))</code>.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-196/"></a><a href="srfi-196/"><span class="number">196</span></a>: <span class="name">Range Objects</span><span class="authors">, by John Cowan (text) and Wolfgang Corcoran-Mathe (sample implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-09-17</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-42/">SRFI 42: Eager Comprehensions</a>.</span><div class="abstract"><p>Ranges are collections somewhat similar to vectors, except that
  they are immutable and have algorithmic representations instead of
  the uniform per-element data structure of vectors. The storage required is
  usually less than the size of the same collection stored in a
  vector and the time needed to reference a particular element is
  typically less for a range than for the same collection stored in a
  list. This SRFI defines a large subset of the sequence operations
  defined on lists, vectors, strings, and other collections.  If
  necessary, a range can be converted to a list, vector, or string of
  its elements or a generator that will lazily produce each element in
  the range.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-195/"></a><a href="srfi-195/"><span class="number">195</span></a>: <span class="name">Multiple-value boxes</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-08-28</span></span><span class="keywords" data-keywords="data-structure,multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-111/">SRFI 111: Boxes</a> and <a href="/srfi-189/">SRFI 189: Maybe and Either: optional container types</a>.</span><div class="abstract"><p>
  This SRFI extends the specification of the boxes
  of <a href="https://srfi.schemers.org/srfi-111/srfi-111.html">SRFI
  111</a> so that they are multiple-values aware.  Whereas a SRFI
  111 box is limited in that it can only box a single value,
  multiple values can be boxed with this SRFI.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-194/"></a><a href="srfi-194/"><span class="number">194</span></a>: <span class="name">Random data generators</span><span class="authors">, by Shiro Kawai (design), Arvydas Silanskas (implementation), John Cowan (editor and shepherd), and Linas Vepštas (implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-08-26</span></span><span class="keywords" data-keywords="randomness">Keywords: <a href="https://srfi.schemers.org/?keywords=randomness">Randomness</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-27/">SRFI 27: Sources of Random Bits</a>.</span><div class="abstract"><p>This SRFI defines a set of
<a href="https://srfi.schemers.org/srfi-158/srfi-158.html">SRFI 158</a>
generators and generator makers that yield random data of specific
ranges and distributions.  It is intended to be implemented on top of
<a href="https://srfi.schemers.org/srfi-27/srfi-27.html">SRFI 27</a>,
which provides the underlying source of random integers and floats.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-193/"></a><a href="srfi-193/"><span class="number">193</span></a>: <span class="name">Command line</span><span class="authors">, by Lassi Kortela</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-09-10</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-22/">SRFI 22: Running Scheme Scripts on Unix</a>.</span><div class="abstract"><p>R<sup>6</sup>RS and R<sup>7</sup>RS define a
<code>command-line</code> procedure. While a useful baseline, the
specification is not detailed enough to cover all practical
situations. This SRFI clarifies the definition of
<code>command-line</code> and adds a few related procedures.
Scheme scripts, standalone executables, compilation and REPL use
are accounted for. Option parsing is out of scope.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-192/"></a><a href="srfi-192/"><span class="number">192</span></a>: <span class="name">Port Positioning</span><span class="authors">, by John Cowan and Shiro Kawai (implementation; requires a hook)</span><span class="based-on">Based on R6RS.</span><span class="date-group">Final: <span class="date">2020-07-31</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-181/">SRFI 181: Custom ports (including transcoded ports)</a>.</span><div class="abstract"><p>This is an extract from the R6RS that documents its support for
positioning ports.  Binary ports can be positioned to read or write
at a specific byte; textual ports at a specific character,
although character positions can't be synthesized portably.
It has been lightly edited to fit R7RS style.</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-191/"></a><a href="srfi-191/"><span class="number">191</span></a>: <span class="name">Procedure Arity Inspection</span><span class="authors">, by John Cowan</span><span class="based-on">Based on SRFI 102.</span><span class="date-group">Withdrawn: <span class="date">2020-07-05</span></span><span class="keywords" data-keywords="introspection">Keywords: <a href="https://srfi.schemers.org/?keywords=introspection">Introspection</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-102/">SRFI 102: Procedure Arity Inspection</a> and <a href="/srfi-151/">SRFI 151: Bitwise Operations</a>.</span><div class="abstract"><p>Many Scheme systems provide mechanisms for inspecting the arity of a
procedural value, making it a common feature, however there is no
standard interface.  As a result there is no portable way to observe
the arity of a procedure without actually applying it.  This
SRFI proposes a simple interface that is consistent with existing
Scheme systems' facilities and prior proposals.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-190/"></a><a href="srfi-190/"><span class="number">190</span></a>: <span class="name">Coroutine Generators</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-06-11</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-121/">SRFI 121: Generators</a>, <a href="/srfi-139/">SRFI 139: Syntax parameters</a>, and <a href="/srfi-158/">SRFI 158: Generators and Accumulators</a>.</span><div class="abstract"><p>This SRFI defines syntax to create
  <a href="https://srfi.schemers.org/srfi-121/">SRFI
    121</a>/<a href="https://srfi.schemers.org/srfi-158/">158</a>
  coroutine generators conveniently and in the flavor of Python
  generator functions.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-189/"></a><a href="srfi-189/"><span class="number">189</span></a>: <span class="name">Maybe and Either: optional container types</span><span class="authors">, by John Cowan (text) and Wolfgang Corcoran-Mathe (sample implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-07-14</span></span><span class="keywords" data-keywords="data-structure,multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-195/">SRFI 195: Multiple-value boxes</a>.</span><div class="abstract"><p>This SRFI defines two disjoint immutable container types
known as Maybe and Either,
both of which can contain objects collectively known as their payload.
A Maybe object is either a Just object or the unique object Nothing
(which has no payload); an Either object is either
a Right object or a Left object.  Maybe represents the concept of
optional values; Either represents the concept of values which are
either correct (Right) or errors (Left).</p>
<p>Note that the terms Maybe, Just, Nothing, Either, Right, and Left
are capitalized in this SRFI so as not to be confused with their
ordinary use as English words.  Thus &quot;returns Nothing&quot; means
&quot;returns the unique Nothing object&quot;; &quot;returns nothing&quot; could be
interpreted as &quot;returns no values&quot;
or &quot;returns an unspecified value&quot;.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-188/"></a><a href="srfi-188/"><span class="number">188</span></a>: <span class="name">Splicing binding constructs for syntactic keywords</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-06-03</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-93/">SRFI 93: R6RS Syntax-Case Macros</a> and <a href="/srfi-148/">SRFI 148: Eager syntax-rules</a>.</span><div class="abstract"><p>Splicing binding constructs for syntactic keywords are versions
  of <code>let-syntax</code> and <code>letrec-syntax</code> that can
  be used in a definition context in the same way
  as <code>begin</code>.
</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-187/"></a><a href="srfi-187/"><span class="number">187</span></a>: <span class="name">ALAMBDA and ADEFINE</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on">Based on SRFI 92.</span><span class="date-group">Withdrawn: <span class="date">2020-03-27</span></span><span class="keywords" data-keywords="miscellaneous,type-checking">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a>, <a href="https://srfi.schemers.org/?keywords=type-checking">Type Checking</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-92/">SRFI 92: ALAMBDA and ALAMBDA*</a> and <a href="/srfi-182/">SRFI 182: ADBMAL, ALET, and ALET*</a>.</span><div class="abstract"><p>This SRFI introduces alambda, which creates a procedure that checks
its actual arguments, takes various types of required and optional
variables.<br> This SRFI is based on
<a href="https://srfi.schemers.org/srfi-92/">SRFI 92</a>
as an extension of the optional arguments of
<a href="https://srfi.schemers.org/srfi-182/">SRFI 182</a>.</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-186/"></a><a href="srfi-186/"><span class="number">186</span></a>: <span class="name">Transcoders and transcoded ports</span><span class="authors">, by John Cowan</span><span class="based-on">Based on R6RS.</span><span class="date-group">Withdrawn: <span class="date">2020-09-08</span></span><span class="keywords" data-keywords="i/o,superseded">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a>, <a href="https://srfi.schemers.org/?keywords=superseded">Superseded</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-80/">SRFI 80: Stream I/O</a>, <a href="/srfi-81/">SRFI 81: Port I/O</a>, and <a href="/srfi-181/">SRFI 181: Custom ports (including transcoded ports)</a>.</span><div class="abstract"><p>This is an extract from the R6RS that documents its support for
transcoders and transcoded ports.  These provide a hook into the
Scheme port system from below, allowing the creation of textual ports
that provide non-default encoding and decoding from arbitrary binary
ports.  It has been lightly edited to fit R7RS style.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-185/"></a><a href="srfi-185/"><span class="number">185</span></a>: <span class="name">Linear adjustable-length strings</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-04-26</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-13/">SRFI 13: String Libraries</a>, <a href="/srfi-118/">SRFI 118: Simple adjustable-size strings</a>, <a href="/srfi-130/">SRFI 130: Cursor-based string library</a>, <a href="/srfi-140/">SRFI 140: Immutable Strings</a>, and <a href="/srfi-152/">SRFI 152: String Library (reduced)</a>.</span><div class="abstract"><p>
Scheme specifies mutable fixed-length strings.
<a href="https://srfi.schemers.org/srfi-118/srfi-118.html">SRFI 118</a>
adds two procedures, <code>string-append!</code> and
<code>string-replace!</code>, which allow the length of the string to change.
This SRFI provides two linear-update versions of these procedures:
that is, the implementation may change the string length or return a
new string instead.
In addition, two convenience macros are provided that make the
procedures somewhat easier to use.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-184/"></a><a href="srfi-184/"><span class="number">184</span></a>: <span class="name">define-record-lambda</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2020-03-27</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-9/">SRFI 9: Defining Record Types</a> and <a href="/srfi-100/">SRFI 100: define-lambda-object</a>.</span><div class="abstract"><p>This SRFI introduces a macro, DEFINE-RECORD-LAMBDA, that defines a
  set of procedures, that is, a group of constructors and a predicate.
  The constructors also make a group of procedures, namely record
  lambdas, that have no explicit field accessors and mutators.  They
  can have various kinds of fields, such as common fields, required
  fields, optional fields, automatic fields, read-only fields,
  read-write fields, invisible fields, immutable fields, and virtual
  fields.</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-183/"></a><a href="srfi-183/"><span class="number">183</span></a>: <span class="name">Another format procedure, Fox</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2020-03-27</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-54/">SRFI 54: Formatting</a>.</span><div class="abstract"><p>This SRFI introduces the formatting procedure Fox ("format of X"),
  which takes one required argument and a variable number of additional
  arguments and returns a formatted string.</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-182/"></a><a href="srfi-182/"><span class="number">182</span></a>: <span class="name">ADBMAL, ALET, and ALET*</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2020-03-27</span></span><span class="keywords" data-keywords="data-structure,multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-2/">SRFI 2: AND-LET*: an AND with local bindings, a guarded LET* special form</a>, <a href="/srfi-11/">SRFI 11: Syntax for receiving multiple values</a>, <a href="/srfi-51/">SRFI 51: Handling rest list</a>, <a href="/srfi-54/">SRFI 54: Formatting</a>, <a href="/srfi-71/">SRFI 71: Extended LET-syntax for multiple values</a>, and <a href="/srfi-86/">SRFI 86: MU and NU simulating VALUES & CALL-WITH-VALUES, and their related LET-syntax</a>.</span><div class="abstract"><p>Unlike the VALUES and CALL-WITH-VALUES mechanism of R5RS, this one
uses an explicit representation for multiple return values as a single
value, namely a procedure.  Decomposition of multiple values is done
by simple application.  The macro, ADBMAL, evaluates to a procedure
that takes one procedure argument.  The ADBMAL macro can be compared
with LAMBDA.  While a LAMBDA expression that consists of
&lt;formals&gt; and &lt;body&gt; requires some actual arguments later
when the evaluated LAMBDA expression is called, an ADBMAL expression
that consists of &lt;expression&gt;s corresponding to actual arguments
of LAMBDA requires &lt;formals&gt; and &lt;body&gt;, that is, an
evaluated LAMBDA expression, later when the evaluated ADBMAL
expression is called.</p>

<p>This SRFI also introduces the new LET-syntax ALET and ALET*, which
depend on ADBMAL to manipulate multiple values, and which are
compatible with LET and LET* of R5RS in single-value bindings.  They
also have a binding form making use of VALUES and CALL-WITH-VALUES to
handle multiple values, and new binding forms for list, cons, and
other multiple values.  In addition, they have several new binding
forms for useful functions such as escape, iteration, optional
arguments, etc.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-181/"></a><a href="srfi-181/"><span class="number">181</span></a>: <span class="name">Custom ports (including transcoded ports)</span><span class="authors">, by John Cowan</span><span class="based-on">Based on R6RS.</span><span class="date-group">Final: <span class="date">2020-09-08</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-79/">SRFI 79: Primitive I/O</a>, <a href="/srfi-81/">SRFI 81: Port I/O</a>, <a href="/srfi-82/">SRFI 82: Stream Ports</a>, <a href="/srfi-91/">SRFI 91: Extended ports</a>, <a href="/srfi-186/">SRFI 186: Transcoders and transcoded ports</a>, and <a href="/srfi-192/">SRFI 192: Port Positioning</a>.</span><div class="abstract"><p>This SRFI is derived from parts of
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-1.html#node_toc_node_sec_8.2.4">
library section 8.2.4</a>,
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.7">
library section 8.2.7</a>,
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.10">
library section 8.2.10</a>, and
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.13">
library section 8.2.13</a>
of the R6RS.
These sections are themselves based on parts of
<a href="http://srfi.schemers.org/srfi-79/srfi-79.html">SRFI 79</a>,
<a href="http://srfi.schemers.org/srfi-80/srfi-80.html">SRFI 80</a> and
<a href="http://srfi.schemers.org/srfi-81/srfi-81.html">SRFI 81</a>.
These procedures provide a hook into the Scheme port system from below, allowing the
creation of custom ports that behave as much as possible like the standard
file, string, and bytevector ports, but that call a procedure to produce
data to input ports or to consume data from output ports.
Procedures for creating ports that transcode
between bytes and characters are an important special
case and are also documented in this SRFI.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-180/"></a><a href="srfi-180/"><span class="number">180</span></a>: <span class="name">JSON</span><span class="authors">, by Amirouche Boubekki</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-07-01</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><div class="abstract"><p>This library describes a JavaScript Object Notation (JSON) parser and printer.  It supports JSON that may be bigger than memory.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-179/"></a><a href="srfi-179/"><span class="number">179</span></a>: <span class="name">Nonempty Intervals and Generalized Arrays (Updated)</span><span class="authors">, by Bradley J. Lucier</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-06-30</span></span><span class="keywords" data-keywords="data-structure,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-122/">SRFI 122: Nonempty Intervals and Generalized Arrays</a> and <a href="/srfi-164/">SRFI 164: Enhanced multi-dimensional Arrays</a>.</span><div class="abstract"><p>This SRFI specifies an array mechanism for Scheme. Arrays as defined here are quite general; at their most basic, an array is simply a mapping, or function, from multi-indices of exact integers $i_0,\ldots,i_{d-1}$ to Scheme values.  The set of multi-indices $i_0,\ldots,i_{d-1}$ that are valid for a given array form the <i>domain</i> of the array.  In this SRFI, each array's domain consists  of the cross product of nonempty intervals of exact integers $[l_0,u_0)\times[l_1,u_1)\times\cdots\times[l_{d-1},u_{d-1})$ of $\mathbb Z^d$, $d$-tuples of integers.  Thus, we introduce a data type called $d$-<i>intervals</i>, or more briefly <i>intervals</i>, that encapsulates this notion. (We borrow this terminology from, e.g.,  Elias Zakon's <a href="http://www.trillia.com/zakon1.html">Basic Concepts of Mathematics</a>.) Specialized variants of arrays are specified to provide portable programs with efficient representations for common use cases.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-178/"></a><a href="srfi-178/"><span class="number">178</span></a>: <span class="name">Bitvector library</span><span class="authors">, by John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-08-25</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-151/">SRFI 151: Bitwise Operations</a> and <a href="/srfi-160/">SRFI 160: Homogeneous numeric vector libraries</a>.</span><div class="abstract"><p>This SRFI describes a set of operations on
homogeneous bitvectors.
Operations analogous to those provided on the other homogeneous
vector types described in
<a href="https://srfi.schemers.org/srfi-160/srfi-160.html">SRFI 160</a>
are provided,
along with operations analogous to the bitwise operations of
<a href="https://srfi.schemers.org/srfi-151/srfi-151.html">SRFI 151</a>.</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-177/"></a><a href="srfi-177/"><span class="number">177</span></a>: <span class="name">Portable keyword arguments</span><span class="authors">, by Lassi Kortela</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2020-07-31</span></span><span class="keywords" data-keywords="binding">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-88/">SRFI 88: Keyword objects</a> and <a href="/srfi-89/">SRFI 89: Optional positional and named parameters</a>.</span><div class="abstract"><p>Many Scheme implementations have keyword arguments, but they
have not been widely standardized. This SRFI defines the macros
<code>lambda/kw</code> and <code>call/kw</code>. They can be used
identically in every major implementation currently in use,
making it safe to use keyword arguments in portable code. The
macros expand to native keyword arguments in Schemes that have
them, letting programmers mix portable code and
implementation-specific code.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-176/"></a><a href="srfi-176/"><span class="number">176</span></a>: <span class="name">Version flag</span><span class="authors">, by Lassi Kortela</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-02-24</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><div class="abstract"><p>This SRFI defines a standard command-line flag to get version
  information from a Scheme implementation.  The output is
  Line-oriented S-expressions which are easy to parse from Scheme, C,
  and shell scripts and can co-exist with non-S-expression output.  A
  standard vocabulary is defined; extensions are easy to make.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-175/"></a><a href="srfi-175/"><span class="number">175</span></a>: <span class="name">ASCII character library</span><span class="authors">, by Lassi Kortela</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-12-20</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">  <p>This SRFI defines ASCII-only equivalents to many of the
  character procedures in standard Scheme plus a few extra ones.
  Recent Scheme standards are based around Unicode but the
  significant syntactic elements in many file formats and network
  protocols are all ASCII. Such low-level code can run faster and
  its behavior can be easier to understand when it uses ASCII
  primitives.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-174/"></a><a href="srfi-174/"><span class="number">174</span></a>: <span class="name">POSIX Timespecs</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-12-21</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-19/">SRFI 19: Time Data Types and Procedures</a> and <a href="/srfi-170/">SRFI 170: POSIX API</a>.</span><div class="abstract"><p>This SRFI defines the trivial type <i>timespec</i>, which is used
to represent the <code>struct timespec</code> defined by the
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html">
P<small>OSIX</small> <code>&lt;time.h&gt;</code> header</a>.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-173/"></a><a href="srfi-173/"><span class="number">173</span></a>: <span class="name">Hooks</span><span class="authors">, by Amirouche Boubekki</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-10-24</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="final"></span><div class="abstract"><p>This library describes a mechanism known as hooks.  Hooks are a
  certain kind of extension point in a program that allows
  interleaving the execution of arbitrary code with the execution of
  the program without introducing any coupling between the two.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-172/"></a><a href="srfi-172/"><span class="number">172</span></a>: <span class="name">Two Safer Subsets of R7RS</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-11-10</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="final"></span><div class="abstract"><p>This SRFI provides two libraries for use with R7RS that provide a
way to sandbox the <code>eval</code> procedure to make it safer to use
in evaluating Scheme expressions of doubtful provenance.  The intention
is to call <code>eval</code>, passing it an S-expression representing a
Scheme procedure and the environment defined by one of these libraries.
Since code evaluated by <code>eval</code> runs in a null lexical
environment, the resulting procedure can then be invoked with less
concern about possible side effects.
</p>

<p><b>Use of these libraries does not provide any sort of safety
guarantee.  There are still many loopholes uncaught, including
attempts to process circular structure and over-allocation of memory.
The claim is only that the probability of such an attack is reduced,
not that it is eliminated.
However, using these libraries is a simple provision that is easy to
implement and easy to use.  For higher safety, it can readily be
combined with other provisions.
</b></p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-171/"></a><a href="srfi-171/"><span class="number">171</span></a>: <span class="name">Transducers</span><span class="authors">, by Linus Björnstam</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-10-26</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract"><p>A library implementing transducers &mdash; composable algorithmic
  transformations.  Scheme has many different ways of expressing
  transformations over different collection types, but they are all
  unique to whatever base type they work on.  This SRFI proposes a new
  construct, the transducer, that is oblivious to the context in which
  it is being used.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-170/"></a><a href="srfi-170/"><span class="number">170</span></a>: <span class="name">POSIX API</span><span class="authors">, by Olin Shivers (original author), John Cowan (editor and shepherd), and Harold Ancell (implementer and editor)</span><span class="based-on">Based on scsh by Olin Shivers.</span><span class="date-group">Final: <span class="date">2020-10-28</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-198/">SRFI 198: Foreign Interface Status</a>.</span><div class="abstract"><p>
The host environment is the set of resources, such as the filesystem,
network and processes, that are managed by the operating system on top of
which a Scheme program is executing. This SRFI specifies some of the ways the host
environment can be accessed from within a Scheme program.  It does so by
leveraging widespread support for P<small>OSIX</small>, the Portable
Operating System Interface standardized by the IEEE.  Not all of the
functions of this SRFI are available on all operating systems.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-169/"></a><a href="srfi-169/"><span class="number">169</span></a>: <span class="name">Underscores in numbers</span><span class="authors">, by Lassi Kortela</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-07-26</span></span><span class="keywords" data-keywords="numbers,syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a>, <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract"><p>Many people find that large numbers are easier to read when the
  digits are broken into small groups.  For example, the number
  <code>1582439</code> might be easier to read if written as <code>1
  582 439</code>.  This applies to source code as it does to other
  writing.  We propose an extension of Scheme syntax to allow the
  underscore as a digit separator in numerical constants.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-168/"></a><a href="srfi-168/"><span class="number">168</span></a>: <span class="name">Generic Tuple Store Database</span><span class="authors">, by Amirouche Boubekki</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-11-08</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-167/">SRFI 167: Ordered Key Value Store</a> and <a href="/srfi-173/">SRFI 173: Hooks</a>.</span><div class="abstract"><p>This library is a generic approach to the database abstractions
  known as triplestore and quadstore.  Generic Tuple Store Database
  implements n-tuple ordered sets and associated primitives for
  working with them in the context of data management.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-167/"></a><a href="srfi-167/"><span class="number">167</span></a>: <span class="name">Ordered Key Value Store</span><span class="authors">, by Amirouche Boubekki</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-11-08</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-168/">SRFI 168: Generic Tuple Store Database</a> and <a href="/srfi-173/">SRFI 173: Hooks</a>.</span><div class="abstract"><p>This library describes an interface for an ordered key-value store
  that is suitable for implementing a storage engine for the generic
  tuple-store SRFI.  It maps cleanly to existing ordered key-value
  databases that may or may not provide transactions.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-166/"></a><a href="srfi-166/"><span class="number">166</span></a>: <span class="name">Monadic Formatting</span><span class="authors">, by Alex Shinn</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2020-07-30</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-13/">SRFI 13: String Libraries</a>, <a href="/srfi-159/">SRFI 159: Combinator Formatting</a>, and <a href="/srfi-165/">SRFI 165: The Environment Monad</a>.</span><div class="abstract"><p>
  A library of procedures for formatting Scheme objects to text in
  various ways, and for easily concatenating, composing and extending
  these formatters efficiently without resorting to capturing and
  manipulating intermediate strings.</p>

<p>
  This SRFI is an updated version of SRFI 159, primarily with the
  difference that state variables are hygienic.</p>

<p>
Summary of differences from SRFI 159:
<ul>
  <li>State variables are first class and hygienic</li>
  <li>Added <code>written-shared</code>, <code>pretty-shared</code></li>
  <li>Added <code>as-italic</code>, <code>as-color</code>, <code>as-true-color</code>, <code>on-<i>color</i></code> background variants, and <code>pretty-with-color</code></li>
  <li>Added <code>ambiguous-is-wide?</code> state variable and <code>string-terminal-width/wide</code> utility</li>
  <li>Added <code>substring/width</code> state var for width-aware substring operations, with <code>substring-terminal-width(/wide)</code> utilities</li>
  <li>Added <code>substring/preserve</code> state var used in trimming, with <code>substring-terminal-preserve</code> utility</li>
  <li>Added <code>pretty-environment</code> state variable</li>
  <li>Renamed <code>as-unicode</code> to <code>terminal-aware</code></li>
  <li>Restored non-uniform comma rules as needed in India</li>
  <li>Restored <code>upcased</code> and <code>downcased</code></li>
  <li>Several clarifications and more examples</li>
</ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-165/"></a><a href="srfi-165/"><span class="number">165</span></a>: <span class="name">The Environment Monad</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-09-05</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-159/">SRFI 159: Combinator Formatting</a> and <a href="/srfi-166/">SRFI 166: Monadic Formatting</a>.</span><div class="abstract">Monads model computations.  The environment monad models
computations that depend on values from a shared environment.
These computations can read values from the environment, pass
values to subsequent computations, execute sub-computations in an
extended environment, and modify the environment for future
computations.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-164/"></a><a href="srfi-164/"><span class="number">164</span></a>: <span class="name">Enhanced multi-dimensional Arrays</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-08-08</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-4/">SRFI 4: Homogeneous numeric vector datatypes</a>, <a href="/srfi-25/">SRFI 25: Multi-dimensional Array Primitives</a>, <a href="/srfi-122/">SRFI 122: Nonempty Intervals and Generalized Arrays</a>, and <a href="/srfi-163/">SRFI 163: Enhanced array literals</a>.</span><div class="abstract"><p>This SRFI describes the array data type (a generalization of
  vectors to multiple indexes or dimensions), along with a set of
  procedures for working on them.</p>
<p>This specification is an extension of <a href="http://srfi.schemers.org/srfi-25/srfi-25.html">SRFI 25</a>,
  with additions from Racket’s
  <a href="https://docs.racket-lang.org/math/array.html">math.array</a> package
  and other sources.  It has been implemented in the <a href="https://www.gnu.org/software/kawa/Arrays.html">Kawa dialect of Scheme</a>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-163/"></a><a href="srfi-163/"><span class="number">163</span></a>: <span class="name">Enhanced array literals</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-01-18</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-4/">SRFI 4: Homogeneous numeric vector datatypes</a>, <a href="/srfi-25/">SRFI 25: Multi-dimensional Array Primitives</a>, <a href="/srfi-48/">SRFI 48: Intermediate Format Strings</a>, <a href="/srfi-58/">SRFI 58: Array Notation</a>, <a href="/srfi-58/">SRFI 58: Array Notation</a>, <a href="/srfi-122/">SRFI 122: Nonempty Intervals and Generalized Arrays</a>, <a href="/srfi-160/">SRFI 160: Homogeneous numeric vector libraries</a>, and <a href="/srfi-164/">SRFI 164: Enhanced multi-dimensional Arrays</a>.</span><div class="abstract"><p>This is a specification of a reader form (literals)
for multi-dimensional arrays.
It is an extension of the Common Lisp array reader syntax to handle
non-zero lower bounds, optional explicit bounds,
and optional uniform element types (compatible with <a href="https://srfi.schemers.org/srfi-4">SRFI 4</a>).
It can be used in conjunction with <a href="https://srfi.schemers.org/srfi-25">SRFI 25</a>, <a href="https://srfi.schemers.org/srfi-122">SRFI 122</a>,
or  <a href="https://srfi.schemers.org/srfi-164">SRFI 164</a>.
These extensions were implemented in Guile (except the handling of rank-0 arrays),
and later in Kawa.
<p>There are recommendations for output formatting
and a suggested <code>format-array</code> procedure.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-162/"></a><a href="srfi-162/"><span class="number">162</span></a>: <span class="name">Comparators sublibrary</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-08-27</span></span><span class="keywords" data-keywords="comparison">Keywords: <a href="https://srfi.schemers.org/?keywords=comparison">Comparison</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-114/">SRFI 114: Comparators</a> and <a href="/srfi-128/">SRFI 128: Comparators (reduced)</a>.</span><div class="abstract"><p>
This SRFI provides a few extra procedures and comparators to go
with SRFI 128, Comparators.  Implementers are urged to add them to
their SRFI 128 libraries, for which reason they are not packaged
as a separate library.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-161/"></a><a href="srfi-161/"><span class="number">161</span></a>: <span class="name">Unifiable Boxes</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2019-02-08</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-111/">SRFI 111: Boxes</a>.</span><div class="abstract"><p>
  Unifiable boxes are, like the boxes
  of <a href="https://srfi.schemers.org/srfi-111/srfi-111.html">SRFI
    111</a>, objects with a single mutable state.  A constructor,
  predicate, accessor, and mutator are provided.
</p>

<p>
In addition to this, an equality predicate and union operations (link,
union, unify) are provided.  Applying a union operation to two
unifiable boxes makes the two boxes equal (in the sense of the
equality predicate).  As a consequence, their state will also become
identical.  In the case of link and union, it will be the state of one
of the two unioned boxes.  In the case of unify, the state is
determined by a supplied unification procedure.
</p>

<p>
  Unifiable boxes are
  also known under the names <i>disjoint-set data
    structure</i>, <i>union–find data structure</i> or <i>merge–find
    set</i>.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-160/"></a><a href="srfi-160/"><span class="number">160</span></a>: <span class="name">Homogeneous numeric vector libraries</span><span class="authors">, by John Cowan and Shiro Kawai (contributed a major patch)</span><span class="based-on">Based on SRFI 4 by Marc Feeley.</span><span class="date-group">Final: <span class="date">2019-08-27</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-tangerine">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-4/">SRFI 4: Homogeneous numeric vector datatypes</a>, <a href="/srfi-74/">SRFI 74: Octet-Addressed Binary Blocks</a>, <a href="/srfi-133/">SRFI 133: Vector Library (R7RS-compatible)</a>, and <a href="/srfi-152/">SRFI 152: String Library (reduced)</a>.</span><div class="abstract"><p>This SRFI describes a set of operations on SRFI 4 homogeneous vector
types (plus a few additional types) that are closely analogous
to the vector operations library,
<a href="http://srfi.schemers.org/srfi-133/srfi-133.html">
SRFI 133</a>.
An external representation is specified which may be supported by the
<code>read</code> and <code>write</code> procedures and by the program
parser so that programs can contain references to literal homogeneous
vectors.</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-159/"></a><a href="srfi-159/"><span class="number">159</span></a>: <span class="name">Combinator Formatting</span><span class="authors">, by Alex Shinn</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2020-07-31</span></span><span class="keywords" data-keywords="i/o,r7rs-large,r7rs-large-tangerine,superseded">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a>, <a href="https://srfi.schemers.org/?keywords=superseded">Superseded</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-28/">SRFI 28: Basic Format Strings</a>, <a href="/srfi-48/">SRFI 48: Intermediate Format Strings</a>, and <a href="/srfi-166/">SRFI 166: Monadic Formatting</a>.</span><div class="abstract"><p>A library of procedures for formatting Scheme objects to text in
  various ways, and for easily concatenating, composing and extending
  these formatters efficiently without resorting to capturing and
  manipulating intermediate strings.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-158/"></a><a href="srfi-158/"><span class="number">158</span></a>: <span class="name">Generators and Accumulators</span><span class="authors">, by Shiro Kawai, John Cowan, and Thomas Gilray</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-10-27</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-tangerine">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-121/">SRFI 121: Generators</a>.</span><div class="abstract"><p>This SRFI defines utility procedures that create, transform, and consume generators.
  A generator is simply a procedure with no arguments that works
  as a source of values.  Every time it is called,
  it yields a value.  Generators may be finite or infinite; a finite
  generator returns an end-of-file object to indicate that it is exhausted.
  For example, <code>read-char</code>, <code>read-line</code>,
  and <code>read</code> are generators that
  generate characters, lines, and objects from the current input port.
  Generators provide lightweight laziness.
</p>

<p>This SRFI also defines procedures that return accumulators.
  An accumulator is the inverse of a generator:  it is a procedure of one argument
  that works as a sink of values.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-157/"></a><a href="srfi-157/"><span class="number">157</span></a>: <span class="name">Continuation marks</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2018-01-29</span></span><span class="keywords" data-keywords="continuations">Keywords: <a href="https://srfi.schemers.org/?keywords=continuations">Continuations</a></span><span class="status" data-status="final"></span><div class="abstract"><p>
  Continuation marks are a programming language feature that allows
  one to attach information to and retrieve information from
  continuations, generalizing stack inspection.  Conceptually, a
  continuation consists of a number of frames where each frame stands
  for an active procedure call that is not a tail call.  A
  continuation mark is then a key-value pair associated with a frame,
  with keys compared using <code>eq?</code>.
  At most one mark for a given key can be attached to a single frame.
</p>

<p>
  Besides stack inspection, continuation marks can be used to
  implement dynamic scope, delimited continuations, or delayed
  evaluation that is able to handle iterative lazy algorithms.
</p>
<p>
  This SRFI proposes to add continuation marks to the Scheme
  programming language.  The interface defined here is modelled after
  Racket's continuation marks.  It does not include all forms and
  procedures provided by Racket but provides a compatible subset.
</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-156/"></a><a href="srfi-156/"><span class="number">156</span></a>: <span class="name">Syntactic combiners for binary predicates</span><span class="authors">, by Panicz Maciej Godek</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-12-18</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-26/">SRFI 26: Notation for Specializing Parameters without Currying</a>.</span><div class="abstract"><p>Recognizing binary predicates as a specific area
  in which the use of prefix operators is an impediment,
  we propose a thin layer of "syntactic stevia" for in-fixing
  such predicates. It can be implemented using regular Scheme
  macros. We suggest that the code <code>(is x &lt; y)</code> should
  be transformed to <code>(&lt; x y)</code>, and <code>(is x &lt; y &lt;= z)</code>
  -- to <code>(let ((y* y)) (and (&lt; x y*) (&lt;= y* z)))</code>.
  In addition, we suggest special meaning to the <code>_</code> symbol:
  <code>(is _ &lt; y)</code> and <code>(is x &lt; _)</code>
  should be transformed to <code>(lambda (_) (&lt; _ y))</code>
  and <code>(lambda (_) (&lt; x _))</code>, respectively.
  This SRFI document also describes some other uses of the
  <code>is</code> macro and its limitations.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-155/"></a><a href="srfi-155/"><span class="number">155</span></a>: <span class="name">Promises</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2018-09-15</span></span><span class="keywords" data-keywords="data-structure,lazy-evaluation">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=lazy-evaluation">Lazy Evaluation</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-45/">SRFI 45: Primitives for Expressing Iterative Lazy Algorithms</a>.</span><div class="abstract">	<p>
	  Scheme, like ML, is a programming language with strict evaluation
	  while others, like Haskell, use lazy evaluation.  Scheme, however,
	  possesses the primitives <code>delay</code> and <code>force</code>
	  that make it possible to express lazy algorithms.

	<p>
	  Lazy evaluation does not go well in conjunction with imperative,
	  non-functional, side-effecting code.  It should, however, be
	  applicable in a purely functional setting.  This is the case for the
	  delayed evaluation model as described in the R7RS as long as no
	  dynamically bound variables, also known as parameter objects, are
	  present.  It is the purpose of this SRFI to rework the specification
	  in the R7RS so that lazy evaluation works with purely functional code
	  that makes use of dynamic environments or, more generally, the dynamic
	  extent.  This is done by remembering the dynamic extent in effect when
	  the <code>delay</code> expression is evaluated.

	<p>
	  Another perceived misfeature of the R7RS model of delayed evaluation
	  is the apparent need of the <code>delay-force</code> special form to
	  express iterative lazy algorithms.  It is shown that
	  the <code>delay-force</code> special form is unneeded and that the
	  implementation can (and should) handle iterative lazy algorithms
	  without space leaks.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-154/"></a><a href="srfi-154/"><span class="number">154</span></a>: <span class="name">First-class dynamic extents</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2018-09-15</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-157/">SRFI 157: Continuation marks</a>.</span><div class="abstract"><p>Scheme has the notion of the <em>dynamic extent</em> of a
  procedure call.  A number of standard Scheme procedures and
  syntaxes
  like <code>dynamic-wind</code>, <code>call-with-current-continuation</code>,
  and <code>parameterize</code>
  deal with the dynamic extent indirectly.  The same holds true
  for the procedures and syntaxes dealing with continuation
  marks as defined by <a href="https://srfi.schemers.org/srfi-157/srfi-157.html">SRFI
  157</a>.</p>

<p>This SRFI reifies the dynamic extent into a first-class value
  together with a well-defined procedural interface and a syntax to
  create procedures that remember not only their environment at
  creation time but also their dynamic extent, which includes their
  dynamic environment.</p></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-153/"></a><a href="srfi-153/"><span class="number">153</span></a>: <span class="name">Ordered Sets</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2018-07-08</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="withdrawn"></span><div class="abstract"><p><em>Osets</em> are immutable collections that can contain any Scheme
  object. Osets enforce the constraint that no two elements can be the same
  in the sense of the oset's associated <em>equality predicate</em>
  The elements in an oset appear in a fixed order determined by the
  comparator used to create it.</p></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-152/"></a><a href="srfi-152/"><span class="number">152</span></a>: <span class="name">String Library (reduced)</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-10-04</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-130/">SRFI 130: Cursor-based string library</a> and <a href="/srfi-135/">SRFI 135: Immutable Texts</a>.</span><div class="abstract">      <p>Scheme has an impoverished set of
      string-processing utilities, which is a problem for authors of portable
      code. This SRFI proposes a coherent and comprehensive set of
      string-processing procedures. It is a reduced version of SRFI 13 that has
      been aligned with SRFI 135, Immutable Texts. Unlike SRFI 13, it has been
      made consistent with the R5RS, R6RS, and R7RS-small string
      procedures.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-151/"></a><a href="srfi-151/"><span class="number">151</span></a>: <span class="name">Bitwise Operations</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-07-10</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-tangerine,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-142/">SRFI 142: Bitwise Operations</a>.</span><div class="abstract">      <p>This SRFI proposes a coherent and comprehensive
      set of procedures for performing bitwise logical operations on integers;
      it is accompanied by a reference implementation of the spec in terms of a
      set of seven core operators. The sample implementation is portable, as
      efficient as practical with pure Scheme arithmetic (it is much more
      efficient to replace the core operators with C or assembly language if
      possible), and open source.
      <p>The precise semantics of these operators is
      almost never an issue. A consistent, portable set of <em>names</em> and
      <em>parameter conventions</em>, however, is. Hence this SRFI, which is
      based mainly on <a href="https://srfi.schemers.org/srfi-33/">SRFI 33</a>, with some changes and
      additions from <a href="http://srfi.schemers.org/srfi-33/mail-archive/msg00023.html">Olin's late
      revisions to SRFI 33</a> (which were never consummated). <a href="https://srfi.schemers.org/srfi-60/">SRFI 60</a> (based on SLIB) is smaller but has a few
      procedures of its own; some of its procedures have both native (often
      Common Lisp) and SRFI 33 names. They have been incorporated into this
      SRFI. <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4">
      R6RS</a> is a subset of SRFI 60, except that all procedure names begin
      with a <code>bitwise-</code> prefix. A few procedures have been added from
      the general vector <a href="https://srfi.schemers.org/srfi-133/">SRFI 133</a>.
      <p>Among the applications of bitwise operations
      are: hashing, Galois-field calculations of error-detecting and
      error-correcting codes, cryptography and ciphers, pseudo-random number
      generation, register-transfer-level modeling of digital logic designs,
      Fast-Fourier transforms, packing and unpacking numbers in persistent data
      structures, space-filling curves with applications to dimension reduction
      and sparse multi-dimensional database indexes, and generating approximate
      seed values for root-finders and transcendental function
      algorithms.
      <p>This SRFI differs from SRFI 142 in only two
      ways:
      <ol>
        <li>
          <p>The <code>bitwise-if</code> function has the
          argument ordering of SLIB, SRFI 60, and R6RS rather than the ordering
          of SRFI 33.
        <li>
          <p>The order in which bits are processed by
          the procedures listed in the "Bits conversion" section has been
          clarified and some of the procedures' names have been changed. See
          "Bit processing order" for details.
      </ol></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-150/"></a><a href="srfi-150/"><span class="number">150</span></a>: <span class="name">Hygienic ERR5RS Record Syntax (reduced)</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2018-01-16</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-9/">SRFI 9: Defining Record Types</a>, <a href="/srfi-99/">SRFI 99: ERR5RS Records</a>, and <a href="/srfi-131/">SRFI 131: ERR5RS Record Syntax (reduced)</a>.</span><div class="abstract">	<p>
	  This SRFI provides a specification and portable implementation of an
	  extension of the ERR5RS record syntax
	  of <a href="https://srfi.schemers.org/srfi-131/srfi-131.html">SRFI
	  131</a>, where field names inserted by macro transformers are
	  effectively renamed as if the macro transformer inserted a binding.
	  This makes this SRFI compatible with the semantics of the record-type
	  definitions of
	  the <a href="https://bitbucket.org/cowan/r7rs/src/draft-10/rnrs/r7rs.pdf">R7RS</a>
	  as intended by
	  its <a href="https://groups.google.com/d/msg/scheme-reports-wg2/oKuhgwaM45w/KXgPrh8oAwAJ">authors</a>.
	  In addition, field names may also be other types of Scheme datums,
	  like numbers and strings, or
	  <a href="https://srfi.schemers.org/srfi-88/srfi-88.html">SRFI 88</a> keyword objects.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-149/"></a><a href="srfi-149/"><span class="number">149</span></a>: <span class="name">Basic Syntax-rules Template Extensions</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-07-08</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>The rules for valid
      <code>&lt;template&gt;</code>s of <code>&lt;syntax rules&gt;</code> are
      slightly softened to allow for more than one consecutive
      <code>&lt;ellipsis&gt;</code> in subtemplates, and to allow pattern
      variables in subtemplates to be followed by more instances of the
      identifier <code>&lt;ellipsis&gt;</code> than they are followed in the
      subpattern in which they occur.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-148/"></a><a href="srfi-148/"><span class="number">148</span></a>: <span class="name">Eager syntax-rules</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-08-08</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Writing powerful <code>syntax-rules</code>
      macros is hard because they do not compose well: The arguments of a macro
      expansion are not expanded. This SRFI defines an easy to comprehend
      high-level system for writing powerful, composable (or <em>eager</em>)
      macros, two of whose defining features are that its macro arguments are
      (in general) eagerly expanded and that it can be portably implemented in
      any Scheme implementation conforming to the R7RS.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-147/"></a><a href="srfi-147/"><span class="number">147</span></a>: <span class="name">Custom macro transformers</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-03-07</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Each syntax definition assigns a macro
      transformer to a keyword. The macro transformer is specified by a
      transformer spec, which is either an instance of
      <code>syntax-rules</code>, an existing syntactic keyword (including macro
      keywords and the syntactic keywords that introduce the core forms, like
      <code>lambda</code>, <code>if</code>, or <code>define</code>), or a use
      of a macro that eventually expands into an instance of
      <code>syntax-rules</code>. In the latter case, the keyword of macro use
      is called a <em>custom macro transformer</em>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-146/"></a><a href="srfi-146/"><span class="number">146</span></a>: <span class="name">Mappings</span><span class="authors">, by Arthur A. Gleckler and Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2018-05-24</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-tangerine">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-224/">SRFI 224: Integer Mappings</a>.</span><div class="abstract">      <p><em>Mappings</em> are finite sets of
      associations, where each association is a pair consisting of a key and an
      arbitrary Scheme value. The keys are elements of a suitable domain. Each
      mapping holds no more than one association with the same key. The
      fundamental mapping operation is retrieving the value of an association
      stored in the mapping when the key is given.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-145/"></a><a href="srfi-145/"><span class="number">145</span></a>: <span class="name">Assumptions</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-03-31</span></span><span class="keywords" data-keywords="optimization">Keywords: <a href="https://srfi.schemers.org/?keywords=optimization">Optimization</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>A means to denote the invalidity of certain
      code paths in a Scheme program is proposed. It allows Scheme code to turn
      the evaluation into a user-defined error that need not be signalled by
      the implementation. Optimizing compilers may use these denotations to
      produce better code and to issue better warnings about dead code.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-144/"></a><a href="srfi-144/"><span class="number">144</span></a>: <span class="name">Flonums</span><span class="authors">, by John Cowan and Will Clinger</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-07-17</span></span><span class="keywords" data-keywords="numbers,r7rs-large,r7rs-large-tangerine">Keywords: <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes numeric procedures
      applicable to <em>flonums</em>, a subset of the inexact real numbers
      provided by a Scheme implementation. In most Schemes, the flonums and the
      inexact reals are the same. These procedures are semantically equivalent
      to the corresponding generic procedures, but allow more efficient
      implementations.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-143/"></a><a href="srfi-143/"><span class="number">143</span></a>: <span class="name">Fixnums</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-05-27</span></span><span class="keywords" data-keywords="numbers,r7rs-large,r7rs-large-tangerine">Keywords: <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes arithmetic procedures
      applicable to a limited range of exact integers only. These procedures
      are semantically similar to the corresponding generic-arithmetic
      procedures, but allow more efficient implementations.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-142/"></a><a href="srfi-142/"><span class="number">142</span></a>: <span class="name">Bitwise Operations</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2017-08-10</span></span><span class="keywords" data-keywords="data-structure,superseded">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=superseded">Superseded</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-151/">SRFI 151: Bitwise Operations</a>.</span><div class="abstract">      <p>This SRFI proposes a coherent and comprehensive
      set of procedures for performing bitwise logical operations on integers;
      it is accompanied by a reference implementation of the spec in terms of a
      set of seven core operators. The sample implementation is portable, as
      efficient as practical with pure Scheme arithmetic (it is worthwhile
      replacing the core operators with C or assembly language if possible),
      and open source.
      <p>The precise semantics of these operators is
      almost never an issue. A consistent, portable set of <em>names</em> and
      <em>parameter conventions</em>, however, is. Hence this SRFI, which is
      based mainly on <a href="https://srfi.schemers.org/srfi-33/">SRFI 33</a>, with some changes and
      additions from <a href="http://srfi.schemers.org/srfi-33/mail-archive/msg00023.html">Olin's late
      revisions to SRFI 33</a> (which were never consummated). <a href="https://srfi.schemers.org/srfi-60/">SRFI 60</a> (based on SLIB) is smaller but has a few
      procedures of its own; some of its procedures have both native (often
      Common Lisp) and SRFI 33 names. They have been incorporated into this
      SRFI. <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4">
      R6RS</a> is a subset of SRFI 60, except that all procedure names begin
      with a <code>bitwise-</code> prefix. A few procedures have been added from
      the general vector <a href="https://srfi.schemers.org/srfi-133/">SRFI 133</a>.
      <p>Among the applications of bitwise operations
      are: hashing, Galois-field calculations of error-detecting and
      error-correcting codes, cryptography and ciphers, pseudo-random number
      generation, register-transfer-level modeling of digital logic designs,
      Fast-Fourier transforms, packing and unpacking numbers in persistent data
      structures, space-filling curves with applications to dimension reduction
      and sparse multi-dimensional database indexes, and generating approximate
      seed values for root-finders and transcendental function
      algorithms.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-141/"></a><a href="srfi-141/"><span class="number">141</span></a>: <span class="name">Integer division</span><span class="authors">, by Taylor Campbell and John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-12-14</span></span><span class="keywords" data-keywords="numbers,r7rs-large,r7rs-large-tangerine">Keywords: <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI provides a fairly complete set of
      integral division and remainder operators.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-140/"></a><a href="srfi-140/"><span class="number">140</span></a>: <span class="name">Immutable Strings</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2017-05-24</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-118/">SRFI 118: Simple adjustable-size strings</a> and <a href="/srfi-135/">SRFI 135: Immutable Texts</a>.</span><div class="abstract">      <p>This attempts to solve the same issues with
      R7RS strings raised by <a href="https://srfi.schemers.org/srfi-135/">SRFI-135</a>, but with better
      integration with the Scheme language.
      <p>We propose to retain the name <dfn>string</dfn>
      as the type of sequences of Unicode characters (scalar values). There are
      two standard subtypes of string:
      <ul>
        <li>Immutable strings, also called
        <dfn>istrings</dfn>, cannot be modified after they have been created.
        Calling <code>string-set!</code> on an istring throws an error. On the
        other hand, the core operations <code>string-ref</code> and
        <code>string-length</code> are guaranteed to be O(1).
        <li>Mutable strings can be modified
        <q>in-place</q> using <code>string-set!</code> and other operations.
        However, <code>string-ref</code>, <code>string-set!</code>, or
        <code>string-length</code> have no performance guarantees. On many
        implementation they may take time proportional to the length of the
        string.
      </ul>
      <p>An implementation may support other kinds of
      strings. For example on the Java platform it may be reasonable to
      consider any instance of <code>java.lang.CharSequence</code> to be a
      string.
      <p>The main part of the proposal specifies the
      default bindings of various procedure names, as might be pre-defined in a
      REPL. Specifically, some procedures that traditionally return mutable
      strings are changed to return istrings. We later discuss compatibility
      and other library issues.
      <p>This combines <a href="https://srfi.schemers.org/srfi-13/">SRFI-13</a>,
      <a href="https://srfi.schemers.org/srfi-135/">SRFI-135</a>, and <a href="/srfi-118/">SRFI-118</a>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-139/"></a><a href="srfi-139/"><span class="number">139</span></a>: <span class="name">Syntax parameters</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-10-02</span></span><span class="keywords" data-keywords="binding,parameters">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=parameters">Parameters</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Syntax parameters are to the expansion process
      of a Scheme program what parameters are to the evaluation process of a
      Scheme program. They allow hygienic implementation of syntactic forms
      that would otherwise introduce implicit identifiers
      unhygienically.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-138/"></a><a href="srfi-138/"><span class="number">138</span></a>: <span class="name">Compiling Scheme programs to executables</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-09-28</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes, for sufficiently
      POSIX-compatible systems, a portable interface for compiling Scheme
      programs conforming to the R7RS to binaries that can be directly executed
      on the host system.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-137/"></a><a href="srfi-137/"><span class="number">137</span></a>: <span class="name">Minimal Unique Types</span><span class="authors">, by John Cowan and Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-10-04</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI is intended to standardize a
      primitive run-time mechanism to create disjoint types.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-136/"></a><a href="srfi-136/"><span class="number">136</span></a>: <span class="name">Extensible record types</span><span class="authors">, by Marc Nieper-Wißkirchen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-12-25</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>SRFI 9 and the compatible R7RS-small provide
      Scheme with record types. The basic problem that is solved by these
      record types is that they allow the user to introduce new types, disjoint
      from all existing types. The record type system described in this
      document is a conservative extension to SRFI 9 and R7RS record types (in
      other words, the keyword <code>define-record-type</code> defined in this
      specification can serve as the equally named keyword from SRFI 9 and R7RS
      and can thus be safely exported from <code>(srfi 9)</code> and
      <code>(scheme base)</code>) that is intended to solve another fundamental
      problem, namely the introduction of subtypes.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-135/"></a><a href="srfi-135/"><span class="number">135</span></a>: <span class="name">Immutable Texts</span><span class="authors">, by William D Clinger</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-09-06</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-118/">SRFI 118: Simple adjustable-size strings</a>, <a href="/srfi-130/">SRFI 130: Cursor-based string library</a>, <a href="/srfi-140/">SRFI 140: Immutable Strings</a>, and <a href="/srfi-152/">SRFI 152: String Library (reduced)</a>.</span><div class="abstract">      <p>In Scheme, strings are a mutable data type.
      Although it "is an error" (<abbr title="Revised&lt;sup&gt;5&lt;/sup&gt; Report on Scheme">R5RS</abbr> and
      <abbr title="Revised&lt;sup&gt;7&lt;/sup&gt; Report on Scheme">R7RS</abbr>) to use
      <code>string-set!</code> on literal strings or on strings returned by
      <code>symbol-&gt;string</code>, and any attempt to do so "should raise an
      exception" (<abbr title="Revised&lt;sup&gt;6&lt;/sup&gt; Report on Scheme">R6RS</abbr>), all
      other strings are mutable.
      <p>Although many mutable strings are never
      actually mutated, the mere possibility of mutation complicates
      specifications of libraries that use strings, encourages precautionary
      copying of strings, and precludes structure sharing that could otherwise
      be used to make procedures such as <code>substring</code> and
      <code>string-append</code> faster and more space-efficient.
      <p>This <abbr title="Scheme Request for Implementation">SRFI</abbr> specifies a new data type
      of immutable texts. It comes with efficient and portable sample
      implementations that guarantee O(1) indexing for both sequential and
      random access, even in systems whose <code>string-ref</code> procedure
      takes linear time.
      <p>The operations of this new data type include
      analogues for all of the non-mutating operations on strings specified by
      the R7RS and most of those specified by <abbr title="String cursors"><a href="https://srfi.schemers.org/srfi-130/">SRFI 130</a></abbr>, but the
      immutability of texts and uniformity of character-based indexing simplify
      the specification of those operations while avoiding several
      inefficiencies associated with the mutability of Scheme's strings.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-134/"></a><a href="srfi-134/"><span class="number">134</span></a>: <span class="name">Immutable Deques</span><span class="authors">, by Kevin Wortman and John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-07-01</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines immutable deques. A deque is
      a double-ended queue, a sequence which allows elements to be added or
      removed efficiently from either end. A structure is immutable when all
      its operations leave the structure unchanged. Note that none of the
      procedures specified here ends with an exclamation point.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-133/"></a><a href="srfi-133/"><span class="number">133</span></a>: <span class="name">Vector Library (R7RS-compatible)</span><span class="authors">, by John Cowan</span><span class="based-on">Based on SRFI 43 by Taylor Campbell.</span><span class="date-group">Final: <span class="date">2016-03-20</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-43/">SRFI 43: Vector library</a> and <a href="/srfi-160/">SRFI 160: Homogeneous numeric vector libraries</a>.</span><div class="abstract">      <p>This SRFI proposes a comprehensive library of
      vector operations accompanied by a freely available and complete
      reference implementation. The reference implementation is unencumbered by
      copyright, and useable with no modifications on any Scheme system that is
      R5RS-compliant. It also provides several hooks for
      implementation-specific optimization as well.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-132/"></a><a href="srfi-132/"><span class="number">132</span></a>: <span class="name">Sort Libraries</span><span class="authors">, by John Cowan</span><span class="based-on">Based on SRFI 32 by Olin Shivers.</span><span class="date-group">Final: <span class="date">2016-04-20</span></span><span class="keywords" data-keywords="algorithm,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=algorithm">Algorithm</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-32/">SRFI 32: Sort Libraries</a>.</span><div class="abstract">      <p>This SRFI describes the API for a full-featured
      sort toolkit.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-131/"></a><a href="srfi-131/"><span class="number">131</span></a>: <span class="name">ERR5RS Record Syntax (reduced)</span><span class="authors">, by John Cowan and Will Clinger</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-02-13</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-150/">SRFI 150: Hygienic ERR5RS Record Syntax (reduced)</a>.</span><div class="abstract">      <p>This SRFI is a reduced version of the SRFI 99
      syntactic layer that can be implemented with <code>syntax-rules</code>
      without requiring low-level macros. Like SRFI-99's syntax layer, it is
      backward compatible with the <code>define-record-type</code> macro from
      <a href="https://srfi.schemers.org/srfi-9/">SRFI 9</a> or R7RS-small. It is forward compatible with
      <a href="https://srfi.schemers.org/srfi-99/">SRFI 99</a>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-130/"></a><a href="srfi-130/"><span class="number">130</span></a>: <span class="name">Cursor-based string library</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-05-28</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-13/">SRFI 13: String Libraries</a>.</span><div class="abstract">      <p><abbr title="Revised&lt;sup&gt;5&lt;/sup&gt; Report on Scheme">R5RS</abbr> Scheme has
      an impoverished set of string-processing utilities, which is a problem
      for authors of portable code. Although <abbr title="Revised&lt;sup&gt;7&lt;/sup&gt; Report on Scheme">R7RS</abbr> provides
      some extensions and improvements, it is still very incomplete. This
      <abbr title="Scheme Request for Implementation">SRFI</abbr> proposes a
      coherent and comprehensive set of string-processing procedures; it is
      accompanied by a portable sample implementation of the spec.
      <p>This SRFI is derived from SRFI 13. The biggest
      difference is that it allows subsequences of strings to be specified by
      <em>cursors</em> as well as the traditional string indexes. In addition,
      it omits the comparison, case-mapping, and mutation operations of SRFI
      13, as well as all procedures already present in <abbr title="Revised&lt;sup&gt;7&lt;/sup&gt; Report on Scheme">R7RS</abbr>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-129/"></a><a href="srfi-129/"><span class="number">129</span></a>: <span class="name">Titlecase procedures</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-03-08</span></span><span class="keywords" data-keywords="internationalization">Keywords: <a href="https://srfi.schemers.org/?keywords=internationalization">Internationalization</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines R7RS-style
      <code>char-title-case?</code>, <code>char-titlecase</code>, and
      <code>string-titlecase</code> procedures.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-128/"></a><a href="srfi-128/"><span class="number">128</span></a>: <span class="name">Comparators (reduced)</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-02-14</span></span><span class="keywords" data-keywords="comparison">Keywords: <a href="https://srfi.schemers.org/?keywords=comparison">Comparison</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-114/">SRFI 114: Comparators</a> and <a href="/srfi-162/">SRFI 162: Comparators sublibrary</a>.</span><div class="abstract">      <p>This SRFI provides <i>comparators</i>, which
      bundle a type test predicate, an equality predicate, an ordering
      predicate, and a hash function (the last two are optional) into a single
      Scheme object. By packaging these procedures together, they can be
      treated as a single item for use in the implementation of data
      structures.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-127/"></a><a href="srfi-127/"><span class="number">127</span></a>: <span class="name">Lazy Sequences</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-01-18</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Lazy sequences (or lseqs, pronounced
      "ell-seeks") are a generalization of lists. In particular, an lseq is
      either a proper list or a dotted list whose last cdr is a <a href="https://srfi.schemers.org/srfi-121/">SRFI 121</a> generator. A generator is a procedure that can
      be invoked with no arguments in order to lazily supply additional
      elements of the lseq. When a generator has no more elements to return, it
      returns an end-of-file object. Consequently, lazy sequences cannot
      reliably contain end-of-file objects.
      <p>This SRFI provides a set of procedures suitable
      for operating on lazy sequences based on <a href="https://srfi.schemers.org/srfi-1/">SRFI
      1</a>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-126/"></a><a href="srfi-126/"><span class="number">126</span></a>: <span class="name">R6RS-based hashtables</span><span class="authors">, by Taylan Ulrich Bayırlı/Kammer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-02-01</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-69/">SRFI 69: Basic hash tables</a> and <a href="/srfi-125/">SRFI 125: Intermediate hash tables</a>.</span><div class="abstract">      <p>We provide a hashtable API that takes the R6RS
      hashtables API as a basis and makes backwards compatible additions such
      as support for weak hashtables, external representation, API support for
      double hashing implementations, and utility procedures.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-125/"></a><a href="srfi-125/"><span class="number">125</span></a>: <span class="name">Intermediate hash tables</span><span class="authors">, by John Cowan and Will Clinger</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2015-05-28</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-69/">SRFI 69: Basic hash tables</a> and <a href="/srfi-126/">SRFI 126: R6RS-based hashtables</a>.</span><div class="abstract">      <p>This SRFI defines an interface to hash tables,
      which are widely recognized as a fundamental data structure for a wide
      variety of applications. A hash table is a data structure that:
      <ul>
        <li>Is disjoint from all other types.
        <li>
          Provides a mapping from objects known as
          <em>keys</em> to corresponding objects known as
          <em>values</em>.
          <ul>
            <li>Keys may be any Scheme objects in some
            kinds of hash tables, but are restricted in other kinds.
            <li>Values may be any Scheme objects.
          </ul>
        <li>Has no intrinsic order for the key-value
        <em>associations</em> it contains.
        <li>Provides an <em>equality predicate</em>
        which defines when a proposed key is the same as an existing key. No
        table may contain more than one value for a given key.
        <li>Provides a <em>hash function</em> which maps
        a candidate key into a non-negative exact integer.
        <li>Supports mutation as the primary means of
        setting the contents of a table.
        <li>Provides key lookup and destructive update
        in (expected) amortized constant time, provided a satisfactory hash
        function is available.
        <li>Does not guarantee that whole-table
        operations work in the presence of concurrent mutation of the whole
        hash table (values may be safely mutated).
      </ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-124/"></a><a href="srfi-124/"><span class="number">124</span></a>: <span class="name">Ephemerons</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2015-11-06</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>An ephemeron is an object with two components
      called its <em>key</em> and its <em>datum</em>. It differs from an
      ordinary pair as follows: if the garbage collector (GC) can prove that
      there are no references to the key except from the ephemeron itself and
      possibly from the datum, then it is free to <em>break</em> the ephemeron,
      dropping its reference to both key and datum. In other words, an
      ephemeron can be broken when nobody else cares about its key. Ephemerons
      can be used to construct weak vectors or lists and (possibly in
      combination with finalizers) weak hash tables.
      <p>Much of this specification is derived with
      thanks from the MIT Scheme Reference Manual.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-123/"></a><a href="srfi-123/"><span class="number">123</span></a>: <span class="name">Generic accessor and modifier operators</span><span class="authors">, by Taylan Ulrich Bayırlı/Kammer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2015-10-14</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Lisp dialects including Scheme have
      traditionally lacked short, simple, generic syntax for accessing and
      modifying the fields of arbitrary "collection" objects. We fill this gap
      for Scheme by defining generalized accessors, and an associated SRFI-17
      setter.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-122/"></a><a href="srfi-122/"><span class="number">122</span></a>: <span class="name">Nonempty Intervals and Generalized Arrays</span><span class="authors">, by Bradley J. Lucier</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2016-12-24</span></span><span class="keywords" data-keywords="data-structure,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-164/">SRFI 164: Enhanced multi-dimensional Arrays</a> and <a href="/srfi-179/">SRFI 179: Nonempty Intervals and Generalized Arrays (Updated)</a>.</span><div class="abstract">      <p>This SRFI specifies an array mechanism for
      Scheme. Arrays as defined here are quite general; at their most basic, an
      array is simply a mapping, or function, from multi-indices of exact
      integers $i_0,\ldots,i_{d-1}$ to Scheme values. The set of multi-indices
      $i_0,\ldots,i_{d-1}$ that are valid for a given array form the
      <i>domain</i> of the array. In this SRFI, each array's domain consists of
      a rectangular interval
      $[l_0,u_0)\times[l_1,u_1)\times\cdots\times[l_{d-1},u_{d-1})$, a subset
      of $\mathbb Z^d$, $d$-tuples of integers. Thus, we introduce a data type
      called <i>intervals</i>, which encapsulate the cross product of nonempty
      intervals of exact integers. Specialized variants of arrays are specified
      to provide portable programs with efficient representations for common
      use cases.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-121/"></a><a href="srfi-121/"><span class="number">121</span></a>: <span class="name">Generators</span><span class="authors">, by Shiro Kawai, John Cowan, and Thomas Gilray</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2019-07-18</span></span><span class="keywords" data-keywords="data-structure,r7rs-large-red,superseded">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a>, <a href="https://srfi.schemers.org/?keywords=superseded">Superseded</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-158/">SRFI 158: Generators and Accumulators</a>.</span><div class="abstract">      <p>This SRFI defines utility procedures that
      create, transform, and consume generators. A generator is simply a
      procedure with no arguments that works as a source of a series of values.
      Every time it is called, it yields a value. Generators may be finite or
      infinite; a finite generator returns an end-of-file object to indicate
      that it is exhausted. For example, <code>read-char</code>,
      <code>read-line</code>, and <code>read</code> are generators that
      generate characters, lines, and objects from the current input port.
      Generators provide lightweight laziness.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-120/"></a><a href="srfi-120/"><span class="number">120</span></a>: <span class="name">Timer APIs</span><span class="authors">, by Takashi Kato</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2015-08-06</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines interfaces to handle timer
      processes.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-119/"></a><a href="srfi-119/"><span class="number">119</span></a>: <span class="name">wisp: simpler indentation-sensitive scheme</span><span class="authors">, by Arne Babenhauserheide</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2015-06-23</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes a simple syntax which
      allows making scheme easier to read for newcomers while keeping the
      simplicity, generality and elegance of s-expressions. Similar to <a href="https://srfi.schemers.org/srfi-110/">SRFI 110</a>, <a href="/srfi-49/">SRFI 49</a> and Python it
      uses indentation to group expressions. Like <a href="https://srfi.schemers.org/srfi-110/">SRFI
      110</a> wisp is general and homoiconic.
      <p>Different from its predecessors, wisp only uses
      the absolute minimum of additional syntax-elements which are required for
      writing and exchanging arbitrary code-structures. As syntax elements it
      only uses a colon surrounded by whitespace, the period followed by
      whitespace as first code-character on the line and optional underscores
      followed by whitespace at the beginning of the line.
      <p>It resolves a limitation of <a href="https://srfi.schemers.org/srfi-110/">SRFI 110</a> and <a href="/srfi-49/">SRFI 49</a>, both of
      which force the programmer to use a single argument per line if the
      arguments to a procedure need to be continued after a
      procedure-call.
      <p>Wisp expressions can include arbitrary
      s-expressions and as such provide backwards compatibility.
      <blockquote>
        <table>
          <tr>
            <th>wisp
            <th>s-exp
          <tr>
            <td>
              <pre>
<b>define</b> : <i>factorial</i> n
__  <b>if</b> : <i>zero?</i> n
____   . 1
____   <i>*</i> n : <i>factorial</i> (- n 1)

<i>display</i> : <i>factorial</i> 5
<i>newline</i>
</pre>
            <td>
              <pre>
(<b>define</b> (<i>factorial</i> n)
    (<b>if</b> (<i>zero?</i> n)
       1
       (<i>*</i> n (<i>factorial</i> (- n 1)))))

(<i>display</i> (<i>factorial</i> 5))
(<i>newline</i>)
</pre>
        </table>
      </blockquote></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-118/"></a><a href="srfi-118/"><span class="number">118</span></a>: <span class="name">Simple adjustable-size strings</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2015-07-07</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-135/">SRFI 135: Immutable Texts</a> and <a href="/srfi-140/">SRFI 140: Immutable Strings</a>.</span><div class="abstract">      <p>Scheme specifies mutable fixed-length strings.
      We add two procedures <code>string-append!</code> and
      <code>string-replace!</code> which allow the size of the string to
      change. We also require that the standard Scheme procedures
      <code>make-string</code> and <code>string-copy</code> return
      variable-size strings.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-117/"></a><a href="srfi-117/"><span class="number">117</span></a>: <span class="name">Queues based on lists</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2015-08-25</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>List queues are mutable ordered collections
      that can contain any Scheme object. Each list queue is based on an
      ordinary Scheme list containing the elements of the list queue by
      maintaining pointers to the first and last pairs of the list. It's cheap
      to add or remove elements from the front of the list or to add elements
      to the back, but not to remove elements from the back. List queues are
      disjoint from other types of Scheme objects.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-116/"></a><a href="srfi-116/"><span class="number">116</span></a>: <span class="name">Immutable List Library</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2014-11-28</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Scheme currently does not provide immutable
      pairs corresponding to its existing mutable pairs, although most uses of
      pairs do not exploit their mutability. The <a href="http://www.racket-lang.org">Racket</a> system takes the radical approach
      of making Scheme's pairs immutable, and providing a minimal library of
      mutable pairs with procedures named <code>mpair?, mcons, mcar, mcdr,
      set-mcar!, set-mcdr!</code>. This SRFI takes the opposite approach of
      leaving Scheme's pairs unchanged and providing a full set of routines for
      creating and dealing with immutable pairs. The sample implementation is
      portable (to systems with SRFI 9) and efficient.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-115/"></a><a href="srfi-115/"><span class="number">115</span></a>: <span class="name">Scheme Regular Expressions</span><span class="authors">, by Alex Shinn</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2014-07-14</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-tangerine">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-tangerine">R7RS Large: Tangerine Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI provides a library for matching
      strings with regular expressions described using the SRE "Scheme Regular
      Expression" notation first introduced by SCSH, and extended heavily by
      IrRegex.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-114/"></a><a href="srfi-114/"><span class="number">114</span></a>: <span class="name">Comparators</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2017-08-10</span></span><span class="keywords" data-keywords="comparison,superseded">Keywords: <a href="https://srfi.schemers.org/?keywords=comparison">Comparison</a>, <a href="https://srfi.schemers.org/?keywords=superseded">Superseded</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-128/">SRFI 128: Comparators (reduced)</a>.</span><div class="abstract">      <p>This proposal is a rewrite of <a href="https://srfi.schemers.org/srfi-67/">SRFI 67</a>, Compare Procedures, extending it from procedures
      that represent a total order to procedure bundles that represent one or
      more of a total order, an equality predicate, and a hash function. By
      packaging these procedures together, along with a type test predicate,
      they can be treated as a single item for use in the implementation of
      data structures.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-113/"></a><a href="srfi-113/"><span class="number">113</span></a>: <span class="name">Sets and bags</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2014-11-28</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-217/">SRFI 217: Integer Sets</a>.</span><div class="abstract">      <p><em>Sets</em> and <em>bags</em> (also known as
      multisets) are unordered collections that can contain any Scheme object.
      Sets enforce the constraint that no two elements can be the same in the
      sense of the set's associated <em>equality predicate</em>; bags do
      not.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-112/"></a><a href="srfi-112/"><span class="number">112</span></a>: <span class="name">Environment Inquiry</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2013-09-12</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This is a proposal for environment inquiry,
      providing human-readable information <em>at run time</em> about the
      hardware and software configuration on which a Scheme program is being
      executed. They are mostly based on Common Lisp, with additions from the
      Posix <code>uname()</code> system call.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-111/"></a><a href="srfi-111/"><span class="number">111</span></a>: <span class="name">Boxes</span><span class="authors">, by John Cowan</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2013-07-03</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-195/">SRFI 195: Multiple-value boxes</a>.</span><div class="abstract">      <p>Boxes are objects with a single mutable state.
      Several Schemes have them, sometimes called <i>cells</i>. A constructor,
      predicate, accessor, and mutator are provided.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-110/"></a><a href="srfi-110/"><span class="number">110</span></a>: <span class="name">Sweet-expressions (t-expressions)</span><span class="authors">, by David A. Wheeler and Alan Manuel K. Gloria</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2013-09-09</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes a set of syntax extensions
      for Scheme, called sweet-expressions (t-expressions), that has the same
      descriptive power as s-expressions but is designed to be easier for
      humans to read. The sweet-expression syntax enables the use of
      syntactically-meaningful indentation to group expressions (similar to
      Python), and it builds on the infix and traditional function notation
      defined in <a href="https://srfi.schemers.org/srfi-105/">SRFI-105 (curly-infix-expressions)</a>.
      Unlike nearly all past efforts to improve s-expression readability,
      sweet-expressions are general (the notation is independent from any
      underlying semantic) and homoiconic (the underlying data structure is
      clear from the syntax). This notation was developed by the “<a href="http://readable.sourceforge.net/">Readable Lisp S-expressions
      Project</a>” and can be used for both programs and data.
      <p>Sweet-expressions can be considered a set of
      additional abbreviations, just as <code>'x</code> already abbreviates
      <code>(quote&nbsp;x)</code>. Sweet-expressions and traditionally formatted
      s-expressions can be freely mixed; this provides backwards compatibility,
      simplifies transition, and enables developers to maximize readability.
      Here is an example of a sweet-expression and its equivalent s-expression
      (note that a sweet-expression reader would accept <em>either</em>
      format):
      <table border="1" cellpadding="4">
        <tr>
          <th>sweet-expression
          <th>s-expression
        <tr>
          <td>
            <pre>
define fibfast(n)   ; Typical function notation
  if {n &lt; 2}        ; Indentation, infix {...}
     n              ; Single expr = no new list
     fibup n 2 1 0  ; Simple function calls
</pre>
          <td>
            <pre>
(define (fibfast n)
  (if (&lt; n 2)
      n
      (fibup n 2 1 0)))
</pre>
      </table></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-109/"></a><a href="srfi-109/"><span class="number">109</span></a>: <span class="name">Extended string quasi-literals</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2013-06-21</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-107/">SRFI 107: XML reader syntax</a> and <a href="/srfi-108/">SRFI 108: Named quasi-literal constructors</a>.</span><div class="abstract">      <p>This specifies a reader extension for extended
      string quasi-literals, including nicer multi-line strings, and enclosed
      unquoted expressions.
      <p>This proposal is related to <a href="https://srfi.schemers.org/srfi-108/">SRFI-108 (named quasi-literal constructors)</a> and <a href="/srfi-107/">SRFI-107 (XML reader syntax)</a>, as they share quite a bit
      of syntax.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-108/"></a><a href="srfi-108/"><span class="number">108</span></a>: <span class="name">Named quasi-literal constructors</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2013-06-21</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This specifies an extensible reader syntax for
      named value constructors. A reader prefix is followed by a <q>tag</q> (an
      identifier), and then expressions and literal text parameters. The tag
      can be though of as a class name, and the expression and literal text are
      arguments to an object constructor call. The reader translates
      <code>&amp;<var>tag</var>{...}</code> to a list
      <code>($construct$:<var>tag</var> ...)</code>, where
      <code>$construct$:<var>tag</var></code> is normally bound to a predefined
      macro.
      <p>This propsal depends on <a href="https://srfi.schemers.org/srfi-109/">SRFI-109 (extended string quasi-literals)</a> (in spite of
      having a lower number). It also shares quite of bit of syntax with
      <a href="https://srfi.schemers.org/srfi-107/">SRFI-107 (XML reader syntax)</a>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-107/"></a><a href="srfi-107/"><span class="number">107</span></a>: <span class="name">XML reader syntax</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2013-12-22</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>We specify a reader extension that reads data
      in a superset of XML/HTML format, and produces conventional
      S-expressions. We also suggest a possible semantics interpretation of how
      these forms may be evaluated to produce XML-node values, but this is
      non-normative.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-106/"></a><a href="srfi-106/"><span class="number">106</span></a>: <span class="name">Basic socket interface</span><span class="authors">, by Takashi Kato</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2013-08-20</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This document specifies basic socket
      interfaces.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-105/"></a><a href="srfi-105/"><span class="number">105</span></a>: <span class="name">Curly-infix-expressions</span><span class="authors">, by David A. Wheeler and Alan Manuel K. Gloria</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2012-11-06</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Lisp-based languages, like Scheme, are almost
      the only programming languages in modern use that do not support infix
      notation. In addition, most languages allow infix expressions to be
      combined with function call notation of the form
      <code><var>f</var>(<var>x</var>)</code>. This SRFI provides these
      capabilities, both for developers who already use Scheme and want these
      conveniences, and also for other developers who may choose to use other
      languages in part because they miss these conveniences. Scheme currently
      reserves <code>{</code>...<code>}</code> “for possible future extensions
      to the language”. We propose that <code>{</code>...<code>}</code> be used
      to support “curly-infix-expression” notation as a homoiconic infix
      abbreviation, as a modification of the Scheme reader. It is an
      abbreviation in much the same way that <samp>'x</samp> is an abbreviation
      for <samp>(quote&nbsp;x)</samp>.
      <p>A <dfn>curly-infix list</dfn> introduces a list
      whose visual presentation can be in infix order instead of prefix order.
      For example, <samp>{n&nbsp;&gt;&nbsp;5}</samp> ⇒
      <samp>(&gt;&nbsp;n&nbsp;5)</samp>, and
      <samp>{a&nbsp;+&nbsp;b&nbsp;+&nbsp;c}</samp> ⇒
      <samp>(+&nbsp;a&nbsp;b&nbsp;c)</samp>. By intent, there is no precedence,
      but e.g., <samp>{x&nbsp;+&nbsp;{y&nbsp;*&nbsp;z}}</samp> maps cleanly to
      <samp>(+&nbsp;x&nbsp;(*&nbsp;y&nbsp;z))</samp>. Forms with mixed infix
      operators and other complications have “<code>$nfx$</code>” prepended to
      enable later processing, e.g.,
      <samp>{4&nbsp;+&nbsp;5&nbsp;*&nbsp;6}</samp> ⇒
      <samp>($nfx$&nbsp;4&nbsp;+&nbsp;5&nbsp;*&nbsp;6)</samp>. Also, inside a
      curly-infix list (recursively), expressions of the form
      <code><var>f</var>(</code>...<code>)</code> are simply an abbreviation
      for <code>(<var>f</var>&nbsp;</code>...<code>)</code>.
      <p>Note that this is derived from the “<a href="http://readable.sourceforge.net/">readable</a>” project. We intend to
      later submit at least one additional SRFI that will build on top of this
      SRFI, but curly-infix-expressions are useful on their own.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-104/"></a><a href="srfi-104/"><span class="number">104</span></a>: <span class="name">Library Files Utilities</span><span class="authors">, by Derick Eddington</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2010-05-23</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI implements <a href="https://srfi.schemers.org/srfi-103/">SRFI&nbsp;103: Library Files</a> as a library. It is useful
      for working with library files.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-103/"></a><a href="srfi-103/"><span class="number">103</span></a>: <span class="name">Library Files</span><span class="authors">, by Derick Eddington</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2013-05-08</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines a standard for locating files
      containing libraries with list-of-symbols library names, for unixes and
      Windows. It defines a standard for files containing R6RS libraries. It
      supports different Scheme dialects.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-102/"></a><a href="srfi-102/"><span class="number">102</span></a>: <span class="name">Procedure Arity Inspection</span><span class="authors">, by David Van Horn</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2013-02-24</span></span><span class="keywords" data-keywords="introspection">Keywords: <a href="https://srfi.schemers.org/?keywords=introspection">Introspection</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Many Scheme systems provide mechanisms for
      inspecting the arity of a procedural value, making it a common feature,
      however there is no standard interface. As a result there is no portable
      way to observe the arity of a procedure <em>without actually applying
      it</em>. This SRFI proposes a simple interface that is consistent with
      existing Scheme systems' facilities and prior proposals.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-101/"></a><a href="srfi-101/"><span class="number">101</span></a>: <span class="name">Purely Functional Random-Access Pairs and Lists</span><span class="authors">, by David Van Horn</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2013-02-24</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Random-access lists [1] are a purely functional
      data structure for representing lists of values. A random-access list may
      act as a drop in replacement for the usual linear-access pair and list
      data structures (<code>pair?</code>, <code>cons</code>, <code>car</code>,
      <code>cdr</code>), which additionally supports fast index-based
      addressing and updating (<code>list-ref</code>, <code>list-set</code>).
      The impact is a whole class of purely-functional algorithms expressed in
      terms of index-based list addressing become feasible compared with their
      linear-access list counterparts.
      <p>This document proposes a library API for purely
      functional random-access lists consistent with the R<sup>6</sup>RS [2]
      base library and list utility standard library [3].</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-100/"></a><a href="srfi-100/"><span class="number">100</span></a>: <span class="name">define-lambda-object</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2010-06-21</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI introduces a macro,
      DEFINE-LAMBDA-OBJECT which defines a set of procedures, that is, a group,
      two constructors, and a predicate. The constructors also make a group of
      procedures, namely lambda objects. The macro extends DEFINE-RECORD-TYPE
      (SRFI 9) in being more general but much less general than DEFCLASS
      (CLOS). The macro has no explicit field accessors and mutators but parent
      groups, required fields, optional fields, automatic fields, read-write
      fields, read-only fields, inaccessible hidden fields, immutable virtual
      fields, and common sharing fields.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-99/"></a><a href="srfi-99/"><span class="number">99</span></a>: <span class="name">ERR5RS Records</span><span class="authors">, by William D Clinger</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2009-10-07</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Many Scheme programmers have considered records
      to be one of the most important features missing from the R5RS. The R6RS
      proposed a record system, but its design has been widely criticized and
      it was not intended for use in R5RS programs anyway.
      <p>This SRFI proposes a better record system for
      use in R5RS, ERR5RS, and R6RS programs. The syntactic layer of this
      SRFI's record system is an extension of SRFI 9. The procedural and
      inspection layers of this SRFI's record system are perfectly compatible
      with its syntactic layer. This entire SRFI is compatible with the
      procedural and inspection layers of the R6RS record system, but offers
      several worthwhile improvements over the R6RS system.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-98/"></a><a href="srfi-98/"><span class="number">98</span></a>: <span class="name">An interface to access environment variables</span><span class="authors">, by Taro Minowa (Higepon)</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2008-09-19</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI specifies the procedure
      get-environment-variable, which gets the value of the specified
      environment variable, and the procedure get-environment-variables, which
      gets an association list of all environment variables.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-97/"></a><a href="srfi-97/"><span class="number">97</span></a>: <span class="name">SRFI Libraries</span><span class="authors">, by David Van Horn</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2008-12-22</span></span><span class="keywords" data-keywords="modules">Keywords: <a href="https://srfi.schemers.org/?keywords=modules">Modules</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Over the past ten years, numerous libraries
      have been specified via the Scheme Requests for Implementation process.
      Yet until the recent ratification of the Revised<sup>6</sup> Report on
      the Algorithmic Language Scheme, there has been no standardized way of
      distributing or relying upon library code. Now that such a library system
      exists, there is a real need to organize these existing SRFI libraries so
      that they can be portably referenced.
      <p>This SRFI is designed to facilitate the writing
      and distribution of code that relies on SRFI libraries. It identifies a
      subset of existing SRFIs that specify features amenable to provision (and
      possibly implementation) as libraries (SRFI Libraries) and proposes a
      naming convention for this subset so that these libraries may be referred
      to by name or by number. <!--
This convention represents a consensus among current R<sup>6</sup>RS
implementors.
      --></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-96/"></a><a href="srfi-96/"><span class="number">96</span></a>: <span class="name">SLIB Prerequisites</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2008-07-07</span></span><span class="keywords" data-keywords="features">Keywords: <a href="https://srfi.schemers.org/?keywords=features">Features</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI specifies a set of procedures and
      macros presenting a uniform interface sufficient to host the <a href="http://swiss.csail.mit.edu/~jaffer/SLIB">SLIB Scheme Library</a>
      system.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-95/"></a><a href="srfi-95/"><span class="number">95</span></a>: <span class="name">Sorting and Merging</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2007-01-29</span></span><span class="keywords" data-keywords="algorithm">Keywords: <a href="https://srfi.schemers.org/?keywords=algorithm">Algorithm</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Sorting and Merging are useful operations
      deserving a common API.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-94/"></a><a href="srfi-94/"><span class="number">94</span></a>: <span class="name">Type-Restricted Numerical Functions</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2007-01-30</span></span><span class="keywords" data-keywords="numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>In the coding of numerial calculations in
      latent-typed languages it is good practice to assure that those
      calculations are using the intended number system. The most common number
      systems for programmatic calculations are the integers, reals, and
      complexes. This SRFI introduces 14 real-only and 3 integer-only variants
      of R5RS procedures to facilitate numerical type checking and
      declaration.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-93/"></a><a href="srfi-93/"><span class="number">93</span></a>: <span class="name">R6RS Syntax-Case Macros</span><span class="authors">, by Kent Dybvig</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-08-23</span></span><span class="keywords" data-keywords="syntax,r6rs-process">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a>, <a href="https://srfi.schemers.org/?keywords=r6rs-process">R6RS process</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-188/">SRFI 188: Splicing binding constructs for syntactic keywords</a>.</span><div class="abstract">      <p>The syntactic abstraction system described here
      extends the R5RS macro system with support for writing low-level macros
      in a high-level style, with automatic syntax checking, input
      destructuring, output restructuring, maintenance of lexical scoping and
      referential transparency (hygiene), and support for controlled identifier
      capture, with constant expansion overhead. Because it does not require
      literals, including quoted lists or vectors, to be copied or even
      traversed, it preserves sharing and cycles within and among the constants
      of a program. It also supports source-object correlation, i.e., the
      maintenance of ties between the original source code and expanded output,
      allowing implementations to provide source-level support for debuggers
      and other tools.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-92/"></a><a href="srfi-92/"><span class="number">92</span></a>: <span class="name">ALAMBDA and ALAMBDA*</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2007-04-09</span></span><span class="keywords" data-keywords="miscellaneous,type-checking">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a>, <a href="https://srfi.schemers.org/?keywords=type-checking">Type Checking</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI introduces ALAMBDA and ALAMBDA*, each
      of which has two modes of operation:
      <ol>
        <li>it creates a procedure that checks actual
        arguments and takes optional arguments,
        <li>it returns a different procedure by checking
        each of actual arguments and the number of them.
      </ol></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-91/"></a><a href="srfi-91/"><span class="number">91</span></a>: <span class="name">Extended ports</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2007-07-10</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI specifies an extension to the R5RS
      ports that supports several useful features: binary I/O and text I/O,
      bulk I/O, file opening attributes, and bidirectional ports. Binary I/O is
      provided through byte ports which are ports whose fundamental I/O unit is
      an 8 bit byte. Because characters can be encoded with bytes using a
      character encoding such as ISO 8859-1, UTF-8, and UTF-16BE, any byte port
      is also a character port (a port that supports the character level I/O of
      R5RS). A byte port's character encoding and various other attributes are
      specified when the port is opened. Because reasonable defaults exist,
      these attributes are specified using a named optional parameter syntax.
      All procedures which have the same name as in R5RS are compatible with
      R5RS but may provide additional functionality.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-90/"></a><a href="srfi-90/"><span class="number">90</span></a>: <span class="name">Extensible hash table constructor</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2007-07-10</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI specifies the procedure
      <code>make-table</code>, a hash table constructor compatible with <a href="https://srfi.schemers.org/srfi-69/">SRFI 69 (Basic hash tables)</a>. The procedure
      <code>make-table</code> allows various parameters of the hash table to be
      specified with optional named parameters when it is constructed. These
      parameters are: the initial size, the minimum and maximum load factor,
      the key equivalence function, the key hashing function, whether the
      references to the keys are weak, and similarly for the values. By using
      optional named parameters, as specified in <a href="https://srfi.schemers.org/srfi-89/">SRFI 89
      (Optional positional and named parameters)</a>, the constructor's API can
      be easily extended in a backward compatible way by other SRFIs and Scheme
      implementations.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-89/"></a><a href="srfi-89/"><span class="number">89</span></a>: <span class="name">Optional positional and named parameters</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2007-07-10</span></span><span class="keywords" data-keywords="binding">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-88/">SRFI 88: Keyword objects</a> and <a href="/srfi-177/">SRFI 177: Portable keyword arguments</a>.</span><div class="abstract">      <p>This SRFI specifies the <code>define*</code> and
      <code>lambda*</code> special forms. These forms extend the R5RS
      <code>define</code> and <code>lambda</code> special forms to simplify the use of
      optional positional and named parameters. Optional positional parameters,
      optional named parameters and required named parameters are covered by
      this SRFI. The formal parameter list syntax specified in this SRFI is
      different from the syntax used by Common Lisp and the DSSSL languages but
      nevertheless offers similar functionality and a nicer syntax. Formal
      parameter lists which conform to the R5RS syntax have the same meaning as
      in R5RS.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-88/"></a><a href="srfi-88/"><span class="number">88</span></a>: <span class="name">Keyword objects</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2007-07-03</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-89/">SRFI 89: Optional positional and named parameters</a> and <a href="/srfi-177/">SRFI 177: Portable keyword arguments</a>.</span><div class="abstract">      <p>This SRFI defines <i>keyword</i> objects, a
      data type similar to Scheme symbols. Keyword objects have the same
      lexical syntax as symbols but they must end in a colon. Moreover keyword
      objects are self-evaluating. Procedures for converting between strings
      and keyword objects (<code>string-&gt;keyword</code> and
      <code>keyword-&gt;string</code>) and a type predicate (<code>keyword?</code>) are
      defined. Finally this SRFI specifies the changes to the Scheme lexical
      syntax required to accomodate keywords.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-87/"></a><a href="srfi-87/"><span class="number">87</span></a>: <span class="name">=> in case clauses</span><span class="authors">, by Chongkai Zhu</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2006-10-18</span></span><span class="keywords" data-keywords="control-flow">Keywords: <a href="https://srfi.schemers.org/?keywords=control-flow">Control Flow</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI proposes an extension to the
      <code>case</code> syntax to allow the <code>=&gt;</code> clauses as in
      <code>cond</code>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-86/"></a><a href="srfi-86/"><span class="number">86</span></a>: <span class="name">MU and NU simulating VALUES & CALL-WITH-VALUES, and their related LET-syntax</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2006-06-20</span></span><span class="keywords" data-keywords="data-structure,multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Unlike the
      <code>values</code>/<code>call-with-values</code> mechanism of R5RS, this
      SRFI uses an explicit representation for multiple return values as a
      single value, namely a procedure. Decomposition of multiple values is
      done by simple application. Each of the two macros, <code>mu</code> and
      <code>nu</code>, evaluates to a procedure that takes one procedure
      argument. The <code>mu</code> and <code>nu</code> can be compared with
      <code>lambda</code>. While <code>lambda</code> expression that consists
      of &lt;formals&gt; and &lt;body&gt; requires some actual arguments later
      when the evaluated <code>lambda</code> expression is called,
      <code>mu</code> and <code>nu</code> expressions that consist of
      &lt;expression&gt;s corresponding to actual arguments of
      <code>lambda</code> require &lt;formals&gt; and &lt;body&gt;, that is, an
      evaluated <code>lambda</code> expression, later when the evaluated
      <code>mu</code> and <code>nu</code> expressions are called.
      <p>This SRFI also introduces new
      <code>let</code>-syntax depending on <code>mu</code> and <code>nu</code>
      to manipulate multiple values, <code>alet</code> and <code>alet*</code>
      that are compatible with <code>let</code> and <code>let*</code> of R5RS
      in single value bindings. They also have a binding form making use of
      <code>values</code> and <code>call-with-values</code> to handle multiple
      values. In addition, they have several new binding forms for useful
      functions such as escape, recursion, etc.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-85/"></a><a href="srfi-85/"><span class="number">85</span></a>: <span class="name">Recursive Equivalence Predicates</span><span class="authors">, by William D Clinger</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-10-21</span></span><span class="keywords" data-keywords="comparison">Keywords: <a href="https://srfi.schemers.org/?keywords=comparison">Comparison</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines two related equivalence
      predicates that are recursive, not just partial recursive: they terminate
      on all arguments. One of these predicates, <code>equiv?</code>, is
      consistent with the <code>equal?</code> procedure described in the R5RS:
      Whenever <code>equal?</code> terminates, <code>equiv?</code> returns the
      same value as <code>equal?</code>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-84/"></a><a href="srfi-84/"><span class="number">84</span></a>: <span class="name">Universal Identifiers</span><span class="authors">, by Andrew Wilcox</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-11-09</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI proposes a social convention to allow
      programmers to easily create short, simple Scheme symbols which are
      guaranteed to be universally unique: No other programmer also following
      this SRFI will accidentally create a symbol eq? to yours.
      <p>Universally unique symbols are useful to
      identify standards, languages, libraries, types, classes, and other
      resources.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-83/"></a><a href="srfi-83/"><span class="number">83</span></a>: <span class="name">R6RS Library Syntax</span><span class="authors">, by Matthew Flatt and Kent Dybvig</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-09-13</span></span><span class="keywords" data-keywords="modules,r6rs-process">Keywords: <a href="https://srfi.schemers.org/?keywords=modules">Modules</a>, <a href="https://srfi.schemers.org/?keywords=r6rs-process">R6RS process</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>The module system presented here is designed to
      let programmers share libraries, i.e., code that is intended to be
      incorporated into larger programs, and especially into programs that use
      library code from multiple sources. The module system supports macro
      definitions within modules, allows macro exports, and distinguishes the
      phases in which definitions and imports are needed. This SRFI defines a
      standard notation for libraries, a semantics for library expansion and
      execution, and a simple format for sharing libraries.
      <!-- ISSUES --></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-82/"></a><a href="srfi-82/"><span class="number">82</span></a>: <span class="name">Stream Ports</span><span class="authors">, by Michael Sperber</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-11-20</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI augments <a href="https://srfi.schemers.org/srfi-81/">SRFI 81
      (Port I/O)</a> by allowing ports to be constructed from streams as
      described in <a href="https://srfi.schemers.org/srfi-80/">SRFI 80 (Stream I/O)</a>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-81/"></a><a href="srfi-81/"><span class="number">81</span></a>: <span class="name">Port I/O</span><span class="authors">, by Michael Sperber</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-11-20</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-80/">SRFI 80: Stream I/O</a> and <a href="/srfi-186/">SRFI 186: Transcoders and transcoded ports</a>.</span><div class="abstract">      <p>This SRFI defines an I/O layer similar in
      nature to the ports subsystem in R5RS, and provides conventional,
      imperative buffered input and output.
      <p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      <p>In particular, the subsystem fulfills the
      following requirements:
      <ul>
        <li>buffered reading and writing
        <li>binary and text I/O, mixed if needed
        <li>the ability to create arbitrary I/O ports
        from readers and writers
      </ul>
      <p>It builds on the Primitive I/O layer specified
      in <a href="https://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-80/"></a><a href="srfi-80/"><span class="number">80</span></a>: <span class="name">Stream I/O</span><span class="authors">, by Michael Sperber</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-11-20</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-81/">SRFI 81: Port I/O</a> and <a href="/srfi-186/">SRFI 186: Transcoders and transcoded ports</a>.</span><div class="abstract">      <p>This SRFI defines an I/O layer for lazy, mostly
      functional buffered streams.
      <p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      <p>In particular, this layer provides
      <ul>
        <li>buffered reading and writing
        <li>arbitrary lookahead
        <li>dynamic redirection of input or
        output
        <li>binary and text I/O, mixed if needed
        <li>translated data streams
        <li>the ability to create I/O streams from
        arbitrary readers and writers
      </ul>
      <p>It builds on the Primitive I/O layer specified
      in <a href="https://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-79/"></a><a href="srfi-79/"><span class="number">79</span></a>: <span class="name">Primitive I/O</span><span class="authors">, by Michael Sperber</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-11-16</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-181/">SRFI 181: Custom ports (including transcoded ports)</a>.</span><div class="abstract">      <p>This SRFI defines a simple, primitive I/O
      subsystem for Scheme that is intended to function as the lowest layer of
      a more comprehensive suite of I/O layers. It provides unbuffered I/O, and
      is close to what a typical operating system offers. Thus, its interface
      is suitable for implementing high-throughput and zero-copy I/O.
      <p>The Primitive I/O layer also allows clients to
      implement custom data sources and sinks via a simple interface.
      <p>Moreover, this SRFI defines a condition
      hierarchy specifying common I/O-related exceptional situations.
      <p>The Primitive I/O layer only handles
      blocking-I/O. Non-blocking and selective I/O is left for another
      SRFI.
      <p>This I/O layer was designed in conjunction with
      two other layers that can be built on top of it: <a href="https://srfi.schemers.org/srfi-80/">SRFI
      80 (Stream I/O)</a> and <a href="https://srfi.schemers.org/srfi-81/">SRFI 81 (Port I/O)</a>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-78/"></a><a href="srfi-78/"><span class="number">78</span></a>: <span class="name">Lightweight testing</span><span class="authors">, by Sebastian Egner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2006-03-06</span></span><span class="keywords" data-keywords="testing">Keywords: <a href="https://srfi.schemers.org/?keywords=testing">Testing</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>A simple mechanism is defined for testing
      Scheme programs. As a most primitive example, the expression
      <pre>
   (check (+ 1 1) =&gt; 3)
</pre>evaluates the expression <code>(+ 1
1)</code> and compares the result with the expected result 3 provided after the
syntactic keyword <code>=&gt;</code>. Then the outcome of this comparison is
reported in human-readable form by printing a message of the form
      <pre>
   (+ 1 1) =&gt; 2 ; *** failed ***
   ; expected result: 3
</pre>Moreover, the outcome of any executed check
is recorded in a global state counting the number of correct and failed checks
and storing the first failed check. At the end of a file, or at any other
point, the user can print a summary using <code>check-report</code>.
      <p>In addition to the simple test above, it is
      also possible to execute a parametric sequence of checks. Syntactically,
      this takes the form of an eager comprehension in the sense of <a href="https://srfi.schemers.org/srfi-42/">SRFI 42</a> [5]. For example,
      <pre>
   (check-ec (:range e 100)
             (:let x (expt 2.0 e))
             (= (+ x 1) x) =&gt; #f (e x))
</pre>This statement runs the variable <code>
      e</code> through {0..99} and for each binding defines <code>x</code> as
      <code>(expt 2.0 e)</code>. Then it is checked if <code>(+ x 1)</code> is
      equal to <code>x</code>, and it is expected that this is not the case
      (i.e. expected value is <code>#f</code>). The trailing <code>(e x)</code>
      tells the reporting mechanism to print the values of both <code>e</code>
      and <code>x</code> in case of a failed check. The output could look like
      this:
      <pre>
   (let ((e 53) (x 9007199254740992.0)) (= (+ x 1) x)) =&gt; #t ; *** failed ***
    ; expected result: #f
</pre>The specification of bindings to report,
<code>(e x)</code> in the example, is optional but very informative. Other
features of this SRFI are:
      <ul>
        <li>A way to specify a different equality
        predicate (default is <code>equal?</code>).
        <li>Controlling the amount of reporting being
        printed.
        <li>Switching off the execution and reporting of
        checks entriely.
        <li>Retrieving a boolean if all checks have been
        executed and passed.
      </ul></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-77/"></a><a href="srfi-77/"><span class="number">77</span></a>: <span class="name">Preliminary Proposal for R6RS Arithmetic</span><span class="authors">, by William D Clinger and Michael Sperber</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-09-13</span></span><span class="keywords" data-keywords="r6rs-process,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=r6rs-process">R6RS process</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Scheme's arithmetic system was designed to
      allow a wide variety of implementations. After many years of
      implementation experience, however, most implementations now fall into a
      small number of categories, and the benefits of continued experimentation
      no longer justify the confusion and portability problems that have
      resulted from giving implementations so much freedom in this area.
      Moreover, the R5RS generic arithmetic is difficult to implement as
      efficiently as purely fixnum or purely flonum arithmetic. (Fixnum
      arithmetic is typically limited-precision integer arithmetic implemented
      using one or more representations that may be especially efficient on the
      executing machine; flonum arithmetic is typically limited-precision
      floating-point arithmetic using one or more representations that may be
      especially efficient on the executing machine.)
      <p>This SRFI is an effort to extend and clarify
      the R5RS arithmetic to make it more portable, more comprehensive, and
      enable faster programs.
      <p>Furthermore, one of us (Sperber) has argued
      that Scheme's arithmetic requires radical overhaul. The other (Clinger)
      agrees that revisions are needed. Whether these revisions qualify as
      radical is best left to the judgement of individual readers.
      <p>This SRFI proposes to revise section 6.2
      ("Numbers") of R5RS by:
      <ul>
        <li>requiring a Scheme implementation to provide
        the full tower, including exact rationals of arbitrary precision, exact
        rectangular complex numbers with rational real and imaginary parts, and
        inexact real and complex arithmetic
        <li>defining fixnum arithmetic (parameterized by
        precision)
        <li>defining flonum arithmetic
        (inexactly)
        <li>defining new procedures for performing exact
        arithmetic
        <li>defining new procedures for performing
        inexact arithmetic
        <li>describing the external representation and
        semantics of 0.0, -0.0, infinities and NaNs for systems that implement
        inexact real arithmetic using IEEE binary floating point&lt;?
        <li>changing the specification of
        <code>eqv?</code> to behave more sensibly with inexact numbers
        <li>defining Scheme's real numbers to be the
        complex numbers whose imaginary part is an exact zero
        <li>adding an external representation for
        inexact numbers that expresses the precision of a binary floating point
        representation
        <li>defining procedures for some new operations,
        including integer division and remainder on real numbers, and bitwise
        operations,
        <li>restricting the domains of some R5RS
        procedures
        <li>clarifying the semantics of some R5RS
        procedures
        <li>possibly changing the semantics of some R5RS
        procedures
      </ul></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-76/"></a><a href="srfi-76/"><span class="number">76</span></a>: <span class="name">R6RS Records</span><span class="authors">, by Will Clinger, R. Kent Dybvig, Michael Sperber, and Anton van Straaten</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-04-24</span></span><span class="keywords" data-keywords="data-structure,r6rs-process">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r6rs-process">R6RS process</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI describes abstractions for creating
      new data types representing records - data structures with named fields.
      This SRFI comes in four parts:
      <ul>
        <li>a procedural layer for creating and
        manipulating record types and record instances
        <li>an explicit-naming syntactic layer for
        defining the various entities associated with a record type -
        construction procedure, predicate, field accessors, mutators, etc. - at
        once
        <li>an implicit-naming syntactic layer built on
        top of the explicit-naming syntactic layer, which chooses the names for
        the various products based on the names of the record type and
        fields
        <li>a set of reflection procedures
      </ul></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-75/"></a><a href="srfi-75/"><span class="number">75</span></a>: <span class="name">R6RS Unicode data</span><span class="authors">, by Matthew Flatt and Marc Feeley</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2006-05-27</span></span><span class="keywords" data-keywords="internationalization,r6rs-process">Keywords: <a href="https://srfi.schemers.org/?keywords=internationalization">Internationalization</a>, <a href="https://srfi.schemers.org/?keywords=r6rs-process">R6RS process</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Unicode is a widespread universal character
      code that supports most of the world's (natural) languages. The
      extensions to Scheme specified in this SRFI concern the support of
      Unicode in Scheme's character, string, and symbol datatypes. This SRFI
      does not (fully) specify how I/O of Unicode data is performed or how
      Scheme source code is encoded in files; these aspects are left for other
      SRFIs to specify.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-74/"></a><a href="srfi-74/"><span class="number">74</span></a>: <span class="name">Octet-Addressed Binary Blocks</span><span class="authors">, by Michael Sperber</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-12-15</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines a set of procedures for
      creating, accessing, and manipulating octet-addressed blocks of binary
      data, in short, <i>blobs</i>. The SRFI provides access primitives for
      fixed-length integers of arbitrary size, with specified endianness, and a
      choice of unsigned and two's complement representations.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-73/"></a><a href="srfi-73/"><span class="number">73</span></a>: <span class="name">Exact Infinities</span><span class="authors">, by Chongkai Zhu</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2005-11-30</span></span><span class="keywords" data-keywords="numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Many Scheme implementations support exact
      arbitrary-precision integer arithmetic as well as exact rational number
      computation. This SRFI extends the rational numbers of R5RS by adding two
      rational infinities (1/0, -1/0).
      <p>With infinities added to the number system we
      find that division by zero "works". It lets initialization of variables
      precede bounds checks and gives flexibility in placement of those
      checks.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-72/"></a><a href="srfi-72/"><span class="number">72</span></a>: <span class="name">Hygienic macros</span><span class="authors">, by André van Tonder</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-09-21</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes a procedural macro proposal
      for Scheme with the following features:
      <ul>
        <li>
          <h3>Improved hygiene:</h3>
          <p>We argue that conventional hygiene
          algorithms may lead to accidental variable capture errors in
          procedural macros. We propose an improved algorithm that avoids these
          problems.
        <li>
          <h3>Reflective tower:</h3>
          <p>We specify a reflective tower of arbitrary
          height, and propose a refinement of lexical scoping that takes into
          account the phase of use of an identifier in determining its
          meaning.
        <li>
          <h3>Syntax-case:</h3>
          <p>In the current proposal, the
          <code>syntax-case</code> form is expressible as a macro in terms of a
          simpler set of primitives and is specified as library syntax.
        <li>
          <h3>Procedural interface:</h3>
          <p>The primitive interface for manipulating
          compound syntax objects consists of procedures rather than special
          forms. In particular, the traditional abstractions <code>car</code>,
          <code>cdr</code>, <code>cons</code> , <code>...</code> can be used on syntactic
          data.
        <li>
          <h3>Fast hygiene algorithm:</h3>
          <p>The reference implementation documents a
          fast imperative hygiene algorithm that is eager and linear in
          expression size.
        <li>
          <h3>Capturing identifiers:</h3>
          <p>A primitive
          <code>make-capturing-identifier</code> is provided for intentional
          variable capture and for building expansion-time fluid binding
          constructs.
      </ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-71/"></a><a href="srfi-71/"><span class="number">71</span></a>: <span class="name">Extended LET-syntax for multiple values</span><span class="authors">, by Sebastian Egner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-08-12</span></span><span class="keywords" data-keywords="binding,multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-8/">SRFI 8: receive: Binding to multiple values</a>, <a href="/srfi-11/">SRFI 11: Syntax for receiving multiple values</a>, and <a href="/srfi-210/">SRFI 210: Procedures and Syntax for Multiple Values</a>.</span><div class="abstract">      <p>This SRFI is a proposal for extending
      <code>let</code>, <code>let*</code>, and <code>letrec</code> for
      receiving multiple values. The syntactic extension is fully compatible
      with the existing syntax. It is the intention that single-value bindings,
      i.e. <code>(let ((var expr)) ...)</code>, and multiple-value binding can
      be mixed freely and conveniently.
      <p>The most simple form of the new syntax is best
      explained by an example:
      <pre>
(define (quo-rem x y)
  (values (quotient x y) (remainder x y)))

(define (quo x y)
  (let ((q r (quo-rem x y)))
    q))
</pre>
      <p>The procedure <code>quo-rem</code> delivers two
      values to its continuation. These values are received as <code>q</code>
      and <code>r</code> in the <code>let</code>-expression of the procedure
      <code>quo</code>. In other words, the syntax of <code>let</code> is
      extended such that several variables can be specified---and these
      variables receive the values delivered by the expression <code>(quo-rem x
      y)</code>.
      <p>The syntax of <code>let</code> is further
      extended to cases in which a rest argument receives the list of all
      residual values. Again by example,
      <pre>
(let (((values y1 y2 . y3+) (foo x)))
   body)
</pre>In this example, <code>values</code> is a
syntactic keyword indicating the presence of multiple values to be received,
and <code>y1</code>, <code>y2</code>, and <code>y3+</code>, resp., are
variables bound to the first value, the second value, and the list of the
remaining values, resp., as produced by <code>(foo x)</code>. The syntactic
keyword <code>values</code> allows receiving all values as in <code>(let
(((values . xs) (foo x))) body)</code>. It also allows receiving no values at
all as in <code>(let (((values) (for-each foo list))) body)</code>.<br>
      <br>
      <p>A common application of binding multiple values
      is decomposing data structures into their components. This mechanism is
      illustrated in its most primitive form as follows: The procedure
      <code>uncons</code> (defined below) decomposes a pair <code>x</code> into
      its car and its cdr and delivers them as two values to its continuation.
      Then an extended <code>let</code> can receive these values:
      <pre>
(let ((car-x cdr-x (uncons x)))
  (foo car-x cdr-x))
</pre>
      <p>Of course, for pairs this method is probably
      neither faster nor clearer than using the procedures <code>car</code> and
      <code>cdr</code>. However, for data structures doing substantial work
      upon decomposition this is different: Extracting the element of highest
      priority from a priority queue, while at the same time constructing the
      residual queue, can both be more efficient and more convenient than doing
      both operations independently. In fact, the <code>quo-rem</code> example
      illustrates this point already as both quotient and remainder are
      probably computed by a common exact division algorithm. (And often
      caching is used to avoid executing this algorithm twice as often as
      needed.)
      <p>As the last feature of this SRFI, a mechanism
      is specified to store multiple values in heap-allocated data structures.
      For this purpose, <code>values-&gt;list</code> and
      <code>values-&gt;vector</code> construct a list (a vector, resp.) storing
      all values delivered by evaluating their argument expression. Note that
      these operations cannot be procedures.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-70/"></a><a href="srfi-70/"><span class="number">70</span></a>: <span class="name">Numbers</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-09-11</span></span><span class="keywords" data-keywords="data-structure,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI proposes text to replace section 6.2
      "Numbers" of R5RS in order to extend its capabilities, correct errors in
      its specification, make it more explicit about limitations of precision
      and magnitude, and improve portability between implementations. More
      specifically, this new text:
      <ul>
        <li>incorporates an inexact real positive
        infinity and an inexact real negative infinity,
        <li>extends number syntax to incorporate inexact
        real infinities,
        <li>adapts Common-Lisp semantics for
        <samp>`expt'</samp> and extends them to include inexact real
        infinities,
        <li>corrects the description of
        <samp>`sqrt'</samp>,
        <li>sharpens the distinction between exact and
        inexact numbers,
        <li>removes a contradiction related to
        exactness,
        <li>extends <samp>`gcd'</samp> and
        <samp>`lcm'</samp> to exact rational numbers,
        <li>extends <samp>`quotient'</samp>,
        <samp>`modulo'</samp>, and <samp>`remainder'</samp> to finite real
        numbers,
        <li>clarifies the behavior of
        <samp>`inexact-&gt;exact'</samp> applied to an exact argument,
        <li>clarifies the behavior of
        <samp>`exact-&gt;inexact'</samp> applied to an inexact argument,
        <li>adds convenience procedures
        <samp>`exact-round'</samp>, <samp>`exact-ceiling'</samp>,
        <samp>`exact-floor'</samp>, and <samp>`exact-truncate'</samp>,
        <li>and adds examples.
      </ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-69/"></a><a href="srfi-69/"><span class="number">69</span></a>: <span class="name">Basic hash tables</span><span class="authors">, by Panu Kalliokoski</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-09-14</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-125/">SRFI 125: Intermediate hash tables</a> and <a href="/srfi-126/">SRFI 126: R6RS-based hashtables</a>.</span><div class="abstract">      <p>This SRFI defines basic hash tables. Hash
      tables are widely recognised as a fundamental data structure for a wide
      variety of applications. A hash table is a data structure that:
      <ol>
        <li>provides a mapping from some set of keys to
        some set of values associated to those keys
        <li>has no intrinsic order for the (key, value)
        associations it contains
        <li>supports in-place modification as the
        primary means of setting the contents of a hash table
        <li>provides key lookup and destructive update
        in amortised constant time, provided that a good hash function is
        used.
      </ol>
      <p>This SRFI aims to accomplish these
      goals:
      <ol>
        <li>to provide a consistent, generic and widely
        applicable API for hash tables
        <li>to improve code portability by providing a
        standard hash table facility with guaranteed behaviour
        <li>to help the programmer by defining utility
        routines that account for the most common situations of using hash
        tables.
      </ol></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-68/"></a><a href="srfi-68/"><span class="number">68</span></a>: <span class="name">Comprehensive I/O</span><span class="authors">, by Michael Sperber</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2005-11-29</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines a comprehensive I/O subsystem
      for Scheme with three layers, where each layer is built on top of the one
      below it:
      <ul>
        <li>The lowest, primitive layer provides
        unbuffered I/O, and is close to what a typical operating system
        offers.
        <li>The middle layer builds on lazy, mostly
        functional buffered streams.
        <li>The upper layer is similar in nature to the
        ports subsystem in R5RS, and provides conventional, imperative buffered
        input and output.
      </ul>
      <p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      <p>In particular, the subsystem provides
      <ul>
        <li>buffered reading and writing
        <li>arbitrary lookahead at the streams
        level
        <li>dynamic redirection of input or output at
        the ports level
        <li>binary and text I/O, mixed if needed
        <li>translated data streams
        <li>unbuffered I/O at the primitive layer
        <li>the ability to create arbitrary I/O streams,
        such as to and from blobs and strings
      </ul>
      <p>The subsystem does <em>not</em> provide
      <ul>
        <li>formatted I/O
        <li>non-blocking or selective I/O
        <li>portable filenames, or any functionality for
        manipulating filenames
        <li>filesystem operations
        <li>socket I/O
        <li>extremely high-throughput or zero-copy
        I/O
      </ul>
      <p>However, all of these could be added on top of
      one or several of the layers specified in this SRFI.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-67/"></a><a href="srfi-67/"><span class="number">67</span></a>: <span class="name">Compare Procedures</span><span class="authors">, by Sebastian Egner and Jens Axel Søgaard</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-09-11</span></span><span class="keywords" data-keywords="comparison">Keywords: <a href="https://srfi.schemers.org/?keywords=comparison">Comparison</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI can be seen as an extension of the
      standard procedures <code>=</code>, <code>&lt;</code>, <code>char&lt;?</code> etc. of
      R<sup>5</sup>RS -- or even as a replacement. The primary design aspect in
      this SRFI is the separation of <em>representing</em> a total order and
      <em>using it.</em> For representing the order, we have chosen for truly
      3-way comparisons. For using it we provide an extensive set of
      operations, each of which accepts a procedure used for comparison. Since
      these compare procedures are often optional, comparing built-in types is
      as convenient as R<sup>5</sup>RS , sometimes more convenient: For
      example, testing if the integer index <em>i</em> lies in the integer
      range {0, <code>...</code>, <em>n</em> <code>-</code> 1} can be written as
      <code>(&lt;=/&lt;? 0 i n)</code>, implicitly invoking
      <code>default-compare</code>.
      <p>As soon as new total orders are required, the
      infrastructure provided by this SRFI is far more convenient and often
      even more efficient than building each total order from scratch.
      <p>Moreover, in case Scheme users and implementors
      find this mechanism useful and adopt it, the benefit of having a uniform
      interface to total orders to be used in data structures will manifest
      itself. Most concretely, a new sorting procedure in the spirit of this
      SRFI would have the interface <code>(my-sort [ <i>compare</i> ]
      <i>xs</i>)</code>, using <code>default-compare</code> if the optional
      <i>compare</i> was not provided. Then <code>my-sort</code> could be defined
      using the entire infrastructure of this SRFI: Efficient 2- and 3-way
      branching, testing for chains and pairwise inequality, min/max, and
      general order statistics.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-66/"></a><a href="srfi-66/"><span class="number">66</span></a>: <span class="name">Octet Vectors</span><span class="authors">, by Michael Sperber</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-12-15</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines a set of procedures for
      creating, accessing, and manipulating uniform vectors of octets.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-65/"></a><a href="srfi-65/"><span class="number">65</span></a>: <span class="name">define-immutable: A Syntax to Define Identifiers With Immutable Values</span><span class="authors">, by Andrew Wilcox</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2005-05-17</span></span><span class="keywords" data-keywords="binding,lazy-evaluation">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=lazy-evaluation">Lazy Evaluation</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>The <code>define-immutable</code> form defines an
      identifier whose value never changes.
      <p>The expression part of the definition is
      evaluated lazily: it is not evaluated unless and until the identifier is
      evaluated. This permits an immutable definition to use other definitions
      in more ways than is possible when using <code>define</code> in internal
      definitions.
      <p>A series of immutable definitions have simple
      semantics, making them easy to program and understand.
      <pre>
    (let ()
      (define-immutable x (+ z 5))
      (define-immutable y (/ 100 4))
      (define-immutable z (add-10 y))
      (define-immutable add-10 (add-n 10))
      (define-immutable (add-n n)
        (lambda (x)
          (+ n x)))
      x)
  =&gt;
    40
</pre></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-64/"></a><a href="srfi-64/"><span class="number">64</span></a>: <span class="name">A Scheme API for test suites</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2006-06-18</span></span><span class="keywords" data-keywords="testing">Keywords: <a href="https://srfi.schemers.org/?keywords=testing">Testing</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This defines an API for writing <dfn>test
      suites</dfn>, to make it easy to portably test Scheme APIs, libraries,
      applications, and implementations. A test suite is a collection of
      <dfn>test cases</dfn> that execute in the context of a
      <dfn>test-runner</dfn>. This specifications also supports writing new
      test-runners, to allow customization of reporting and processing the
      result of running test suites.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-63/"></a><a href="srfi-63/"><span class="number">63</span></a>: <span class="name">Homogeneous and Heterogeneous Arrays</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-04-27</span></span><span class="keywords" data-keywords="data-structure,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>The SRFI, which is to supersede <a href="https://srfi.schemers.org/srfi-47/">SRFI-47</a>, "Array",
      <ul>
        <li>synthesizes array concepts from Common-Lisp
        and Alan Bawden's "array.scm";
        <li>incorporates all the uniform vector types
        from <a href="https://srfi.schemers.org/srfi-4/">SFRI-4</a> "Homogeneous numeric vector
        datatypes";
        <li>adds a boolean uniform array type;
        <li>adds 16.bit and 128.bit floating-point
        uniform-array types;
        <li>adds decimal floating-point uniform-array
        types; and
        <li>adds array types of (dual) floating-point
        complex numbers.
      </ul>Multi-dimensional arrays subsume homogeneous
      vectors as the one-dimensional case, obviating the need for SRFI-4.<br>
      <br>
      <p>SRFI-58 gives a read/write invariant syntax for
      the homogeneous and heterogeneous arrays described here.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-62/"></a><a href="srfi-62/"><span class="number">62</span></a>: <span class="name">S-expression comments</span><span class="authors">, by Taylor Campbell</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-07-21</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI proposes a simple extension to
      Scheme's lexical syntax that allows individual S-expressions to be made
      into comments, ignored by the reader. This contrasts with the standard
      Lisp semicolon comments, which make the reader ignore the remainder of
      the line, and the slightly less common block comments, as <a href="">SRFI
      30</a> defines: both of these mechanisms comment out slices of text, not
      S-expressions.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-61/"></a><a href="srfi-61/"><span class="number">61</span></a>: <span class="name">A more general cond clause</span><span class="authors">, by Taylor Campbell</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-07-21</span></span><span class="keywords" data-keywords="binding,control-flow">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=control-flow">Control Flow</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI proposes an extension to the
      <code>cond</code> syntax to allow a more general clause, one that allows
      binding the results of tests as in the <code>=&gt;</code> clauses and
      user-defined meaning of the success &amp; failure of tests.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-60/"></a><a href="srfi-60/"><span class="number">60</span></a>: <span class="name">Integers as Bits</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-03-08</span></span><span class="keywords" data-keywords="data-structure,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Treating integers as two's-complement strings
      of bits is an arcane but important domain of computer science. It is used
      for:
      <ul>
        <li>hashing;
        <li>Galois-field[2] calculations of
        error-detecting and error-correcting codes;
        <li>cryptography and ciphers;
        <li>pseudo-random number generation;
        <li>register-transfer-level modeling of digital
        logic designs;
        <li>Fast-Fourier transforms;
        <li>packing and unpacking numbers in persistant
        data structures;
        <li>space-filling curves with applications to
        dimension reduction and sparse multi-dimensional database indexes;
        and
        <li>generating approximate seed values for
        root-finders and transcendental function algorithms.
      </ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-59/"></a><a href="srfi-59/"><span class="number">59</span></a>: <span class="name">Vicinity</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-03-08</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>A vicinity is a descriptor for a place in the
      file system. Vicinities hide from the programmer the concepts of host,
      volume, directory, and version. Vicinities express only the concept of a
      file environment where a file name can be resolved to a file in a system
      independent manner.
      <p>All of these procedures are file-system
      dependent. Use of these vicinity procedures can make programs file-system
      <em>in</em>dependent.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-58/"></a><a href="srfi-58/"><span class="number">58</span></a>: <span class="name">Array Notation</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-03-08</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p><a href="https://srfi.schemers.org/srfi-47/">SRFI-47</a> and its
      successor <a href="https://srfi.schemers.org/srfi-63/">SRFI-63</a> provide both homogeneous numeric
      and heterogeneous multidimensional arrays which subsume Scheme vectors.
      The notation presented here builds upon Common-Lisp array syntax to
      represent heterogeneous arrays; and introduces a new Scheme-based
      notation for denoting homogeneous numeric arrays.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-57/"></a><a href="srfi-57/"><span class="number">57</span></a>: <span class="name">Records</span><span class="authors">, by André van Tonder</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-03-07</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>We describe a syntax for defining record types.
      A predicate, constructor, and field accessors and modifiers may be
      specified for each record type. We also introduce a syntax for declaring
      record type schemes, representing families of record types that share a
      set of field labels. A polymorphic predicate and polymorphic field
      accessors and modifiers may be specified for each record type scheme. A
      syntax is provided for constructing records by field label, for in-place
      and for functional record update, and for composing records.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-56/"></a><a href="srfi-56/"><span class="number">56</span></a>: <span class="name">Binary I/O</span><span class="authors">, by Alex Shinn</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2005-10-31</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI extends Scheme with procedures to
      read and write binary data to and from ports, including utility
      procedures for writing various integer and floating point values in both
      big and little endian formats. Predicates are provided to test if binary
      I/O is allowed on a port, along with new procedures for creating such
      ports.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-55/"></a><a href="srfi-55/"><span class="number">55</span></a>: <span class="name">require-extension</span><span class="authors">, by Felix L. Winkelmann and D.C. Frost</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2004-11-05</span></span><span class="keywords" data-keywords="features">Keywords: <a href="https://srfi.schemers.org/?keywords=features">Features</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI specifies an extremely simple
      facility for making an extension or library available to a Scheme
      toplevel environment.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-54/"></a><a href="srfi-54/"><span class="number">54</span></a>: <span class="name">Formatting</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2004-06-24</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI introduces the CAT procedure that
      converts any object to a string. It takes one object as the first
      argument and accepts a variable number of optional arguments, unlike the
      procedure called FORMAT.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-53/"></a><a href="srfi-53/"><span class="number">53</span></a>: <span class="name">Syntactic computations with computation-rules</span><span class="authors">, by André van Tonder</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2004-09-06</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI provides a portable framework for
      writing complex high-level macros that perform nontrivial computations
      during expansion.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-52/"></a><a href="srfi-52/"><span class="number">52</span></a>: <span class="name">Permitting and Supporting Extended Character Sets</span><span class="authors">, by Thomas Lord</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2004-06-17</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI describes how to modify the
      <i>Revised Report</i> (<a href="http://www.schemers.org/Documents/Standards/R5RS/">R5RS</a>) in order to
      enable conforming implementations to use an extended character set such
      as (but not limited to) <a href="http://www.unicode.org">Unicode</a>.
      <p>Changes to some requirements of the report are
      recommended. Currently, the <i>Revised Report</i> contains requirements
      which are difficult or impossible to satisfy with some extended character
      sets.
      <p>New required procedures are proposed,
      specified, and included in the reference implementation. These procedures
      enable portable Scheme programs to manipulate Scheme source texts and
      source data accurately, even in implementations using extended character
      sets.
      <p>This SRFI concludes with some suggestions for
      implementors interested in providing good Unicode support, using these
      suggestions to illustrate how the proposed changes to the <i>Revised
      Report</i> can "play out" in Unicode-based Scheme.
      <p>This SRFI does <b>not</b> attempt to provide a
      comprehensive library for global text processing. For example, one issue
      in global text processing is the need for linguistically-sensitive,
      locale-sensitive procedures for sorting strings. Such procedures are
      beyond the scope of this SRFI. On the other hand, by making Scheme
      compatible with extended character sets, this SRFI is a step in the
      direction of permitting global text processing standard libraries to be
      developed in a form portable across all conforming
      implementations.
      <p>This SRFI does <b>not</b> propose that
      implementations be required to support Unicode or any other extended
      character set. It does not specify a representation for Unicode
      characters or strings. It <b>does</b> revise the specifications of the
      report so that <code>char?</code> values <i>may be</i> Unicode (or other)
      characters.
      <p>The reference implementation included should
      prove to be easily ported to and effective for all ASCII-only
      implementations and for many implementations using an 8-bit character set
      which is an extension of ASCII (it will require very minor modifications
      for each particular implementation). Other implementations may need to
      use a different implementation.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-51/"></a><a href="srfi-51/"><span class="number">51</span></a>: <span class="name">Handling rest list</span><span class="authors">, by Joo ChurlSoo</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2004-06-07</span></span><span class="keywords" data-keywords="multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI introduces the
      <code>rest-values</code> procedure which has three modes of
      operation:
      <ol>
        <li>it processes a rest list after checking its
        elements with default values or predicate procedures,
        <li>it processes a rest list with default values
        without checking its elements,
        <li>it processes a default list whose elements
        are lists or pairs, after checking their elements that are default
        values or predicate procedures with the elements of a rest list,
      </ol>
      <p>and eight macros which additionally check the
      rest arguments that are returned by <code>rest-values</code>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-50/"></a><a href="srfi-50/"><span class="number">50</span></a>: <span class="name">Mixing Scheme and C</span><span class="authors">, by Richard Kelsey and Michael Sperber</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2005-12-20</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI describes an interface for calling C
      functions from Scheme, calling Scheme functions from C, and allocating
      storage in the Scheme heap. Scheme manages stub functions in C that
      negotiate between the calling conventions of Scheme and C and the memory
      allocation policies of both worlds.
      <p>The following facilities are available for
      interfacing between Scheme and C:
      <ul>
        <li>Scheme code can call C functions.
        <li>The external interface provides full
        introspection for all Scheme objects. External code may inspect,
        modify, and allocate Scheme objects arbitrarily.
        <li>External code may signal errors to the
        Scheme system.
        <li>External code may call back into Scheme.
        Scheme correctly unrolls the process stack on non-local exits.
        <li>External modules may register bindings of
        names to values with a central registry accessible from Scheme.
        Conversely, Scheme code can register shared bindings for access by C
        code.
      </ul>
      <p>The interface is closely based on that of
      <a href="http://www.s48.org/">Scheme 48</a> and <a href="http://www.scsh.net/">scsh</a>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-49/"></a><a href="srfi-49/"><span class="number">49</span></a>: <span class="name">Indentation-sensitive syntax</span><span class="authors">, by Egil Möller</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-07-22</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI descibes a new syntax for Scheme,
      called I-expressions, whith equal descriptive power as S-expressions. The
      syntax uses indentation to group expressions, and has no special cases
      for semantic constructs of the language. It can be used both for program
      and data input.
      <p>It also allows mixing S-expressions and
      I-expressions freely, giving the programmer the ability to layout the
      code as to maximize readability.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-48/"></a><a href="srfi-48/"><span class="number">48</span></a>: <span class="name">Intermediate Format Strings</span><span class="authors">, by Ken Dickey</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2004-03-02</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-28/">SRFI 28: Basic Format Strings</a> and <a href="/srfi-159/">SRFI 159: Combinator Formatting</a>.</span><div class="abstract">      <p>This document specifies Format Strings, a
      method of interpreting a Scheme string which contains a number of format
      directives that are replaced with other string data according to the
      semantics of each directive. This SRFI extends <a href="https://srfi.schemers.org/srfi-28">SRFI-28</a> in being more generally useful but is less general
      than advanced format strings in that it does not allow, aside from ~F,
      for controlled positioning of text within fields.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-47/"></a><a href="srfi-47/"><span class="number">47</span></a>: <span class="name">Array</span><span class="authors">, by Aubrey Jaffer</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2004-06-14</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>"slib/array.scm" synthesizes array ideas from
	Common-Lisp and Alan Bawden with homogeneous vector ideas from <a href="https://srfi.schemers.org/srfi-4/">SRFI-4</a>
	and <a href="http://swissnet.ai.mit.edu/~jaffer/SCM">SCM</a>. The result portably
      integrates homogeneous and heterogeneous arrays into Scheme.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-46/"></a><a href="srfi-46/"><span class="number">46</span></a>: <span class="name">Basic Syntax-rules Extensions</span><span class="authors">, by Taylor Campbell</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2005-02-28</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI proposes two extensions to the
      R5RS<sup>1</sup> <code>syntax-rules</code> pattern language: the first
      allows <code>syntax-rules</code> macros to generate macros, where the
      macro-generated macros use ellipsis that is not used by the
      macro-generating macros; the second allows for 'tail patterns.'</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-45/"></a><a href="srfi-45/"><span class="number">45</span></a>: <span class="name">Primitives for Expressing Iterative Lazy Algorithms</span><span class="authors">, by André van Tonder</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2004-04-05</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-155/">SRFI 155: Promises</a>.</span><div class="abstract">      <p>Lazy evaluation is traditionally simulated in
      Scheme using <code>delay</code> and <code>force</code>. However, these
      primitives are not powerful enough to express a large class of lazy
      algorithms that are iterative. Indeed, it is folklore in the Scheme
      community that typical iterative lazy algorithms written using
      <code>delay</code> and <code>force</code> will often require unbounded
      memory.
      <p>Although varous modifications of
      <code>delay</code> and <code>force</code> had been proposed to resolve
      this problem (see e.g., the SRFI-40 discussion list) they all fail some
      of the benchmarks provided below. To our knowledge, the current SRFI
      provides the first exhaustive solution to this problem.
      <p>As motivation, we first explain how the usual
      laziness encoding using only <code>delay</code> and <code>force</code>
      will break the iterative behavior of typical algorithms that would have
      been properly tail-recursive in a true lazy language, causing the
      computation to require unbounded memory.
      <p>The problem is then resolved by introducing a
      set of three operations:
      <pre>
    {<code>lazy</code>, <code>delay</code>, <code>force</code>}
</pre>which allow the programmer to succinctly
express lazy algorithms while retaining bounded space behavior in cases that
are properly tail-recursive. A general recipe for using these primitives is
provided. An additional procedure <code>{eager}</code> is provided for the
construction of eager promises in cases where efficiency is a concern.<br>

      <br>
      <p>Although this SRFI redefines <code>delay</code>
      and <code>force</code>, the extension is conservative in the sense that
      the semantics of the subset {<code>delay</code>, <code>force</code>} in
      isolation (i.e., as long as the program does not use <code>lazy</code>)
      agrees with that in R5RS. In other words, no program that uses the R5RS
      definitions of delay and force will break if those definition are
      replaced by the SRFI-45 definitions of delay and force.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-44/"></a><a href="srfi-44/"><span class="number">44</span></a>: <span class="name">Collections</span><span class="authors">, by Scott G. Miller</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2004-03-07</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>A Collections API which defines a common naming
      scheme and set of operations for creating, accessing, and manipulating
      common datastructures in Scheme. The API defines accessors, a common
      protocol for value access via generic and specific enumeration, and
      functions for inter-datastructure cooperation. Finally, a concrete
      specification of a compliant set of operators for the standard Scheme
      heterogenous datastructures (lists and vectors) and for the homogeneous
      Scheme string is provided.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-43/"></a><a href="srfi-43/"><span class="number">43</span></a>: <span class="name">Vector library</span><span class="authors">, by Taylor Campbell</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2004-10-26</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-133/">SRFI 133: Vector Library (R7RS-compatible)</a>.</span><div class="abstract">      <p>This SRFI proposes a comprehensive and complete
      library of vector operations accompanied by a freely available and
      complete reference implementation. The reference implementation is
      unencumbered by copyright, and useable with no modifications on any
      Scheme system that is R5RS-compliant. It also provides several hooks for
      implementation-specific optimization as well.
      <p>Because this SRFI is more of a library or
      module specification than a request for additions to readers or any other
      internal implementation detail, in an implementation that supports a
      module or structure or package or library or unit (et cetera) systems,
      these procedures should be contained in a module / structure / package /
      library / unit called <code>vector-lib</code>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-42/"></a><a href="srfi-42/"><span class="number">42</span></a>: <span class="name">Eager Comprehensions</span><span class="authors">, by Sebastian Egner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2003-07-07</span></span><span class="keywords" data-keywords="control-flow">Keywords: <a href="https://srfi.schemers.org/?keywords=control-flow">Control Flow</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-196/">SRFI 196: Range Objects</a>.</span><div class="abstract">      <p>This SRFI defines a modular and portable
      mechanism for eager comprehensions extending the algorithmic language
      Scheme [R5RS]. An eager comprehension is a convenient notation for one or
      more nested or parallel loops generating a sequence of values, and
      accumulating this sequence into a result.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-41/"></a><a href="srfi-41/"><span class="number">41</span></a>: <span class="name">Streams</span><span class="authors">, by Philip L. Bewig</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2008-01-24</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-40/">SRFI 40: A Library of Streams</a>.</span><div class="abstract">      <p><span class="c1">Streams, sometimes called
      lazy lists, are a sequential data structure containing elements computed
      only on demand. A stream is either null or is a pair with a stream in its
      cdr. Since elements of a stream are computed only when accessed, streams
      can be infinite. Once computed, the value of a stream element is cached
      in case it is needed again.</span>
      <p><span class="c1">Streams without memoization
      were first described by Peter Landin in 1965. Memoization became accepted
      as an essential feature of streams about a decade later. Today, streams
      are the signature data type of functional programming languages such as
      Haskell.</span>
      <p><span class="c1">This Scheme Request for
      Implementation describes two libraries for operating on streams: a
      canonical set of stream primitives and a set of procedures and syntax
      derived from those primitives that permits convenient expression of
      stream operations. They rely on facilities provided by R6RS, including
      libraries, records, and error reporting. To load both stream libraries,
      say:</span>
      <p><span class="c2">(import (streams))</span></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-40/"></a><a href="srfi-40/"><span class="number">40</span></a>: <span class="name">A Library of Streams</span><span class="authors">, by Philip L. Bewig</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2017-08-10</span></span><span class="keywords" data-keywords="data-structure,superseded">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=superseded">Superseded</a></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-41/">SRFI 41: Streams</a>.</span><div class="abstract">      <p>Along with higher-order functions, one of the
      hallmarks of functional programming is lazy evaluation. A primary
      manifestation of lazy evaluation is lazy lists, generally called streams
      by Scheme programmers, where evaluation of a list element is delayed
      until its value is needed.
      <p>The literature on lazy evaluation distinguishes
      two styles of laziness, called even and odd. Odd style streams are
      ubiquitous among Scheme programs and can be easily encoded with the
      Scheme primitives delay and force defined in R5RS. However, the even
      style delays evaluation in a manner closer to that of traditional lazy
      languages such as Haskell and avoids an "off by one" error that is
      symptomatic of the odd style.
      <p>This SRFI defines the stream data type in the
      even style, some essential procedures and syntax that operate on streams,
      and motivates our choice of the even style. A companion SRFI 41 Stream
      Library provides additional procedures and syntax which make for more
      convenient processing of streams and shows several examples of their
      use.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-39/"></a><a href="srfi-39/"><span class="number">39</span></a>: <span class="name">Parameter objects</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2003-06-30</span></span><span class="keywords" data-keywords="binding,parameters">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=parameters">Parameters</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines <i>parameter</i> objects, the
      procedure <code>make-parameter</code> to create parameter objects and the
      <code>parameterize</code> special form to dynamically bind parameter
      objects. In the dynamic environment, each parameter object is bound to a
      cell containing the value of the parameter. When a procedure is called
      the called procedure inherits the dynamic environment from the caller.
      The <code>parameterize</code> special form allows the binding of a
      parameter object to be changed for the dynamic extent of its body.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-38/"></a><a href="srfi-38/"><span class="number">38</span></a>: <span class="name">External Representation for Data With Shared Structure</span><span class="authors">, by Ray Dillinger</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2003-04-02</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI proposes
      <code>(write-with-shared-structure)</code> and
      <code>(read-with-shared-structure)</code>, procedures for writing and reading
      external representations of data containing shared structure. These
      procedures implement a proposed standard external notation for data
      containing shared structure.
      <p>This SRFI permits but does not require
      replacing the standard <code>(write)</code> and <code>(read)</code> functions.
      These functions may be implemented without the overhead in time and space
      required to detect and specify shared structure.
      <p>An implementation conforms to this SRFI if it
      provides procedures named <code>(write-with-shared-structure)</code> and
      <code>(read-with-shared-structure)</code>, which produce and read the same
      notation as produced by the reference implementation. It may also provide
      <code>(read/ss)</code> and <code>(write/ss)</code>, equivalent functions with
      shorter names.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-37/"></a><a href="srfi-37/"><span class="number">37</span></a>: <span class="name">args-fold: a program argument processor</span><span class="authors">, by Anthony Carrico</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2003-01-13</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Many operating systems make the set of argument
      strings used to invoke a program available (often following the program
      name string in an array called argv). Most programs need to parse and
      process these argument strings in one way or another. This SRFI describes
      a set of procedures that support processing program arguments according
      to POSIX and GNU C Library Reference Manual guidelines.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-36/"></a><a href="srfi-36/"><span class="number">36</span></a>: <span class="name">I/O Conditions</span><span class="authors">, by Michael Sperber</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-12-01</span></span><span class="keywords" data-keywords="exceptions,i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=exceptions">Exceptions</a>, <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI specifies a set of condition types
      for I/O errors. The condition types are defined in terms of <a href="https://srfi.schemers.org/srfi-35/">SRFI 35</a>. Moreover, this SRFI requires a Scheme system
      implementing it to raise exceptions in the sense of <a href="http://srfi.schemers.org/srfi-34/">SRFI 34</a> for errors occurring
      during the execution of the R5RS <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.6">
      I/O operations</a>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-35/"></a><a href="srfi-35/"><span class="number">35</span></a>: <span class="name">Conditions</span><span class="authors">, by Richard Kelsey and Michael Sperber</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-12-01</span></span><span class="keywords" data-keywords="exceptions">Keywords: <a href="https://srfi.schemers.org/?keywords=exceptions">Exceptions</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>The SRFI defines constructs for creating and
      inspecting <i>condition</i> types and values. A condition value
      encapsulates information about an exceptional situation, or exception.
      This SRFI also defines a few basic condition types.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-34/"></a><a href="srfi-34/"><span class="number">34</span></a>: <span class="name">Exception Handling for Programs</span><span class="authors">, by Richard Kelsey and Michael Sperber</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-12-01</span></span><span class="keywords" data-keywords="exceptions">Keywords: <a href="https://srfi.schemers.org/?keywords=exceptions">Exceptions</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines exception-handling and
      exception-raising constructs for Scheme, including
      <ul>
        <li>a <code>with-exception-handler</code>
        procedure and a <code>guard</code> form for installing
        exception-handling procedures,
        <li>a <code>raise</code> procedure for invoking
        the current exception handler.
      </ul>
      <p>This SRFI is based on (withdrawn) <a href="https://srfi.schemers.org/srfi-12/">SRFI 12: Exception Handling</a> by William Clinger, R. Kent
      Dybvig, Matthew Flatt, and Marc Feeley.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-33/"></a><a href="srfi-33/"><span class="number">33</span></a>: <span class="name">Integer Bitwise-operation Library</span><span class="authors">, by Olin Shivers</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2003-07-17</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>R5RS Scheme has no utilities for performing
      bitwise logical operations on integers or bitstrings, which is a problem
      for authors of portable code. This SRFI proposes a coherent and
      comprehensive set of these functions; it is accompanied by a reference
      implementation of the spec in terms of a set of seven core operators. The
      reference implementation is
      <ul>
        <li>portable
        <li>efficient
        <li>completely open, public-domain source
      </ul>
      <p>The precise semantics of these operators is
      almost never an issue. A consistent, portable set of <b>names</b> and
      <b>parameter conventions</b>, however, is. Hence this SRFI.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-32/"></a><a href="srfi-32/"><span class="number">32</span></a>: <span class="name">Sort Libraries</span><span class="authors">, by Olin Shivers</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2003-07-17</span></span><span class="keywords" data-keywords="algorithm">Keywords: <a href="https://srfi.schemers.org/?keywords=algorithm">Algorithm</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Current Scheme sorting packages are, every one
      of them, surprisingly bad. I've designed the API for a full-featured sort
      toolkit, which I propose as an SRFI. The spec comes with 1200 lines of
      high-quality reference code: tightly written, highly commented, portable
      code, available for free. Implementors want this code. It's better than
      what you have.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-31/"></a><a href="srfi-31/"><span class="number">31</span></a>: <span class="name">A special form `rec' for recursive evaluation</span><span class="authors">, by Mirko Luedde</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-12-02</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>We propose the implementation of a special form
      called <code>rec</code>. This form is a generalization and combination of
      the forms <code>rec</code> and <code>named-lambda</code> of
      [Clinger1985]. It allows the simple and non-imperative construction of
      self-referential expressions. As an important special case, it extends
      the A. Church form <code>lambda</code> such that it allows the direct
      definition of recursive procedures without using further special forms
      like <code>let</code> or <code>letrec</code>, without using advanced
      constructions like the H. B. Curry combinator and, unlike
      <code>define</code>, without introducing variable bindings into the
      external environment.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-30/"></a><a href="srfi-30/"><span class="number">30</span></a>: <span class="name">Nested Multi-line Comments</span><span class="authors">, by Martin Gasbichler</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-08-07</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI extends R5RS by possibly nested,
      multi-line comments. Multi-line comments start with <code>#|</code> and
      end with <code>|#</code>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-29/"></a><a href="srfi-29/"><span class="number">29</span></a>: <span class="name">Localization</span><span class="authors">, by Scott G. Miller</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-08-01</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This document specifies an interface to
      retrieving and displaying locale sensitive messages. A Scheme program can
      register one or more translations of templated messages, and then write
      Scheme code that can transparently retrieve the appropriate message for
      the locale under which the Scheme system is running.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-28/"></a><a href="srfi-28/"><span class="number">28</span></a>: <span class="name">Basic Format Strings</span><span class="authors">, by Scott G. Miller</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-06-25</span></span><span class="keywords" data-keywords="i/o">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-48/">SRFI 48: Intermediate Format Strings</a> and <a href="/srfi-159/">SRFI 159: Combinator Formatting</a>.</span><div class="abstract">      <p>This document specifies Format Strings, a
      method of interpreting a Scheme string which contains a number of escape
      sequences that are replaced with other string data according to the
      semantics of each sequence.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-27/"></a><a href="srfi-27/"><span class="number">27</span></a>: <span class="name">Sources of Random Bits</span><span class="authors">, by Sebastian Egner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-06-03</span></span><span class="keywords" data-keywords="randomness">Keywords: <a href="https://srfi.schemers.org/?keywords=randomness">Randomness</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This document specifies an interface to sources
      of random bits, or "random sources" for brevity. In particular, there are
      three different ways to use the interface, with varying demands on the
      quality of the source and the amount of control over the production
      process:
      <ul>
        <li>The "no fuss" interface specifies that
        <code>(random-integer</code> <i>n</i><code>)</code> produces the next
        random integer in {0, ..., <i>n</i>-1} and <code>(random-real)</code>
        produces the next random real number between zero and one. The details
        of how these random values are produced may not be very relevant, as
        long as they appear to be sufficiently random.
        <li>For simulation purposes, on the contrary, it
        is usually necessary to know that the numbers are produced
        deterministically by a pseudo random number generator of high quality
        and to have explicit access to its state. In addition, one might want
        to use several independent sources of random numbers at the same time
        and it can be useful to have some simple form of randomization.
        <li>For security applications a serious form of
        true randomization is essential, in the sense that it is difficult for
        an adversary to exploit or introduce imperfections into the
        distribution of random bits. Moreover, the linear complexity of the
        stream of random bits is more important than its statistical
        properties. In these applications, an entropy source (producing truely
        random bits at a low rate) is used to randomize a pseudo random number
        generator to increase the rate of available bits.
      </ul>
      <p>Once random sources provide the infrastructure
      to obtain random bits, these can be used to construct other random
      deviates. Most important are floating point numbers of various
      distributions and random discrete structures, such as permutations or
      graphs. As there is an essentially unlimited number of such objects (with
      limited use elsewhere), we do not include them in this SRFI. In other
      words, this SRFI is <em>not</em> about making all sorts of random
      objects---it is about obtaining random bits in a portable, flexible,
      reliable, and efficient way.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-26/"></a><a href="srfi-26/"><span class="number">26</span></a>: <span class="name">Notation for Specializing Parameters without Currying</span><span class="authors">, by Sebastian Egner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-02-14</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-156/">SRFI 156: Syntactic combiners for binary predicates</a>.</span><div class="abstract">      <p>When programming in functional style, it is
      frequently necessary to specialize some of the parameters of a
      multi-parameter procedure. For example, from the binary operation
      <code>cons</code> one might want to obtain the unary operation
      <code>(lambda (x) (cons 1 x))</code>. This specialization of parameters
      is also known as "partial application", "operator section" or
      "projection".
      <p>The mechanism proposed here allows to write
      this sort of specialization in a simple and compact way. The mechanism is
      best explained by a few examples:
      <table>
        <tr>
          <td><code>(cut cons (+ a 1) &lt;&gt;)</code>
          <td>is the same as
          <td><code>(lambda (x2) (cons (+ a 1) x2))</code>
        <tr>
          <td><code>(cut list 1 &lt;&gt; 3 &lt;&gt; 5)</code>
          <td>is the same as
          <td><code>(lambda (x2 x4) (list 1 x2 3 x4 5))</code>
        <tr>
          <td><code>(cut list)</code>
          <td>is the same as
          <td><code>(lambda () (list))</code>
        <tr>
          <td><code>(cut list 1 &lt;&gt; 3 &lt;...&gt;)</code>
          <td>is the same as
          <td><code>(lambda (x2 . xs) (apply list 1 x2 3 xs))</code>
        <tr>
          <td><code>(cut &lt;&gt; a b)</code>
          <td>is the same as
          <td><code>(lambda (f) (f a b))</code>
      </table>
      <p>As you see, the macro <code>cut</code>
      specializes some of the parameters of its first argument. The parameters
      that are to show up as formal variables of the result are indicated by
      the symbol <code>&lt;&gt;</code>, pronouced as "slot". In addition, the
      symbol <code>&lt;...&gt;</code>, pronounced as "rest-slot", matches all
      residual arguments of a variable argument procedure. As you can see from
      the last example above, the first argument can also be a slot, as one
      should expect in Scheme.
      <p>In addition to <code>cut</code>, there is a
      variant called <code>cute</code> (a mnemonic for "<code>cut</code> with
      evaluated non-slots") which evaluates the non-slot expressions at the
      time the procedure is specialized, not at the time the specialized
      procedure is called. For example,
      <table>
        <tr>
          <td><code>(cute cons (+ a 1) &lt;&gt;)</code>
          <td>is the same as
          <td><code>(let ((a1 (+ a 1))) (lambda (x2) (cons a1 x2)))</code>
      </table>
      <p>As you see from comparing this example with the
      first example above, the <code>cute</code>-variant will evaluate <code>(+
      a 1)</code> once, while the <code>cut</code>-variant will evaluate it
      during every invokation of the resulting procedure.
      <p>The mechanism proposed in this SRFI allows
      specializing any subset of the variables of a procedure. The result can
      be of fixed arity or of variable arity. The mechanism does not allow
      permutation, omission, duplication or any other processing of the
      arguments; for this it is necessary to write to use a different mechanism
      such as <code>lambda</code>.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-25/"></a><a href="srfi-25/"><span class="number">25</span></a>: <span class="name">Multi-dimensional Array Primitives</span><span class="authors">, by Jussi Piitulainen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-05-21</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>A core set of procedures for creating and
      manipulating heterogeneous multidimensional arrays is proposed. The
      design is consistent with the rest of Scheme and independent of other
      container data types. It provides easy sharing of parts of an array as
      other arrays without copying, encouraging a declarative style of
      programming.
      <p>The specification is based on an original
      contribution by Alan Bawden in 1993.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-24/"></a><a href="srfi-24/"><span class="number">24</span></a>: <span class="name">Define-syntax in local lexical scopes</span><span class="authors">, by Antti Huima</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2002-04-12</span></span><span class="keywords" data-keywords="syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=syntax">Syntax</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This document specifies a proper extension to
      Scheme which allows <b>define-syntax</b> forms to appear in those places
      where local definitions can appear (R5RS, 5.2.2). A corresponding
      letrec-variant is described.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-23/"></a><a href="srfi-23/"><span class="number">23</span></a>: <span class="name">Error reporting mechanism</span><span class="authors">, by Stephan Houben</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2001-06-22</span></span><span class="keywords" data-keywords="control-flow,error-handling">Keywords: <a href="https://srfi.schemers.org/?keywords=control-flow">Control Flow</a>, <a href="https://srfi.schemers.org/?keywords=error-handling">Error Handling</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>A mechanism is proposed to allow Scheme code to
      report errors and abort execution. The proposed mechanism is already
      implemented in several Scheme systems and can be implemented, albeit
      imperfectly, in any R5RS conforming Scheme.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-22/"></a><a href="srfi-22/"><span class="number">22</span></a>: <span class="name">Running Scheme Scripts on Unix</span><span class="authors">, by Martin Gasbichler and Michael Sperber</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2002-01-20</span></span><span class="keywords" data-keywords="operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes basic prerequisites for
      running Scheme programs as Unix scripts in a uniform way. Specifically,
      it describes:
      <ul>
        <li>the syntax of Unix scripts written in
        Scheme,
        <li>a uniform convention for calling the Scheme
        script interpreter, and
        <li>a method for accessing the Unix command line
        arguments from within the Scheme script.
      </ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-21/"></a><a href="srfi-21/"><span class="number">21</span></a>: <span class="name">Real-time multithreading support</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2001-03-02</span></span><span class="keywords" data-keywords="concurrency">Keywords: <a href="https://srfi.schemers.org/?keywords=concurrency">Concurrency</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines the following multithreading
      datatypes for Scheme
      <ul>
        <li>Thread
        <li>Mutex
        <li>Condition variable
        <li>Time
      </ul>
      <p>It also defines a mechanism to handle
      exceptions and some multithreading exception datatypes.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-20/"></a><a href="srfi-20/"><span class="number">20</span></a>: <span class="name">Simple object system</span><span class="authors">, by Christian Queinnec</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2001-04-29</span></span><span class="keywords" data-keywords="miscellaneous">Keywords: <a href="https://srfi.schemers.org/?keywords=miscellaneous">Miscellaneous</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI presents an object system to define
      classes, generic functions as well as to support some level of
      introspection. This object system is based on Meroon-V3 which is itself
      inspired by CLOS. <a href="http://www-spi.lip6.fr/~queinnec/WWW/Meroon.html">Meroon-V3</a> is
      distributed and used since 1992.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-19/"></a><a href="srfi-19/"><span class="number">19</span></a>: <span class="name">Time Data Types and Procedures</span><span class="authors">, by Will Fitzgerald</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2000-08-31</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Points in time are represented a the number of
      seconds (with nanosecond precision) since "the epoch," a zero point in
      time. Several standard variants are defined, including UTC (universal
      coordinated time), TAI (international atomic time), and monotonic time. A
      point in time can also be represented as a Julian Day or Modified Julian
      Day number. Time durations, including time spent in a process or thread,
      are defined. Conversion routines are provided. The procedure CURRENT-TIME
      queries the current time in a specified variant, with a system-dependent
      resolution. Procedures for time arithmetic and time comparisons are also
      provided.
      <p>A date is a representation of a point in time
      in the Gregorian calendar, a 24 hour clock (with nanosecond precision)
      and a time zone offset from UTC. Procedures for converting between time
      and dates are provided, as well as for reading and writing string
      representations of dates.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-18/"></a><a href="srfi-18/"><span class="number">18</span></a>: <span class="name">Multithreading support</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2001-03-14</span></span><span class="keywords" data-keywords="concurrency">Keywords: <a href="https://srfi.schemers.org/?keywords=concurrency">Concurrency</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI defines the following multithreading
      datatypes for Scheme
      <ul>
        <li>Thread
        <li>Mutex
        <li>Condition variable
        <li>Time
      </ul>
      <p>It also defines a mechanism to handle
      exceptions and some multithreading exception datatypes.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-17/"></a><a href="srfi-17/"><span class="number">17</span></a>: <span class="name">Generalized set!</span><span class="authors">, by Per Bothner</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2000-07-24</span></span><span class="keywords" data-keywords="assignment">Keywords: <a href="https://srfi.schemers.org/?keywords=assignment">Assignment</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This is a proposal to allow procedure calls
      that evaluate to the "value of a location" to be used to <em>set</em> the
      value of the location, when used as the first operand of
      <code>set!</code>.For example:
      <pre>
(set! (car x) (car y))
</pre>becomes equivalent to
      <pre>
(set-car! x (car y))
</pre>
      <p>Many programming languages have the concept of
      an <i>lvalue</i>. that is an "expression" that "evaluates" to a location,
      and which can appear on the left-hand-side of an assignment. Common Lisp
      has a related concept of "generalized variables" which can be used in
      <code>setf</code> and some other special forms. However, the Common Lisp
      concept is based on the idea of compile-time recognition of special
      "location-producing" functions; this does not seem to be in the "spirit
      of Scheme".
      <p>This SRFI proposes an extension of
      <code>set!</code> so that it provides similar functionality as Common
      Lisp's <code>setf</code>, except that the updater is associated with a
      procedure value, rather than a name.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-16/"></a><a href="srfi-16/"><span class="number">16</span></a>: <span class="name">Syntax for procedures of variable arity</span><span class="authors">, by Lars T Hansen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2000-03-10</span></span><span class="keywords" data-keywords="pattern-matching">Keywords: <a href="https://srfi.schemers.org/?keywords=pattern-matching">Pattern Matching</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>CASE-LAMBDA, a syntax for procedures with a
      variable number of arguments, is introduced.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-15/"></a><a href="srfi-15/"><span class="number">15</span></a>: <span class="name">Syntax for dynamic scoping</span><span class="authors">, by Lars T Hansen</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2000-03-10</span></span><span class="keywords" data-keywords="binding">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>FLUID-LET, a binding syntax for dynamic
      scoping, is introduced.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-14/"></a><a href="srfi-14/"><span class="number">14</span></a>: <span class="name">Character-set Library</span><span class="authors">, by Olin Shivers</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2000-12-28</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>The ability to efficiently represent and
      manipulate sets of characters is an unglamorous but very useful
      capability for text-processing code -- one that tends to pop up in the
      definitions of other libraries. Hence it is useful to specify a general
      substrate for this functionality early. This SRFI defines a general
      library that provides this functionality.
      <p>It is accompanied by a reference implementation
      for the spec. The reference implementation is fairly efficient,
      straightforwardly portable, and has a "free software" copyright. The
      implementation is tuned for "small" 7 or 8 bit character types, such as
      ASCII or Latin-1; the data structures and algorithms would have to be
      altered for larger 16 or 32 bit character types such as Unicode --
      however, the specs have been carefully designed with these larger
      character types in mind.
      <p>Several forthcoming SRFIs can be defined in
      terms of this one:
      <ul>
        <li>string library
        <li>delimited input procedures (<em>e.g.</em>,
        <code>read-line</code>)
        <li>regular expressions
      </ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-13/"></a><a href="srfi-13/"><span class="number">13</span></a>: <span class="name">String Libraries</span><span class="authors">, by Olin Shivers</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2000-12-28</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-130/">SRFI 130: Cursor-based string library</a>.</span><div class="abstract">      <p><abbr title="Revised^5 Report on Scheme">R5RS</abbr> Scheme has an impoverished set
      of string-processing utilities, which is a problem for authors of
      portable code. This <abbr title="Scheme Request for Implementation">SRFI</abbr> proposes a coherent and
      comprehensive set of string-processing procedures; it is accompanied by a
      reference implementation of the spec. The reference implementation
      is
      <ul>
        <li>portable
        <li>efficient
        <li>open source
      </ul>
      <p>The routines in this SRFI are
      backwards-compatible with the string-processing routines of <abbr title="Revised^5 Report on Scheme">R5RS</abbr>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-12/"></a><a href="srfi-12/"><span class="number">12</span></a>: <span class="name">Exception Handling</span><span class="authors">, by William Clinger, R. Kent Dybvig, Matthew Flatt, and Marc Feeley</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">2000-01-22</span></span><span class="keywords" data-keywords="control-flow,exceptions">Keywords: <a href="https://srfi.schemers.org/?keywords=control-flow">Control Flow</a>, <a href="https://srfi.schemers.org/?keywords=exceptions">Exceptions</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>The SRFI defines exception-handling constructs
      for Scheme, including
      <ul>
        <li>the CURRENT-EXCEPTION-HANDLER procedure for
        obtaining the current exception-handling procedure,
        <li>the WITH-EXCEPTION-HANDLER procedure and
        HANDLE-EXCEPTIONS form for installing an exception-handling
        procedure,
        <li>the ABORT and SIGNAL procedures for raising
        exceptions, and
        <li>constructs for creating and inspecting
        <em>condition</em> values, which encapsulate information about an
        exception.
      </ul>
      <p>This SRFI requires a Scheme implementation to
      raise an exception whenever an error is to be signaled or whenever the
      system determines that evaluation cannot proceed in a manner consistent
      with the semantics of Scheme. However, this SRFI does not define the
      information to be supplied by an implementation for each possible kind of
      exception; such a specification is left open for future SRFIs.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-11/"></a><a href="srfi-11/"><span class="number">11</span></a>: <span class="name">Syntax for receiving multiple values</span><span class="authors">, by Lars T Hansen</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2000-03-15</span></span><span class="keywords" data-keywords="binding,multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-8/">SRFI 8: receive: Binding to multiple values</a>, <a href="/srfi-71/">SRFI 71: Extended LET-syntax for multiple values</a>, and <a href="/srfi-210/">SRFI 210: Procedures and Syntax for Multiple Values</a>.</span><div class="abstract">      <p>The SRFI introduces syntactic forms LET-VALUES
      and LET*-VALUES that bind the values of expressions that return multiple
      values.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-10/"></a><a href="srfi-10/"><span class="number">10</span></a>: <span class="name">#, external form</span><span class="authors">, by Oleg Kiselyov</span><span class="based-on"></span><span class="date-group">Final: <span class="date">2000-01-13</span></span><span class="keywords" data-keywords="reader-syntax">Keywords: <a href="https://srfi.schemers.org/?keywords=reader-syntax">Reader Syntax</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>The present SRFI proposes an extensible
      external representation of Scheme values, a notational convention for
      future SRFIs. This SRFI adds <code>#,(</code> as a new token and extends
      production rules of the grammar for a Scheme reader. The
      <code>#,()</code> form can be used for example to denote values that do
      not have a convenient printed representation, as well for conditional
      code compilation. It is proposed that future SRFIs that contain new read
      syntax for values use the <code>#,()</code> notation with an appropriate
      tag symbol.
      <p>As a particular example and the reference
      implementation for the <code>#,()</code> convention, this SRFI describes
      an interpretation of the <code>#,()</code> external form as a read-time
      application.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-9/"></a><a href="srfi-9/"><span class="number">9</span></a>: <span class="name">Defining Record Types</span><span class="authors">, by Richard Kelsey</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-09-09</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes syntax for creating new
      data types, called record types. A predicate, constructor, and field
      accessors and modifiers are defined for each record type. Each new record
      type is distinct from all existing types, including other record types
      and Scheme's predefined types.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-8/"></a><a href="srfi-8/"><span class="number">8</span></a>: <span class="name">receive: Binding to multiple values</span><span class="authors">, by John David Stone</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-08-30</span></span><span class="keywords" data-keywords="binding,multiple-value-returns">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=multiple-value-returns">Multiple-Value Returns</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-11/">SRFI 11: Syntax for receiving multiple values</a>, <a href="/srfi-71/">SRFI 71: Extended LET-syntax for multiple values</a>, and <a href="/srfi-210/">SRFI 210: Procedures and Syntax for Multiple Values</a>.</span><div class="abstract">      <p>The only mechanism that R<sup>5</sup>RS
      provides for binding identifiers to the values of a multiple-valued
      expression is the primitive <code>call-with-values</code>. This SRFI
      proposes a more concise, more readable syntax for creating such
      bindings.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-7/"></a><a href="srfi-7/"><span class="number">7</span></a>: <span class="name">Feature-based program configuration language</span><span class="authors">, by Richard Kelsey</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-08-19</span></span><span class="keywords" data-keywords="features">Keywords: <a href="https://srfi.schemers.org/?keywords=features">Features</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>This SRFI describes a configuration language to
      be used for specifying the set of Scheme features or extensions required
      to run a program. In addition to a list of required features, a program
      may also contain Scheme code to be used only when a particular feature or
      combination of features is available.
      <p>The configuration language is entirely distinct
      from Scheme; it is neither embedded in Scheme nor includes Scheme as a
      subset.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-6/"></a><a href="srfi-6/"><span class="number">6</span></a>: <span class="name">Basic String Ports</span><span class="authors">, by William D Clinger</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-07-01</span></span><span class="keywords" data-keywords="i/o,operating-system">Keywords: <a href="https://srfi.schemers.org/?keywords=i/o">I/O</a>, <a href="https://srfi.schemers.org/?keywords=operating-system">Operating System</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>Scheme's i/o primitives are extended by adding
      three new procedures that
      <ul>
        <li>create an input port from a string,
        <li>create an output port whose contents are
        accumulated in Scheme's working memory instead of an external file,
        and
        <li>extract the accumulated contents of an
        in-memory output port and return them in the form of a string.
      </ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-5/"></a><a href="srfi-5/"><span class="number">5</span></a>: <span class="name">A compatible let form with signatures and rest arguments</span><span class="authors">, by Andy Gaynor</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-04-26</span></span><span class="keywords" data-keywords="binding">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>The <i>named-let</i> incarnation of the
      <code>let</code> form has two slight inconsistencies with the
      <code>define</code> form. As defined, the <code>let</code> form makes no
      accommodation for rest arguments, an issue of functionality and
      consistency. As defined, the <code>let</code> form does not accommodate
      signature-style syntax, an issue of aesthetics and consistency. Both
      issues are addressed here in a manner which is compatible with the
      traditional <code>let</code> form but for minor extensions.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-4/"></a><a href="srfi-4/"><span class="number">4</span></a>: <span class="name">Homogeneous numeric vector datatypes</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-05-22</span></span><span class="keywords" data-keywords="data-structure,numbers">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=numbers">Numbers</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-160/">SRFI 160: Homogeneous numeric vector libraries</a>.</span><div class="abstract">      <p>This SRFI describes a set of datatypes for
      vectors whose elements are of the same numeric type (signed or unsigned
      exact integer or inexact real of a given precision). These datatypes
      support operations analogous to the Scheme vector type, but they are
      distinct datatypes. An external representation is specified which must be
      supported by the <code>read</code> and <code>write</code> procedures and
      by the program parser (i.e. programs can contain references to literal
      homogeneous vectors).</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-3/"></a><a href="srfi-3/"><span class="number">3</span></a>: <span class="name">List-Set Library</span><span class="authors">, by Olin Shivers</span><span class="based-on"></span><span class="date-group">Withdrawn: <span class="date">1999-08-26</span></span><span class="keywords" data-keywords="data-structure">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI proposes a coherent and comprehensive
      set of procedures for manipulating lists as sets; it is accompanied by a
      reference implementation of the spec. The reference implementation
      is
      <ul>
        <li>portable
        <li>efficient
        <li>completely open, public-domain source
      </ul>
      <p>Be aware that these procedures are inherently
      O(n^2) in the lengths of their parameter lists - serious set operations
      on large lists should use alternate techniques.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-2/"></a><a href="srfi-2/"><span class="number">2</span></a>: <span class="name">AND-LET*: an AND with local bindings, a guarded LET* special form</span><span class="authors">, by Oleg Kiselyov</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-03-01</span></span><span class="keywords" data-keywords="binding,control-flow">Keywords: <a href="https://srfi.schemers.org/?keywords=binding">Binding</a>, <a href="https://srfi.schemers.org/?keywords=control-flow">Control Flow</a></span><span class="status" data-status="final"></span><span class="see-also">See also <a href="/srfi-202/">SRFI 202: Pattern-matching Variant of the and-let* Form that Supports Multiple Values</a>.</span><div class="abstract">      <p>Like an ordinary AND, an AND-LET* special form
      evaluates its arguments -- expressions -- one after another in order,
      till the first one that yields #f. Unlike AND, however, a non-#f result
      of one expression can be bound to a fresh variable and used in the
      subsequent expressions. AND-LET* is a cross-breed between LET* and
      AND.</div></li>
      <li class="card final"><a class="card-anchor" href="srfi-1/"></a><a href="srfi-1/"><span class="number">1</span></a>: <span class="name">List Library</span><span class="authors">, by Olin Shivers</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-10-09</span></span><span class="keywords" data-keywords="data-structure,r7rs-large,r7rs-large-red">Keywords: <a href="https://srfi.schemers.org/?keywords=data-structure">Data Structure</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large">R7RS Large</a>, <a href="https://srfi.schemers.org/?keywords=r7rs-large-red">R7RS Large: Red Edition</a></span><span class="status" data-status="final"></span><div class="abstract">      <p><abbr title="Revised^5 Report on Scheme">R5RS</abbr> Scheme has an impoverished set
      of list-processing utilities, which is a problem for authors of portable
      code. This <abbr title="Scheme Request for Implementation">SRFI</abbr>
      proposes a coherent and comprehensive set of list-processing procedures;
      it is accompanied by a reference implementation of the spec. The
      reference implementation is
      <ul>
        <li>portable
        <li>efficient
        <li>completely open, public-domain source
      </ul></div></li>
      <li class="card final"><a class="card-anchor" href="srfi-0/"></a><a href="srfi-0/"><span class="number">0</span></a>: <span class="name">Feature-based conditional expansion construct</span><span class="authors">, by Marc Feeley</span><span class="based-on"></span><span class="date-group">Final: <span class="date">1999-05-07</span></span><span class="keywords" data-keywords="features">Keywords: <a href="https://srfi.schemers.org/?keywords=features">Features</a></span><span class="status" data-status="final"></span><div class="abstract">      <p>It is desirable that programs which depend on
      additions to standard Scheme name those additions. SRFIs provide the
      specifications of these additions ("features"), and SRFI 0 provides the
      means to actually check that these features are present in the Scheme
      system by means of the <code>cond-expand</code> construct. It is
      anticipated that there will be two main classes of features:
      <ul>
        <li>sets of value and syntax bindings
        <li>reader syntax extensions
      </ul>
      <p>("Reader syntax" refers to aspects of the
      syntax described by the grammars in the Scheme reports.)
      <p>The former class of features will probably
      include most SRFIs, exemplified by the list library specified in <a href="https://srfi.schemers.org/srfi-1/">SRFI 1</a>. The latter class includes Unicode source code
      support and different kinds of parentheses.
      <p>Control over the presence of individual
      features will vary over different Scheme systems. A given feature may be
      absent or provided by default in some Scheme systems and in others some
      mechanism (such as an "import" clause in the code or a program
      configuration file, a command line option, a dependency declaration in a
      module definition, etc.) will be required for the feature to be present
      in the system.
      <p>Moreover, in some systems a given feature may
      be in effect throughout the entire program if it is in effect anywhere at
      all. Other systems may have more precise mechanisms to control the scope
      of a feature (this might be the case for example when a module system is
      supported). In general it is thus possible that a feature is in effect in
      some parts of the program and not in others. This allows conflicting
      SRFIs to be present in a given program as long as their scope do not
      intersect.
      <p>SRFI 0 does not prescribe a particular
      mechanism for controlling the presence of a feature as it is our opinion
      that this should be the role of a module system. We expect that future
      module system SRFIs will need to extend the semantics of SRFI 0 for their
      purposes, for example by defining feature scoping rules or by
      generalizing the feature testing construct.</div></li></ul></div>

    <hr />

    <p>Here is <a href="srfi-privacy.html">our privacy statement</a>.

    <p>If you have any general questions about this site, please
    contact <a href="mailto:srfi-editors%20at%20srfi%20dot%20schemers%20dot%20org">the
    SRFI editors</a>.</p>

    <script crossorigin="anonymous"
            integrity="sha384-JDmRxRiXkNkskRM5AD4qHRGk9ItwZ9flbqOpsRYs8SOrIRwcMtTGKP2Scnjptzgm"
            src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
    <script src="srfi.js"></script></body></html>