<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link href="admin.css" rel="stylesheet" type="text/css">
    <link href="list.css" rel="stylesheet" type="text/css">
    <link href="favicon.png" rel="icon" sizes="192x192" type="image/png">
    <meta name=viewport content="width=device-width, initial-scale=1" />
    <title>Withdrawn Scheme Requests for Implementation</title>
  </head>
  <body>
    <h1>Withdrawn Scheme Requests for Implementation</h1>
    <div id="srfis">
      <input class="search" placeholder="Search" tabindex="1" />
      Sort by
      <button class="sort" data-sort="authors" tabindex="2" >authors</button>
      <button class="sort" data-sort="date" tabindex="3" >date</button>
      <button class="sort" data-sort="name" tabindex="4" >name</button>
      <button class="sort" data-sort="number" tabindex="5" >number</button>
      <ul class="list">
      <li class="card withdrawn"><a class="card-anchor" href="srfi-3/"></a><span class="number">3</span><span class="name">List-Set Library</span><span class="authors">by Olin Shivers</span><span class="date-group">Withdrawn: <span class="date">1999/08/26</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI proposes a coherent and comprehensive
      set of procedures for manipulating lists as sets; it is accompanied by a
      reference implementation of the spec. The reference implementation
      is
      <ul>
        <li>portable
        <li>efficient
        <li>completely open, public-domain source
      </ul>
      <p>Be aware that these procedures are inherently
      O(n^2) in the lengths of their parameter lists - serious set operations
      on large lists should use alternate techniques.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-12/"></a><span class="number">12</span><span class="name">Exception Handling</span><span class="authors">by William Clinger, R. Kent Dybvig, Matthew Flatt, and Marc Feeley</span><span class="date-group">Withdrawn: <span class="date">2000/01/22</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>The SRFI defines exception-handling constructs
      for Scheme, including
      <ul>
        <li>the CURRENT-EXCEPTION-HANDLER procedure for
        obtaining the current exception-handling procedure,
        <li>the WITH-EXCEPTION-HANDLER procedure and
        HANDLE-EXCEPTIONS form for installing an exception-handling
        procedure,
        <li>the ABORT and SIGNAL procedures for raising
        exceptions, and
        <li>constructs for creating and inspecting
        <em>condition</em> values, which encapsulate information about an
        exception.
      </ul>
      <p>This SRFI requires a Scheme implementation to
      raise an exception whenever an error is to be signaled or whenever the
      system determines that evaluation cannot proceed in a manner consistent
      with the semantics of Scheme. However, this SRFI does not define the
      information to be supplied by an implementation for each possible kind of
      exception; such a specification is left open for future SRFIs.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-15/"></a><span class="number">15</span><span class="name">Syntax for dynamic scoping</span><span class="authors">by Lars T Hansen</span><span class="date-group">Withdrawn: <span class="date">2000/03/10</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>FLUID-LET, a binding syntax for dynamic
      scoping, is introduced.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-20/"></a><span class="number">20</span><span class="name">Simple object system</span><span class="authors">by Christian Queinnec</span><span class="date-group">Withdrawn: <span class="date">2001/04/29</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI presents an object system to define
      classes, generic functions as well as to support some level of
      introspection. This object system is based on Meroon-V3 which is itself
      inspired by CLOS. <a href=
      "http://www-spi.lip6.fr/~queinnec/WWW/Meroon.html">Meroon-V3</a> is
      distributed and used since 1992.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-24/"></a><span class="number">24</span><span class="name">Define-syntax in local lexical scopes</span><span class="authors">by Antti Huima</span><span class="date-group">Withdrawn: <span class="date">2002/04/12</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This document specifies a proper extension to
      Scheme which allows <b>define-syntax</b> forms to appear in those places
      where local definitions can appear (R5RS, 5.2.2). A corresponding
      letrec-variant is described.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-32/"></a><span class="number">32</span><span class="name">Sort Libraries</span><span class="authors">by Olin Shivers</span><span class="date-group">Withdrawn: <span class="date">2003/07/17</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Current Scheme sorting packages are, every one
      of them, surprisingly bad. I've designed the API for a full-featured sort
      toolkit, which I propose as an SRFI. The spec comes with 1200 lines of
      high-quality reference code: tightly written, highly commented, portable
      code, available for free. Implementors want this code. It's better than
      what you have.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-33/"></a><span class="number">33</span><span class="name">Integer Bitwise-operation Library</span><span class="authors">by Olin Shivers</span><span class="date-group">Withdrawn: <span class="date">2003/07/17</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>R5RS Scheme has no utilities for performing
      bitwise logical operations on integers or bitstrings, which is a problem
      for authors of portable code. This SRFI proposes a coherent and
      comprehensive set of these functions; it is accompanied by a reference
      implementation of the spec in terms of a set of seven core operators. The
      reference implementation is
      <ul>
        <li>portable
        <li>efficient
        <li>completely open, public-domain source
      </ul>
      <p>The precise semantics of these operators is
      almost never an issue. A consistent, portable set of *names* and
      *parameter conventions*, however, is. Hence this SRFI.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-40/"></a><span class="number">40</span><span class="name">A Library of Streams</span><span class="authors">by Philip L. Bewig</span><span class="date-group">Withdrawn: <span class="date">2017/8/10</span></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-41/">SRFI 41: Streams</a>.</span><div class="abstract">      <p>Along with higher-order functions, one of the
      hallmarks of functional programming is lazy evaluation. A primary
      manifestation of lazy evaluation is lazy lists, generally called streams
      by Scheme programmers, where evaluation of a list element is delayed
      until its value is needed.
      <p>The literature on lazy evaluation distinguishes
      two styles of laziness, called even and odd. Odd style streams are
      ubiquitous among Scheme programs and can be easily encoded with the
      Scheme primitives delay and force defined in R5RS. However, the even
      style delays evaluation in a manner closer to that of traditional lazy
      languages such as Haskell and avoids an "off by one" error that is
      symptomatic of the odd style.
      <p>This SRFI defines the stream data type in the
      even style, some essential procedures and syntax that operate on streams,
      and motivates our choice of the even style. A companion SRFI 41 Stream
      Library provides additional procedures and syntax which make for more
      convenient processing of streams and shows several examples of their
      use.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-50/"></a><span class="number">50</span><span class="name">Mixing Scheme and C</span><span class="authors">by Richard Kelsey and Michael Sperber</span><span class="date-group">Withdrawn: <span class="date">2005/12/20</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI describes an interface for calling C
      functions from Scheme, calling Scheme functions from C, and allocating
      storage in the Scheme heap. Scheme manages stub functions in C that
      negotiate between the calling conventions of Scheme and C and the memory
      allocation policies of both worlds.
      <p>The following facilities are available for
      interfacing between Scheme and C:
      <ul>
        <li>Scheme code can call C functions.
        <li>The external interface provides full
        introspection for all Scheme objects. External code may inspect,
        modify, and allocate Scheme objects arbitrarily.
        <li>External code may signal errors to the
        Scheme system.
        <li>External code may call back into Scheme.
        Scheme correctly unrolls the process stack on non-local exits.
        <li>External modules may register bindings of
        names to values with a central registry accessible from Scheme.
        Conversely, Scheme code can register shared bindings for access by C
        code.
      </ul>
      <p>The interface is closely based on that of
      <a href="http://www.s48.org/">Scheme 48</a> and <a href=
      "http://www.scsh.net/">scsh</a>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-52/"></a><span class="number">52</span><span class="name">Permitting and Supporting Extended Character Sets</span><span class="authors">by Thomas Lord (lord@emf.net aka lord@gnu.org)</span><span class="date-group">Withdrawn: <span class="date">2004/06/17</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI describes how to modify the
      <i>Revised Report</i> (<a href=
      "http://www.schemers.org/Documents/Standards/R5RS/">R5RS</a>) in order to
      enable conforming implementations to use an extended character set such
      as (but not limited to) <a href=
      "http://www.unicode.org">Unicode</a>.
      <p>Changes to some requirements of the report are
      recommended. Currently, the <i>Revised Report</i> contains requirements
      which are difficult or impossible to satisfy with some extended character
      sets.
      <p>New required procedures are proposed,
      specified, and included in the reference implementation. These procedures
      enable portable Scheme programs to manipulate Scheme source texts and
      source data accurately, even in implementations using extended character
      sets.
      <p>This SRFI concludes with some suggestions for
      implementors interested in providing good Unicode support, using these
      suggestions to illustrate how the proposed changes to the <i>Revised
      Report</i> can "play out" in Unicode-based Scheme.
      <p>This SRFI does <b>not</b> attempt to provide a
      comprehensive library for global text processing. For example, one issue
      in global text processing is the need for linguistically-sensitive,
      locale-sensitive procedures for sorting strings. Such procedures are
      beyond the scope of this SRFI. On the other hand, by making Scheme
      compatible with extended character sets, this SRFI is a step in the
      direction of permitting global text processing standard libraries to be
      developed in a form portable across all conforming
      implementations.
      <p>This SRFI does <b>not</b> propose that
      implementations be required to support Unicode or any other extended
      character set. It does not specify a representation for Unicode
      characters or strings. It <b>does</b> revise the specifications of the
      report so that <code>char?</code> values <i>may be</i> Unicode (or other)
      characters.
      <p>The reference implementation included should
      prove to be easily ported to and effective for all ASCII-only
      implementations and for many implementations using an 8-bit character set
      which is an extension of ASCII (it will require very minor modifications
      for each particular implementation). Other implementations may need to
      use a different implementation.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-53/"></a><span class="number">53</span><span class="name">Syntactic computations with computation-rules</span><span class="authors">by Andr√© van Tonder</span><span class="date-group">Withdrawn: <span class="date">2004/09/06</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI provides a portable framework for
      writing complex high-level macros that perform nontrivial computations
      during expansion.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-56/"></a><span class="number">56</span><span class="name">Binary I/O</span><span class="authors">by Alex Shinn</span><span class="date-group">Withdrawn: <span class="date">2005/10/31</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI extends Scheme with procedures to
      read and write binary data to and from ports, including utility
      procedures for writing various integer and floating point values in both
      big and little endian formats. Predicates are provided to test if binary
      I/O is allowed on a port, along with new procedures for creating such
      ports.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-65/"></a><span class="number">65</span><span class="name">define-immutable: A Syntax to Define Identifiers With Immutable Values</span><span class="authors">by Andrew Wilcox</span><span class="date-group">Withdrawn: <span class="date">2005/05/17</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>The <tt>define-immutable</tt> form defines an
      identifier whose value never changes.
      <p>The expression part of the definition is
      evaluated lazily: it is not evaluated unless and until the identifier is
      evaluated. This permits an immutable definition to use other definitions
      in more ways than is possible when using <tt>define</tt> in internal
      definitions.
      <p>A series of immutable definitions have simple
      semantics, making them easy to program and understand.
      <pre>
    (let ()
      (define-immutable x (+ z 5))
      (define-immutable y (/ 100 4))
      (define-immutable z (add-10 y))
      (define-immutable add-10 (add-n 10))
      (define-immutable (add-n n)
        (lambda (x)
          (+ n x)))
      x)
  =&gt;
    40
</pre></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-68/"></a><span class="number">68</span><span class="name">Comprehensive I/O</span><span class="authors">by Michael Sperber</span><span class="date-group">Withdrawn: <span class="date">2005/11/29</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines a comprehensive I/O subsystem
      for Scheme with three layers, where each layer is built on top of the one
      below it:
      <ul>
        <li>The lowest, primitive layer provides
        unbuffered I/O, and is close to what a typical operating system
        offers.
        <li>The middle layer builds on lazy, mostly
        functional buffered streams.
        <li>The upper layer is similar in nature to the
        ports subsystem in R5RS, and provides conventional, imperative buffered
        input and output.
      </ul>
      <p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href=
      "http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      <p>In particular, the subsystem provides
      <ul>
        <li>buffered reading and writing
        <li>arbitrary lookahead at the streams
        level
        <li>dynamic redirection of input or output at
        the ports level
        <li>binary and text I/O, mixed if needed
        <li>translated data streams
        <li>unbuffered I/O at the primitive layer
        <li>the ability to create arbitrary I/O streams,
        such as to and from blobs and strings
      </ul>
      <p>The subsystem does <em>not</em> provide
      <ul>
        <li>formatted I/O
        <li>non-blocking or selective I/O
        <li>portable filenames, or any functionality for
        manipulating filenames
        <li>filesystem operations
        <li>socket I/O
        <li>extremely high-throughput or zero-copy
        I/O
      </ul>
      <p>However, all of these could be added on top of
      one or several of the layers specified in this SRFI.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-73/"></a><span class="number">73</span><span class="name">Exact Infinities</span><span class="authors">by Chongkai Zhu</span><span class="date-group">Withdrawn: <span class="date">2005/11/30</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Many Scheme implementations support exact
      arbitrary-precision integer arithmetic as well as exact rational number
      computation. This SRFI extends the rational numbers of R5RS by adding two
      rational infinities (1/0, -1/0).
      <p>With infinities added to the number system we
      find that division by zero "works". It lets initialization of variables
      precede bounds checks and gives flexibility in placement of those
      checks.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-75/"></a><span class="number">75</span><span class="name">R6RS Unicode data</span><span class="authors">by Matthew Flatt and Marc Feeley</span><span class="date-group">Withdrawn: <span class="date">2006/05/27</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Unicode is a widespread universal character
      code that supports most of the world's (natural) languages. The
      extensions to Scheme specified in this SRFI concern the support of
      Unicode in Scheme's character, string, and symbol datatypes. This SRFI
      does not (fully) specify how I/O of Unicode data is performed or how
      Scheme source code is encoded in files; these aspects are left for other
      SRFIs to specify.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-76/"></a><span class="number">76</span><span class="name">R6RS Records</span><span class="authors">by Will Clinger, R. Kent Dybvig, Michael Sperber, Anton van Straaten</span><span class="date-group">Withdrawn: <span class="date">2006/04/24</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI describes abstractions for creating
      new data types representing records - data structures with named fields.
      This SRFI comes in four parts:
      <ul>
        <li>a procedural layer for creating and
        manipulating record types and record instances
        <li>an explicit-naming syntactic layer for
        defining the various entities associated with a record type -
        construction procedure, predicate, field accessors, mutators, etc. - at
        once
        <li>an implicit-naming syntactic layer built on
        top of the explicit-naming syntactic layer, which chooses the names for
        the various products based on the names of the record type and
        fields
        <li>a set of reflection procedures
      </ul></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-77/"></a><span class="number">77</span><span class="name">Preliminary Proposal for R6RS Arithmetic</span><span class="authors">by William D Clinger and Michael Sperber</span><span class="date-group">Withdrawn: <span class="date">2006/09/13</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Scheme's arithmetic system was designed to
      allow a wide variety of implementations. After many years of
      implementation experience, however, most implementations now fall into a
      small number of categories, and the benefits of continued experimentation
      no longer justify the confusion and portability problems that have
      resulted from giving implementations so much freedom in this area.
      Moreover, the R5RS generic arithmetic is difficult to implement as
      efficiently as purely fixnum or purely flonum arithmetic. (Fixnum
      arithmetic is typically limited-precision integer arithmetic implemented
      using one or more representations that may be especially efficient on the
      executing machine; flonum arithmetic is typically limited-precision
      floating-point arithmetic using one or more representations that may be
      especially efficient on the executing machine.)
      <p>This SRFI is an effort to extend and clarify
      the R5RS arithmetic to make it more portable, more comprehensive, and
      enable faster programs.
      <p>Furthermore, one of us (Sperber) has argued
      that Scheme's arithmetic requires radical overhaul. The other (Clinger)
      agrees that revisions are needed. Whether these revisions qualify as
      radical is best left to the judgement of individual readers.
      <p>This SRFI proposes to revise section 6.2
      ("Numbers") of R5RS by:
      <ul>
        <li>requiring a Scheme implementation to provide
        the full tower, including exact rationals of arbitrary precision, exact
        rectangular complex numbers with rational real and imaginary parts, and
        inexact real and complex arithmetic
        <li>defining fixnum arithmetic (parameterized by
        precision)
        <li>defining flonum arithmetic
        (inexactly)
        <li>defining new procedures for performing exact
        arithmetic
        <li>defining new procedures for performing
        inexact arithmetic
        <li>describing the external representation and
        semantics of 0.0, -0.0, infinities and NaNs for systems that implement
        inexact real arithmetic using IEEE binary floating point&lt;?
        <li>changing the specification of
        <code>eqv?</code> to behave more sensibly with inexact numbers
        <li>defining Scheme's real numbers to be the
        complex numbers whose imaginary part is an exact zero
        <li>adding an external representation for
        inexact numbers that expresses the precision of a binary floating point
        representation
        <li>defining procedures for some new operations,
        including integer division and remainder on real numbers, and bitwise
        operations,
        <li>restricting the domains of some R5RS
        procedures
        <li>clarifying the semantics of some R5RS
        procedures
        <li>possibly changing the semantics of some R5RS
        procedures
      </ul></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-79/"></a><span class="number">79</span><span class="name">Primitive I/O</span><span class="authors">by Michael Sperber</span><span class="date-group">Withdrawn: <span class="date">2006/11/16</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines a simple, primitive I/O
      subsystem for Scheme that is intended to function as the lowest layer of
      a more comprehensive suite of I/O layers. It provides unbuffered I/O, and
      is close to what a typical operating system offers. Thus, its interface
      is suitable for implementing high-throughput and zero-copy I/O.
      <p>The Primitive I/O layer also allows clients to
      implement custom data sources and sinks via a simple interface.
      <p>Moreover, this SRFI defines a condition
      hierarchy specifying common I/O-related exceptional situations.
      <p>The Primitive I/O layer only handles
      blocking-I/O. Non-blocking and selective I/O is left for another
      SRFI.
      <p>This I/O layer was designed in conjunction with
      two other layers that can be built on top of it: <a href="/srfi-80/">SRFI
      80 (Stream I/O)</a> and <a href="/srfi-81/">SRFI 81 (Port I/O)</a>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-80/"></a><span class="number">80</span><span class="name">Stream I/O</span><span class="authors">by Michael Sperber</span><span class="date-group">Withdrawn: <span class="date">2006/11/20</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines an I/O layer for lazy, mostly
      functional buffered streams.
      <p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href=
      "http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      <p>In particular, this layer provides
      <ul>
        <li>buffered reading and writing
        <li>arbitrary lookahead
        <li>dynamic redirection of input or
        output
        <li>binary and text I/O, mixed if needed
        <li>translated data streams
        <li>the ability to create I/O streams from
        arbitrary readers and writers
      </ul>
      <p>It builds on the Primitive I/O layer specified
      in <a href="/srfi-79/">SRFI 79 (Primitive I/O)</a>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-81/"></a><span class="number">81</span><span class="name">Port I/O</span><span class="authors">by Michael Sperber</span><span class="date-group">Withdrawn: <span class="date">2006/11/20</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines an I/O layer similar in
      nature to the ports subsystem in R5RS, and provides conventional,
      imperative buffered input and output.
      <p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href=
      "http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      <p>In particular, the subsystem fulfills the
      following requirements:
      <ul>
        <li>buffered reading and writing
        <li>binary and text I/O, mixed if needed
        <li>the ability to create arbitrary I/O ports
        from readers and writers
      </ul>
      <p>It builds on the Primitive I/O layer specified
      in <a href="/srfi-79/">SRFI 79 (Primitive I/O)</a>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-82/"></a><span class="number">82</span><span class="name">Stream Ports</span><span class="authors">by Michael Sperber</span><span class="date-group">Withdrawn: <span class="date">2006/11/20</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI augments <a href="/srfi-81/">SRFI 81
      (Port I/O)</a> by allowing ports to be constructed from streams as
      described in <a href="/srfi-80/">SRFI 80 (Stream I/O)</a>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-83/"></a><span class="number">83</span><span class="name">R6RS Library Syntax</span><span class="authors">by Matthew Flatt and Kent Dybvig</span><span class="date-group">Withdrawn: <span class="date">2006/09/13</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>The module system presented here is designed to
      let programmers share libraries, i.e., code that is intended to be
      incorporated into larger programs, and especially into programs that use
      library code from multiple sources. The module system supports macro
      definitions within modules, allows macro exports, and distinguishes the
      phases in which definitions and imports are needed. This SRFI defines a
      standard notation for libraries, a semantics for library expansion and
      execution, and a simple format for sharing libraries.
      <!-- ISSUES --></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-84/"></a><span class="number">84</span><span class="name">Universal Identifiers</span><span class="authors">by Andrew Wilcox</span><span class="date-group">Withdrawn: <span class="date">2006/11/09</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI proposes a social convention to allow
      programmers to easily create short, simple Scheme symbols which are
      guaranteed to be universally unique: No other programmer also following
      this SRFI will accidentally create a symbol eq? to yours.
      <p>Universally unique symbols are useful to
      identify standards, languages, libraries, types, classes, and other
      resources.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-85/"></a><span class="number">85</span><span class="name">Recursive Equivalence Predicates</span><span class="authors">by William D Clinger</span><span class="date-group">Withdrawn: <span class="date">2006/10/21</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines two related equivalence
      predicates that are recursive, not just partial recursive: they terminate
      on all arguments. One of these predicates, <code>equiv?</code>, is
      consistent with the <code>equal?</code> procedure described in the R5RS:
      Whenever <code>equal?</code> terminates, <code>equiv?</code> returns the
      same value as <code>equal?</code>.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-91/"></a><span class="number">91</span><span class="name">Extended ports</span><span class="authors">by Marc Feeley</span><span class="date-group">Withdrawn: <span class="date">2007/07/10</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI specifies an extension to the R5RS
      ports that supports several useful features: binary I/O and text I/O,
      bulk I/O, file opening attributes, and bidirectional ports. Binary I/O is
      provided through byte ports which are ports whose fundamental I/O unit is
      an 8 bit byte. Because characters can be encoded with bytes using a
      character encoding such as ISO 8859-1, UTF-8, and UTF-16BE, any byte port
      is also a character port (a port that supports the character level I/O of
      R5RS). A byte port's character encoding and various other attributes are
      specified when the port is opened. Because reasonable defaults exist,
      these attributes are specified using a named optional parameter syntax.
      All procedures which have the same name as in R5RS are compatible with
      R5RS but may provide additional functionality.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-92/"></a><span class="number">92</span><span class="name">ALAMBDA and ALAMBDA*</span><span class="authors">by Joo ChurlSoo</span><span class="date-group">Withdrawn: <span class="date">2007/04/09</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI introduces ALAMBDA and ALAMBDA*, each
      of which has two modes of operation:
      <ol>
        <li>it creates a procedure that checks actual
        arguments and takes optional arguments,
        <li>it returns a different procedure by checking
        each of actual arguments and the number of them.
      </ol></div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-93/"></a><span class="number">93</span><span class="name">R6RS Syntax-Case Macros</span><span class="authors">by Kent Dybvig</span><span class="date-group">Withdrawn: <span class="date">2006/08/23</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>The syntactic abstraction system described here
      extends the R5RS macro system with support for writing low-level macros
      in a high-level style, with automatic syntax checking, input
      destructuring, output restructuring, maintenance of lexical scoping and
      referential transparency (hygiene), and support for controlled identifier
      capture, with constant expansion overhead. Because it does not require
      literals, including quoted lists or vectors, to be copied or even
      traversed, it preserves sharing and cycles within and among the constants
      of a program. It also supports source-object correlation, i.e., the
      maintenance of ties between the original source code and expanded output,
      allowing implementations to provide source-level support for debuggers
      and other tools.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-102/"></a><span class="number">102</span><span class="name">Procedure Arity Inspection</span><span class="authors">by David Van Horn</span><span class="date-group">Withdrawn: <span class="date">2013/02/24</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>Many Scheme systems provide mechanisms for
      inspecting the arity of a procedural value, making it a common feature,
      however there is no standard interface. As a result there is no portable
      way to observe the arity of a procedure <em>without actually applying
      it</em>. This SRFI proposes a simple interface that is consistent with
      existing Scheme systems' facilities and prior proposals.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-103/"></a><span class="number">103</span><span class="name">Library Files</span><span class="authors">by Derick Eddington</span><span class="date-group">Withdrawn: <span class="date">2013/05/08</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI defines a standard for locating files
      containing libraries with list-of-symbols library names, for unixes and
      Windows. It defines a standard for files containing R6RS libraries. It
      supports different Scheme dialects.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-104/"></a><span class="number">104</span><span class="name">Library Files Utilities</span><span class="authors">by Derick Eddington</span><span class="date-group">Withdrawn: <span class="date">2010/05/23</span></span><span class="status" data-status="withdrawn"></span><div class="abstract">      <p>This SRFI implements <a href=
      "/srfi-103/">SRFI&nbsp;103: Library Files</a> as a library. It is useful
      for working with library files.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-114/"></a><span class="number">114</span><span class="name">Comparators</span><span class="authors">by John Cowan</span><span class="date-group">Withdrawn: <span class="date">2017/8/10</span></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-128/">SRFI 128: Comparators (reduced)</a>.</span><div class="abstract">      <p>This proposal is a rewrite of <a href=
      "/srfi-67/">SRFI 67</a>, Compare Procedures, extending it from procedures
      that represent a total order to procedure bundles that represent one or
      more of a total order, an equality predicate, and a hash function. By
      packaging these procedures together, along with a type test predicate,
      they can be treated as a single item for use in the implementation of
      data structures.</div></li>
      <li class="card withdrawn"><a class="card-anchor" href="srfi-142/"></a><span class="number">142</span><span class="name">Bitwise Operations</span><span class="authors">by John Cowan</span><span class="date-group">Withdrawn: <span class="date">2017/8/10</span></span><span class="status" data-status="withdrawn"></span><span class="see-also">See also <a href="/srfi-151/">SRFI 151: Bitwise Operations</a>.</span><div class="abstract">      <p>This SRFI proposes a coherent and comprehensive
      set of procedures for performing bitwise logical operations on integers;
      it is accompanied by a reference implementation of the spec in terms of a
      set of seven core operators. The sample implementation is portable, as
      efficient as practical with pure Scheme arithmetic (it is worthwhile
      replacing the core operators with C or assembly language if possible),
      and open source.
      <p>The precise semantics of these operators is
      almost never an issue. A consistent, portable set of <em>names</em> and
      <em>parameter conventions</em>, however, is. Hence this SRFI, which is
      based mainly on <a href="/srfi-33/">SRFI 33</a>, with some changes and
      additions from <a href=
      "http://srfi.schemers.org/srfi-33/mail-archive/msg00023.html">Olin's late
      revisions to SRFI 33</a> (which were never consummated). <a href=
      "/srfi-60/">SRFI 60</a> (based on SLIB) is smaller but has a few
      procedures of its own; some of its procedures have both native (often
      Common Lisp) and SRFI 33 names. They have been incorporated into this
      SRFI. <a href=
      "http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4">
      R6RS</a> is a subset of SRFI 60, except that all procedure names begin
      with a <tt>bitwise-</tt> prefix. A few procedures have been added from
      the general vector <a href="/srfi-133/">SRFI 133</a>.
      <p>Among the applications of bitwise operations
      are: hashing, Galois-field calculations of error-detecting and
      error-correcting codes, cryptography and ciphers, pseudo-random number
      generation, register-transfer-level modeling of digital logic designs,
      Fast-Fourier transforms, packing and unpacking numbers in persistent data
      structures, space-filling curves with applications to dimension reduction
      and sparse multi-dimensional database indexes, and generating approximate
      seed values for root-finders and transcendental function
      algorithms.</div></li></ul></div>
    <script crossorigin="anonymous"
	    integrity="sha384-JDmRxRiXkNkskRM5AD4qHRGk9ItwZ9flbqOpsRYs8SOrIRwcMtTGKP2Scnjptzgm"
	    src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"
	    type="application/javascript"></script>
    <script src="list.js" type="application/javascript"></script></body></html>