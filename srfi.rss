<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Scheme Requests for Implementation</title><link>https://srfi.schemers.org/</link><description>Updates to SRFI documents</description><language>en-US</language><webMaster>srfi@speechcode.com (Arthur A. Gleckler)</webMaster><atom:link href="https://srfi.schemers.org/rss" rel="self" type="application/rss+xml"></atom:link><item><title>SRFI 225: Dictionaries</title><link>https://srfi.schemers.org/srfi-225/srfi-225.html</link><guid>https://srfi.schemers.org/srfi-225</guid><description>SRFI 225 is now in <em>final</em> status.<blockquote><p>The procedures of this SRFI allow callers to manipulate an object that maps keys to values
  without the caller needing to know exactly what the type of the object is.
  Such an object is called a <em>dictionary</em> or <em>dict</em> in this SRFI.</p></blockquote></description><dc:creator>John Cowan (spec) and Arvydas Silanskas (implementation)</dc:creator><pubDate>Mon, 19 Sep 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 235: Combinators</title><link>https://srfi.schemers.org/srfi-235/srfi-235.html</link><guid>https://srfi.schemers.org/srfi-235</guid><description>SRFI 235 is now in <em>draft</em> status.<blockquote><p>This SRFI contains various procedures that accept and return procedures,
as well as a few others, drawn from
<a href="https://wiki.call-cc.org/eggref/4/combinators">an earlier version of Chicken</a>.
Common Lisp has a few of them too, and more come from
<a href="https://programmingpraxis.com/contents/standard-prelude/">the Standard Prelude from <em>Programming Praxis</em></a>.</p></blockquote></description><dc:creator>John Cowan (spec) and Arvydas Silanskas (implementation)</dc:creator><pubDate>Fri, 12 Aug 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 233: INI files</title><link>https://srfi.schemers.org/srfi-233/srfi-233.html</link><guid>https://srfi.schemers.org/srfi-233</guid><description>SRFI 233 is now in <em>draft</em> status.<blockquote><p>An INI file is a configuration file that consists of key-value
pairs for properties, and sections that group the properties. The
name of these configuration files comes from the filename extension
<code>INI</code>, short for initialization.
The format has become an informal standard in many contexts of configuration.
This SRFI provides access to the contents of an INI file.
</p></blockquote></description><dc:creator>John Cowan (spec) and Arvydas Silanskas (implementation)</dc:creator><pubDate>Wed, 10 Aug 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 234: Topological Sorting</title><link>https://srfi.schemers.org/srfi-234/srfi-234.html</link><guid>https://srfi.schemers.org/srfi-234</guid><description>SRFI 234 is now in <em>draft</em> status.<blockquote><p>
Topological sorting is an algorithm that takes a graph consisting of
nodes and other nodes that depend on them, forming a partial order,
and returns a list representing a total ordering of the graph.
If the graph is cyclic, the topological sort will fail, and an
error will be signaled.
</p></blockquote></description><dc:creator>John Cowan (spec) and Arvydas Silanskas (implementation)</dc:creator><pubDate>Wed, 10 Aug 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 200: Pattern Matching</title><link>https://srfi.schemers.org/srfi-200/srfi-200.html</link><guid>https://srfi.schemers.org/srfi-200</guid><description>SRFI 200 is now in <em>withdrawn</em> status.<blockquote><p>This SRFI discusses some of the existing pattern-matching
  libraries for the Scheme programming language &amp;mdash; namely,
  the pattern matcher presented by Andrew K. Wright and Robert
  Cartwright in the paper "A Soft Type System for Scheme", the
  pattern matcher developed by Dan Friedman, Erik Hilsdale and
  Kent Dybvig, the <code>racket/match</code> module
  distributed with the Racket programming environment, as well
  as the Bigloo and Gerbil pattern matchers distributed with
  their respective implementations.
  It then extracts a pattern syntax which is compatible with three of
  those implementations and provides extrinsic rationale for that
  syntax.
  It also provides a simple implementation of a pattern matcher
  which conforms to the specification of a pattern language provided
  in this document.</p></blockquote></description><dc:creator>Panicz Maciej Godek</dc:creator><pubDate>Sat, 23 Jul 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 211: Scheme Macro Libraries</title><link>https://srfi.schemers.org/srfi-211/srfi-211.html</link><guid>https://srfi.schemers.org/srfi-211</guid><description>SRFI 211 is now in <em>final</em> status.<blockquote><p>This SRFI describes common syntactic extensions of the <code>syntax-rules</code> macro facility of R5RS and the base R6RS and R7RS libraries.  In particular,
      library namespaces are defined where these extensions can be located
      and which can be tested against in <code>cond-expand</code> forms.
    </p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Tue, 19 Jul 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 232: Flexible curried procedures</title><link>https://srfi.schemers.org/srfi-232/srfi-232.html</link><guid>https://srfi.schemers.org/srfi-232</guid><description>SRFI 232 is now in <em>final</em> status.<blockquote><p>Scheme lacks a flexible way to create and apply curried procedures.
This SRFI describes <code>curried</code>, a variant of
<code>lambda</code> that creates true curried procedures which also
behave just like ordinary Scheme procedures.  They can be applied to
their arguments one by one, all at once, or anywhere in between,
without any novel syntax.  <code>curried</code> also supports
nullary and variadic procedures, and procedures created with it have
predictable behavior when applied to surplus arguments.</p></blockquote></description><dc:creator>Wolfgang Corcoran-Mathe</dc:creator><pubDate>Wed, 06 Apr 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 205: POSIX Terminal Fundamentals</title><link>https://srfi.schemers.org/srfi-205/srfi-205.html</link><guid>https://srfi.schemers.org/srfi-205</guid><description>SRFI 205 is now in <em>withdrawn</em> status.<blockquote><p>
This SRFI describes procedures for command-line and terminal interface
programs to safely change and reset terminal modes, for example from
cooked to raw and back, and for serial-line device manipulation for
interfacing with embedded hardware and the like.
</p>
<p>
It is intended to provide all the
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/termios.h.html">termios structure</a>
functionality a modern Scheme programmer might desire by supplying a
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/stty.html">stty</a>
procedure, and simple abstractions on top of it.
</p>
</blockquote></description><dc:creator>John Cowan and Harold Ancell</dc:creator><pubDate>Mon, 21 Mar 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 204: Wright-Cartwright-Shinn Pattern Matcher</title><link>https://srfi.schemers.org/srfi-204/srfi-204.html</link><guid>https://srfi.schemers.org/srfi-204</guid><description>SRFI 204 is now in <em>withdrawn</em> status.<blockquote><p>Pattern matching decomposes a compound data structure
into parts and assigns those parts to variables. This
SRFI describes a pattern-matching library already in use by
several scheme implementations which can match many common
compound data structures.</p></blockquote></description><dc:creator>Felix Thibault</dc:creator><pubDate>Wed, 02 Feb 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 231: Intervals and Generalized Arrays</title><link>https://srfi.schemers.org/srfi-231/srfi-231.html</link><guid>https://srfi.schemers.org/srfi-231</guid><description>SRFI 231 is now in <em>draft</em> status.<blockquote>    <p>This SRFI specifies an array mechanism for Scheme. Arrays as defined here are quite general; at their most basic, an array is simply a mapping, or function, from multi-indices of exact integers $i_0,\ldots,i_{d-1}$ to Scheme values.  The set of multi-indices $i_0,\ldots,i_{d-1}$ that are valid for a given array form the <i>domain</i> of the array.  In this SRFI, each array's domain consists  of the cross product of intervals of exact integers $[l_0,u_0)\times[l_1,u_1)\times\cdots\times[l_{d-1},u_{d-1})$ of $\mathbb Z^d$, $d$-tuples of integers.  Thus, we introduce a data type called $d$-<i>intervals</i>, or more briefly <a href="https://en.wikipedia.org/w/index.php?title=Interval_(mathematics)&amp;oldid=1091935326"><i>intervals</i></a>, that encapsulates this notion. (We borrow this terminology from, e.g.,  Elias Zakon's <a href="http://www.trillia.com/zakon1.html">Basic Concepts of Mathematics</a>.) Specialized variants of arrays provide portable programs with efficient representations for common use cases.</p>
    <p>This is a revised version of <a href="https://srfi.schemers.org/srfi-179/">SRFI 179</a>.</p></blockquote></description><dc:creator>Bradley J. Lucier</dc:creator><pubDate>Fri, 07 Jan 2022 12:00:00 -0800</pubDate></item><item><title>SRFI 227: Optional Arguments</title><link>https://srfi.schemers.org/srfi-227/srfi-227.html</link><guid>https://srfi.schemers.org/srfi-227</guid><description>SRFI 227 is now in <em>final</em> status.<blockquote>    <p>This SRFI specifies the <code>opt-lambda</code> syntax, which
      generalizes <code>lambda</code>.  An <code>opt-lambda</code> expression
      evaluates to a procedure that takes a number of required and a number of
      optional (positional) arguments whose default values are determined by
      evaluating corresponding expressions when the procedure is called.</p>

    <p>This SRFI also specifies a variation <code>opt*-lambda</code>, which is
      to <code>opt-lambda</code> as <code>let*</code> is to <code>let</code>
      and the related binding constructs <code>let-optionals</code>
      and <code>let-optionals*</code>.</p>

    <p>Finally, for those who prefer less explicit procedure
      definitions, a sublibrary provides <code>define-optionals</code>
      and <code>define-optionals*</code>.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen (spec and R6RS implementation) and Daphne Preston-Kendal (R7RS implementation)</dc:creator><pubDate>Tue, 16 Nov 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 229: Tagged Procedures</title><link>https://srfi.schemers.org/srfi-229/srfi-229.html</link><guid>https://srfi.schemers.org/srfi-229</guid><description>SRFI 229 is now in <em>final</em> status.<blockquote>    <p>This SRFI defines <dfn>tagged procedures</dfn>, which are procedures
      that are tagged with a Scheme value when created through the
      syntax <code>lambda/tag</code> and <code>case-lambda/tag</code>.  The
      value of the tag of a procedure can be retrieved
      with <code>procedure-tag</code>, and the
      predicate <code>procedure/tag?</code> discerns whether a procedure is
      tagged.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Mon, 15 Nov 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 230: Atomic Operations</title><link>https://srfi.schemers.org/srfi-230/srfi-230.html</link><guid>https://srfi.schemers.org/srfi-230</guid><description>SRFI 230 is now in <em>final</em> status.<blockquote>    <p>This SRFI defines atomic operations for the Scheme programming language.
      An <dfn>atomic operation</dfn> is an operation that, even in the presence
      of multiple threads, is either executed completely or not at all.  Atomic
      operations can be used to implement mutexes and other synchronization
      primitives, and they can be used to make concurrent algorithms lock-free.
      For this, this SRFI defines two data types, <dfn>atomic flags</dfn>
      and <dfn>atomic (fixnum) boxes</dfn>, whose contents can be queried and
      mutated atomically.  Moreover, each atomic operation comes with
      a <dfn>memory order</dfn> that defines the level of synchronization with
      other threads.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Mon, 15 Nov 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 228: A further comparator library</title><link>https://srfi.schemers.org/srfi-228/srfi-228.html</link><guid>https://srfi.schemers.org/srfi-228</guid><description>SRFI 228 is now in <em>draft</em> status.<blockquote><p>Further procedures and syntax forms for defining <a href="https://srfi.schemers.org/srfi-128/srfi-128.html">SRFI 128</a> comparators, and for extracting comparison procedures similar to those defined for Scheme’s built-in types using them.

</p><p>Best enjoyed in combination with <a href="https://srfi.schemers.org/srfi-162/srfi-162.html">SRFI 162</a>.</p></blockquote></description><dc:creator>Daphne Preston-Kendal</dc:creator><pubDate>Sat, 28 Aug 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 226: Control Features</title><link>https://srfi.schemers.org/srfi-226/srfi-226.html</link><guid>https://srfi.schemers.org/srfi-226</guid><description>SRFI 226 is now in <em>draft</em> status.<blockquote>    <p>Whenever an expression is evaluated during the run of a Scheme program,
    there is a continuation awaiting the values of the expression. It is a
    distinguishing property of the Scheme programming language to offer a
    procedure (named <code>call/cc</code>) that captures the current
    continuation as a procedure, which, when called, aborts the then current
    continuation and reinstates the captured one.</p>

    <p>One can visualize a continuation as a list of (continuation) frames
      where a non-tail call adds a frame to the top of the list and where the return
      from a non-tail call removes the appropriate frame.</p>

    <p>Moreover, each expression is evaluated in a dynamic environment that
      conceptually holds the values of parameters like the current output port
      and the dynamic-wind stack at the point of evaluation.  As the dynamic
      environment is captured and reinstated along the continuation when the
      <code>call/cc</code> machinery is used, we can view it conceptually as
      part of the continuation.</p>

    <p>The libraries defined in this SRFI are all concerned with continuations
      in a wider sense. More specifically, the topics are as follows:</p>

    <p><i>Continuation Prompts:</i> A continuation prompt is a special
    continuation frame, which is tagged with a so-called prompt tag. Procedures
    to install continuation prompts and to abort the current continuation and
    to escape back to a previously installed continuation prompt are
    provided. Moreover, continuation prompts are equipped with handlers that
    are invoked when a continuation is aborted to them.</p>

    <p><i>Continuations:</i> When continuations are captured, the list of
    captured continuation frames are always delimited by some continuation
    prompt. This extends the semantics of Scheme’s
    <code>call-with-current-continuation</code>.  Moreover, a
    procedure to capture so-called composable continuations is
    provided. As opposed to continuations captured
    by <code>call-with-current-continuation</code>, invoking a
    composable continuation does not abort the then current
    continuation, so composable continuations behave like ordinary
    procedures.  Together with continuation prompts, composable
    continuations allow one to implement the various proposed sets of
    control operators for delimited continuations. Finally, a
    primitive (<code>call-in-continuation</code>) is provided that
    allows calling a thunk in a given continuation instead of just
    delivering values to it.</p>

    <p><i>Continuation Marks:</i> Continuation marks are a provided feature
      that allows one to attach arbitrary information to continuation frames,
      which are captured and reinstated along the rest of the
      continuation. Conceptually, exception handlers and parameters are
      implemented in terms of continuation marks, but the syntax and procedures
      defined in this SRFI allow the user to use them in more general
      ways. Moreover, they reify the notion of a tail call, allowing, for
      example, to test for tail context.</p>

    <p><i>Exceptions:</i> The exception mechanism
    of <a href="https://doi.org/10.1017/S0956796809990074">R6RS</a>
    and <a href="https://small.r7rs.org/attachment/r7rs.pdf">R7RS</a> is reinterpreted with
    respect to the concepts introduced in this SRFI.  Moreover, the
    <code>with-exception-handler</code> procedure and the <code>guard</code>
    syntax gain additional tail context guarantees.</p>

    <p><i>Parameters:</i> The parameter object mechanism
    of <a href="https://srfi.schemers.org/srfi-39/srfi-39.html">SRFI 39</a>
    and R7RS is reinterpreted with respect to the
    concepts introduced in this SRFI.  Procedures to retrieve the
    current parameterization and to reinstall it later are
    provided. Moreover, the parameterize syntax gains an additional
    tail context guarantee.</p>

    <p><i>Delayed evaluation:</i> The syntax and procedures on delayed
      evaluation of R7RS are revisited and redefined to handle the
      following satisfactorily: the parameterization of the delayed expression
      being forced, the treatment of exceptions raised during forcing of
      delayed expressions, and iterative lazy algorithms. Moreover, their
      semantics are detailed with respect to the concepts introduced in this
      SRFI, and promises can naturally deliver an arbitrary number of values
      when being forced. Finally, the initial continuation of a delayed
      expression being forced is defined in a way that makes it interchangeably
      with the initial continuation of a thread.</p>

    <p><i>Threads:</i> The thread mechanism of <a href="https://srfi.schemers.org/srfi-18/srfi-18.html">SRFI
      18</a> is detailed with respect to the concepts introduced in this
      SRFI.  In particular, mutation of parameter objects in multithreaded
      applications is specified.<code></code>.</p>

    <p>Large parts of this SRFI have been inspired by the control operators
      provided by <a href="https://racket-lang.org/">Racket</a>.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Fri, 06 Aug 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 223: Generalized binary search procedures</title><link>https://srfi.schemers.org/srfi-223/srfi-223.html</link><guid>https://srfi.schemers.org/srfi-223</guid><description>SRFI 223 is now in <em>final</em> status.<blockquote><p>Generalized procedures for binary search of vector-like data structures are provided which can be applied to any sequence type, including ones defined by the user, together with applications of these procedures for Scheme’s built-in vectors.</p></blockquote></description><dc:creator>Daphne Preston-Kendal</dc:creator><pubDate>Tue, 27 Jul 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 222: Compound Objects</title><link>https://srfi.schemers.org/srfi-222/srfi-222.html</link><guid>https://srfi.schemers.org/srfi-222</guid><description>SRFI 222 is now in <em>final</em> status.<blockquote><p>Compound objects are analogous to R6RS compound conditions,
and are suitable for use in creating and handling conditions
on non-R6RS systems, among other purposes.
They encapsulate an immutable sequence of subobjects, which can be
any object except another compound object.
It is possible to implement R6RS compound conditions on top of
compound objects, but not vice versa.
Note that this SRFI does not provide any analogue to R6RS
<i>simple</i> conditions, which are just records.</p></blockquote></description><dc:creator>John Cowan (text) and Arvydas Silanskas (implementation)</dc:creator><pubDate>Tue, 20 Jul 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 224: Integer Mappings</title><link>https://srfi.schemers.org/srfi-224/srfi-224.html</link><guid>https://srfi.schemers.org/srfi-224</guid><description>SRFI 224 is now in <em>final</em> status.<blockquote><p>Integer maps, or <em>fxmappings</em>, are finite sets, where each element is
an association between a fixnum (exact integer) key and an arbitrary Scheme
object.  They are similar to the general mappings of
<a href="https://srfi.schemers.org/srfi-146/">SRFI
146</a>, but the restricted key-type allows implementations of
fxmappings to benefit from optimized structures and algorithms.  This
library provides a rich set of operations on fxmappings, including
analogues of most of the forms provided by SRFI 146.  Fxmappings have
no intrinsic order, but may be treated as ordered sets, using the
natural ordering on keys; a substantial sublibrary for working with
fxmappings in this fashion is included.</p></blockquote></description><dc:creator>Wolfgang Corcoran-Mathe</dc:creator><pubDate>Wed, 30 Jun 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 221: Generator/accumulator sub-library</title><link>https://srfi.schemers.org/srfi-221/srfi-221.html</link><guid>https://srfi.schemers.org/srfi-221</guid><description>SRFI 221 is now in <em>final</em> status.<blockquote><p>This is a set of convenience routines for generators and accumulators
intended to blend in with
<a href="https://srfi.schemers.org/srfi-158/srfi-158.html">SRFI 158</a>.
The authors recommend that they be added to the
<code>(srfi 158)</code> library provided by
users or implementations.
If they are approved by the R7RS-large process,
they can also be added to <code>(r7rs generator)</code>.</p></blockquote></description><dc:creator>John Cowan (text) and Arvydas Silanskas (implementation)</dc:creator><pubDate>Fri, 28 May 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 220: Line directives</title><link>https://srfi.schemers.org/srfi-220/srfi-220.html</link><guid>https://srfi.schemers.org/srfi-220</guid><description>SRFI 220 is now in <em>withdrawn</em> status.<blockquote>  <p>Many language-agnostic programming tools rely on specially
  formatted source code comments to annotate the code with
  metadata. Such "magic comments" are hard for both humans and
  computers to parse reliably, as the purpose of a comment is to be
  free-form text that is not interpreted by machine.</p>
  <p>This SRFI extends the standard Scheme directive syntax
  (<code>#!</code>) to support <em>line directives</em>. They look
  like magic comments to language-agnostic tools but read as
  S-expressions in Scheme, combining the portability of magic
  comments with the well-defined syntax and easy parsing of
  ordinary Scheme code.</p></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Tue, 20 Apr 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 219: Define higher-order lambda</title><link>https://srfi.schemers.org/srfi-219/srfi-219.html</link><guid>https://srfi.schemers.org/srfi-219</guid><description>SRFI 219 is now in <em>final</em> status.<blockquote><p>This SRFI codifies the following shorthand syntax, which some
  Scheme implementations have had for a long time.</p>
  <pre>(define ((outer-name outer-args ...) inner-args ...)
  inner-body ...)</pre></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Sun, 04 Apr 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 213: Identifier Properties</title><link>https://srfi.schemers.org/srfi-213/srfi-213.html</link><guid>https://srfi.schemers.org/srfi-213</guid><description>SRFI 213 is now in <em>final</em> status.<blockquote><p>Using the <code>define-property</code> definition described in
  this SRFI, expand-time properties can be associated with
  identifiers in a referentially transparent and lexically scoped way.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sun, 21 Mar 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 214: Flexvectors</title><link>https://srfi.schemers.org/srfi-214/srfi-214.html</link><guid>https://srfi.schemers.org/srfi-214</guid><description>SRFI 214 is now in <em>final</em> status.<blockquote><p>A <em>flexvector</em>, also known as a dynamic array or an arraylist, is a mutable vector-like data structure with an adjustable size. Flexvectors allow fast random access and fast insertion/removal at the end. This SRFI defines a suite of operations on flexvectors, modeled after <a href="https://srfi.schemers.org/srfi-133/srfi-133.html">SRFI 133</a>'s vector operations.</p></blockquote></description><dc:creator>Adam Nelson</dc:creator><pubDate>Thu, 18 Mar 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 208: NaN procedures</title><link>https://srfi.schemers.org/srfi-208/srfi-208.html</link><guid>https://srfi.schemers.org/srfi-208</guid><description>SRFI 208 is now in <em>final</em> status.<blockquote><p>This SRFI provides procedures that dissect NaN (Not a Number) inexact values.</p></blockquote></description><dc:creator>Emmanuel Medernach (design), John Cowan (editor), and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Tue, 23 Feb 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 217: Integer Sets</title><link>https://srfi.schemers.org/srfi-217/srfi-217.html</link><guid>https://srfi.schemers.org/srfi-217</guid><description>SRFI 217 is now in <em>final</em> status.<blockquote><p>Integer sets, or <em>iset</em>s, are unordered collections of
fixnums.  (Fixnums are exact integers within certain
implementation-specified bounds.)</p></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Mon, 15 Feb 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 210: Procedures and Syntax for Multiple Values</title><link>https://srfi.schemers.org/srfi-210/srfi-210.html</link><guid>https://srfi.schemers.org/srfi-210</guid><description>SRFI 210 is now in <em>final</em> status.<blockquote><p>
  This SRFI extends the Scheme standard with procedures and syntax
  dealing with multiple values, including syntax to create lists and
  vectors from expressions returning multiple values and procedures
  returning the elements of a list or vector as multiple values.
</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Fri, 12 Feb 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 212: Aliases</title><link>https://srfi.schemers.org/srfi-212/srfi-212.html</link><guid>https://srfi.schemers.org/srfi-212</guid><description>SRFI 212 is now in <em>final</em> status.<blockquote><p>This SRFI introduces <em>alias definitions</em>, a syntactic
extension.  An alias definition transfers the binding of one
identifier to another, effectively aliasing the identifier.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Fri, 12 Feb 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 218: Unicode Numerals</title><link>https://srfi.schemers.org/srfi-218/srfi-218.html</link><guid>https://srfi.schemers.org/srfi-218</guid><description>SRFI 218 is now in <em>withdrawn</em> status.<blockquote><p>These procedures allow the creation and interpretation of numerals
using any set of Unicode digits that support positional notation.</p></blockquote></description><dc:creator>John Cowan (text) and Arvydas Silanskas (implementation)</dc:creator><pubDate>Sat, 30 Jan 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 201: Syntactic Extensions to the Core Scheme Bindings</title><link>https://srfi.schemers.org/srfi-201/srfi-201.html</link><guid>https://srfi.schemers.org/srfi-201</guid><description>SRFI 201 is now in <em>final</em> status.<blockquote><p>This document describes a handful of syntactic extensions
  to the core bindings of the Scheme programming language.
  In particular, it proposes to extend the binding forms
  <code>lambda</code>, <code>let</code>,
  <code>let*</code> with pattern matching capabilities, to extend the forms <code>let</code>
  and <code>or</code> with the ability
  to handle multiple values, and to extend the form <code>define</code> with
  the ability of defining "curried" functions.</p></blockquote></description><dc:creator>Panicz Maciej Godek</dc:creator><pubDate>Wed, 13 Jan 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 215: Central Log Exchange</title><link>https://srfi.schemers.org/srfi-215/srfi-215.html</link><guid>https://srfi.schemers.org/srfi-215</guid><description>SRFI 215 is now in <em>final</em> status.<blockquote>    <p>
      This SRFI specifies a central log exchange for Scheme that
      connects log producers with log consumers. It allows multiple
      logging systems to interoperate and co-exist in the same
      program. Library code can produce log messages without knowledge
      of which log system is actually used. Simple applications can
      easily get logs on standard output, while more advanced
      applications can send them to a full logging system.
    </p></blockquote></description><dc:creator>Göran Weinholt</dc:creator><pubDate>Mon, 11 Jan 2021 12:00:00 -0800</pubDate></item><item><title>SRFI 206: Auxiliary Syntax Keywords</title><link>https://srfi.schemers.org/srfi-206/srfi-206.html</link><guid>https://srfi.schemers.org/srfi-206</guid><description>SRFI 206 is now in <em>final</em> status.<blockquote>This SRFI defines a mechanism for defining auxiliary syntax
keywords independently in different modules in such a way that
they still have the same binding so that they can be used
interchangeably as literal identifiers in
<code>syntax-rules</code> and <code>syntax-case</code> expressions
and can be both imported under the same name without conflicts.</blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Mon, 21 Dec 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 209: Enums and Enum Sets</title><link>https://srfi.schemers.org/srfi-209/srfi-209.html</link><guid>https://srfi.schemers.org/srfi-209</guid><description>SRFI 209 is now in <em>final</em> status.<blockquote><p>Enums are objects that serve to form sets of distinct classes
that specify different modes of operation for a procedure.
Their use fosters portable and readable code.</p></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Thu, 17 Dec 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 202: Pattern-matching Variant of the and-let* Form that Supports Multiple Values</title><link>https://srfi.schemers.org/srfi-202/srfi-202.html</link><guid>https://srfi.schemers.org/srfi-202</guid><description>SRFI 202 is now in <em>final</em> status.<blockquote><p>The SRFI-2 library introduced the <code>and-let*</code> form
  for short-circuited evaluation in the style of the <code>and</code>
  form, with the ability to capture the (non-<code>#f</code>) results
  in the style of the <code>let*</code> form.  This document extends
  the <code>and-let*</code> form with the ability to pattern-match (or
  "destructurally bind") the values of evaluated expressions (where
  the match failure causes short-circuiting rather than raising an
  error) and the ability to handle multiple values (where only the
  falsehood of the first value causes short-circuiting).
</p></blockquote></description><dc:creator>Panicz Maciej Godek</dc:creator><pubDate>Sat, 28 Nov 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 207: String-notated bytevectors</title><link>https://srfi.schemers.org/srfi-207/srfi-207.html</link><guid>https://srfi.schemers.org/srfi-207</guid><description>SRFI 207 is now in <em>final</em> status.<blockquote><p>To ease the human reading and writing of Scheme code involving
binary data that for mnemonic reasons corresponds
as a whole or in part to ASCII-coded text, a notation
for bytevectors is defined which allows printable ASCII characters
to be used literally without being converted to their corresponding
integer forms. In addition, this SRFI provides a set of procedures
known as the bytestring library
for constructing a bytevector from a sequence of integers,
characters, strings, and/or bytevectors, and for manipulating
bytevectors as if they were strings as far as possible.</p></blockquote></description><dc:creator>Daphne Preston-Kendal (external notation), John Cowan (procedure design), and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Thu, 29 Oct 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 170: POSIX API</title><link>https://srfi.schemers.org/srfi-170/srfi-170.html</link><guid>https://srfi.schemers.org/srfi-170</guid><description>SRFI 170 is now in <em>final</em> status.<blockquote><p>
The host environment is the set of resources, such as the filesystem,
network and processes, that are managed by the operating system on top of
which a Scheme program is executing. This SRFI specifies some of the ways the host
environment can be accessed from within a Scheme program.  It does so by
leveraging widespread support for P<small>OSIX</small>, the Portable
Operating System Interface standardized by the IEEE.  Not all of the
functions of this SRFI are available on all operating systems.
</p></blockquote></description><dc:creator>Olin Shivers (original author), John Cowan (editor and shepherd), and Harold Ancell (implementer and editor)</dc:creator><pubDate>Wed, 28 Oct 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 196: Range Objects</title><link>https://srfi.schemers.org/srfi-196/srfi-196.html</link><guid>https://srfi.schemers.org/srfi-196</guid><description>SRFI 196 is now in <em>final</em> status.<blockquote><p>Ranges are collections somewhat similar to vectors, except that
  they are immutable and have algorithmic representations instead of
  the uniform per-element data structure of vectors. The storage required is
  usually less than the size of the same collection stored in a
  vector and the time needed to reference a particular element is
  typically less for a range than for the same collection stored in a
  list. This SRFI defines a large subset of the sequence operations
  defined on lists, vectors, strings, and other collections.  If
  necessary, a range can be converted to a list, vector, or string of
  its elements or a generator that will lazily produce each element in
  the range.</p></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (sample implementation)</dc:creator><pubDate>Thu, 17 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 203: A Simple Picture Language in the Style of SICP</title><link>https://srfi.schemers.org/srfi-203/srfi-203.html</link><guid>https://srfi.schemers.org/srfi-203</guid><description>SRFI 203 is now in <em>final</em> status.<blockquote><p>This SRFI proposes a simple library for programmatic drawing of
pictures compatible with Section 2.2.4 of <cite>Structure and
Interpretation of Computer Programs</cite>.</p>

<p>It aims to close the gap between the Scheme suggested for study in
the book and portable Scheme.</p></blockquote></description><dc:creator>Vladimir Nikishkin</dc:creator><pubDate>Thu, 17 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 197: Pipeline Operators</title><link>https://srfi.schemers.org/srfi-197/srfi-197.html</link><guid>https://srfi.schemers.org/srfi-197</guid><description>SRFI 197 is now in <em>final</em> status.<blockquote><p>Many functional languages provide pipeline operators, like Clojure's <code>-></code> or OCaml's <code>|></code>. Pipelines are a simple, terse, and readable way to write deeply-nested expressions. This SRFI defines a family of <code>chain</code> and <code>nest</code> pipeline operators, which can rewrite nested expressions like <code>(a b (c d (e f g)))</code> as a sequence of operations: <code>(chain g (e f _) (c d _) (a b _))</code>.</p></blockquote></description><dc:creator>Adam Nelson</dc:creator><pubDate>Sat, 12 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 198: Foreign Interface Status</title><link>https://srfi.schemers.org/srfi-198/srfi-198.html</link><guid>https://srfi.schemers.org/srfi-198</guid><description>SRFI 198 is now in <em>withdrawn</em> status.<blockquote><p>
This SRFI provides means to construct, return or signal, and extract
information from Scheme interfaces with "foreign" systems such as the
P<small>OSIX</small> API, databases, and libraries.
</p></blockquote></description><dc:creator>John Cowan (editor and shepherd), Harold Ancell (implementer and editor), and Lassi Kortela (architect)</dc:creator><pubDate>Sat, 12 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 193: Command line</title><link>https://srfi.schemers.org/srfi-193/srfi-193.html</link><guid>https://srfi.schemers.org/srfi-193</guid><description>SRFI 193 is now in <em>final</em> status.<blockquote><p>R<sup>6</sup>RS and R<sup>7</sup>RS define a
<code>command-line</code> procedure. While a useful baseline, the
specification is not detailed enough to cover all practical
situations. This SRFI clarifies the definition of
<code>command-line</code> and adds a few related procedures.
Scheme scripts, standalone executables, compilation and REPL use
are accounted for. Option parsing is out of scope.</p></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Thu, 10 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 181: Custom ports (including transcoded ports)</title><link>https://srfi.schemers.org/srfi-181/srfi-181.html</link><guid>https://srfi.schemers.org/srfi-181</guid><description>SRFI 181 is now in <em>final</em> status.<blockquote><p>This SRFI is derived from parts of
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-1.html#node_toc_node_sec_8.2.4">
library section 8.2.4</a>,
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.7">
library section 8.2.7</a>,
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.10">
library section 8.2.10</a>, and
<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-9.html#node_sec_8.2.13">
library section 8.2.13</a>
of the R6RS.
These sections are themselves based on parts of
<a href="http://srfi.schemers.org/srfi-79/srfi-79.html">SRFI 79</a>,
<a href="http://srfi.schemers.org/srfi-80/srfi-80.html">SRFI 80</a> and
<a href="http://srfi.schemers.org/srfi-81/srfi-81.html">SRFI 81</a>.
These procedures provide a hook into the Scheme port system from below, allowing the
creation of custom ports that behave as much as possible like the standard
file, string, and bytevector ports, but that call a procedure to produce
data to input ports or to consume data from output ports.
Procedures for creating ports that transcode
between bytes and characters are an important special
case and are also documented in this SRFI.
</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Tue, 08 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 186: Transcoders and transcoded ports</title><link>https://srfi.schemers.org/srfi-186/srfi-186.html</link><guid>https://srfi.schemers.org/srfi-186</guid><description>SRFI 186 is now in <em>withdrawn</em> status.<blockquote><p>This is an extract from the R6RS that documents its support for
transcoders and transcoded ports.  These provide a hook into the
Scheme port system from below, allowing the creation of textual ports
that provide non-default encoding and decoding from arbitrary binary
ports.  It has been lightly edited to fit R7RS style.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Tue, 08 Sep 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 195: Multiple-value boxes</title><link>https://srfi.schemers.org/srfi-195/srfi-195.html</link><guid>https://srfi.schemers.org/srfi-195</guid><description>SRFI 195 is now in <em>final</em> status.<blockquote><p>
  This SRFI extends the specification of the boxes
  of <a href="https://srfi.schemers.org/srfi-111/srfi-111.html">SRFI
  111</a> so that they are multiple-values aware.  Whereas a SRFI
  111 box is limited in that it can only box a single value,
  multiple values can be boxed with this SRFI.
</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Fri, 28 Aug 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 194: Random data generators</title><link>https://srfi.schemers.org/srfi-194/srfi-194.html</link><guid>https://srfi.schemers.org/srfi-194</guid><description>SRFI 194 is now in <em>final</em> status.<blockquote><p>This SRFI defines a set of
<a href="https://srfi.schemers.org/srfi-158/srfi-158.html">SRFI 158</a>
generators and generator makers that yield random data of specific
ranges and distributions.  It is intended to be implemented on top of
<a href="https://srfi.schemers.org/srfi-27/srfi-27.html">SRFI 27</a>,
which provides the underlying source of random integers and floats.</p></blockquote></description><dc:creator>Shiro Kawai (design), Arvydas Silanskas (implementation), John Cowan (editor and shepherd), and Linas Vepštas (implementation)</dc:creator><pubDate>Wed, 26 Aug 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 178: Bitvector library</title><link>https://srfi.schemers.org/srfi-178/srfi-178.html</link><guid>https://srfi.schemers.org/srfi-178</guid><description>SRFI 178 is now in <em>final</em> status.<blockquote><p>This SRFI describes a set of operations on
homogeneous bitvectors.
Operations analogous to those provided on the other homogeneous
vector types described in
<a href="https://srfi.schemers.org/srfi-160/srfi-160.html">SRFI 160</a>
are provided,
along with operations analogous to the bitwise operations of
<a href="https://srfi.schemers.org/srfi-151/srfi-151.html">SRFI 151</a>.</p></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (implementation)</dc:creator><pubDate>Tue, 25 Aug 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 159: Combinator Formatting</title><link>https://srfi.schemers.org/srfi-159/srfi-159.html</link><guid>https://srfi.schemers.org/srfi-159</guid><description>SRFI 159 is now in <em>withdrawn</em> status.<blockquote><p>A library of procedures for formatting Scheme objects to text in
  various ways, and for easily concatenating, composing and extending
  these formatters efficiently without resorting to capturing and
  manipulating intermediate strings.</p></blockquote></description><dc:creator>Alex Shinn</dc:creator><pubDate>Fri, 31 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 177: Portable keyword arguments</title><link>https://srfi.schemers.org/srfi-177/srfi-177.html</link><guid>https://srfi.schemers.org/srfi-177</guid><description>SRFI 177 is now in <em>withdrawn</em> status.<blockquote><p>Many Scheme implementations have keyword arguments, but they
have not been widely standardized. This SRFI defines the macros
<code>lambda/kw</code> and <code>call/kw</code>. They can be used
identically in every major implementation currently in use,
making it safe to use keyword arguments in portable code. The
macros expand to native keyword arguments in Schemes that have
them, letting programmers mix portable code and
implementation-specific code.</p></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Fri, 31 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 192: Port Positioning</title><link>https://srfi.schemers.org/srfi-192/srfi-192.html</link><guid>https://srfi.schemers.org/srfi-192</guid><description>SRFI 192 is now in <em>final</em> status.<blockquote><p>This is an extract from the R6RS that documents its support for
positioning ports.  Binary ports can be positioned to read or write
at a specific byte; textual ports at a specific character,
although character positions can't be synthesized portably.
It has been lightly edited to fit R7RS style.</p></blockquote></description><dc:creator>John Cowan and Shiro Kawai (implementation; requires a hook)</dc:creator><pubDate>Fri, 31 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 166: Monadic Formatting</title><link>https://srfi.schemers.org/srfi-166/srfi-166.html</link><guid>https://srfi.schemers.org/srfi-166</guid><description>SRFI 166 is now in <em>final</em> status.<blockquote><p>
  A library of procedures for formatting Scheme objects to text in
  various ways, and for easily concatenating, composing and extending
  these formatters efficiently without resorting to capturing and
  manipulating intermediate strings.</p>

<p>
  This SRFI is an updated version of SRFI 159, primarily with the
  difference that state variables are hygienic.</p>

<p>
Summary of differences from SRFI 159:
<ul>
  <li>State variables are first class and hygienic</li>
  <li>Added <code>written-shared</code>, <code>pretty-shared</code></li>
  <li>Added <code>as-italic</code>, <code>as-color</code>, <code>as-true-color</code>, <code>on-<i>color</i></code> background variants, and <code>pretty-with-color</code></li>
  <li>Added <code>ambiguous-is-wide?</code> state variable and <code>string-terminal-width/wide</code> utility</li>
  <li>Added <code>substring/width</code> state var for width-aware substring operations, with <code>substring-terminal-width(/wide)</code> utilities</li>
  <li>Added <code>substring/preserve</code> state var used in trimming, with <code>substring-terminal-preserve</code> utility</li>
  <li>Added <code>pretty-environment</code> state variable</li>
  <li>Renamed <code>as-unicode</code> to <code>terminal-aware</code></li>
  <li>Restored non-uniform comma rules as needed in India</li>
  <li>Restored <code>upcased</code> and <code>downcased</code></li>
  <li>Several clarifications and more examples</li>
</ul></p></blockquote></description><dc:creator>Alex Shinn</dc:creator><pubDate>Thu, 30 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 199: POSIX errno manipulation</title><link>https://srfi.schemers.org/srfi-199/srfi-199.html</link><guid>https://srfi.schemers.org/srfi-199</guid><description>SRFI 199 is now in <em>withdrawn</em> status.<blockquote><p>The majority of P<small>OSIX</small> system and library calls
  require accessing <code>errno</code> to discern the specific cause
  of an error, and some require setting it to 0 before being called.
  This SRFI specifies procedures to both retrieve its value, and to
  set it.
</p></blockquote></description><dc:creator>Harold Ancell</dc:creator><pubDate>Sun, 19 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 189: Maybe and Either: optional container types</title><link>https://srfi.schemers.org/srfi-189/srfi-189.html</link><guid>https://srfi.schemers.org/srfi-189</guid><description>SRFI 189 is now in <em>final</em> status.<blockquote><p>This SRFI defines two disjoint immutable container types
known as Maybe and Either,
both of which can contain objects collectively known as their payload.
A Maybe object is either a Just object or the unique object Nothing
(which has no payload); an Either object is either
a Right object or a Left object.  Maybe represents the concept of
optional values; Either represents the concept of values which are
either correct (Right) or errors (Left).</p>
<p>Note that the terms Maybe, Just, Nothing, Either, Right, and Left
are capitalized in this SRFI so as not to be confused with their
ordinary use as English words.  Thus "returns Nothing" means
"returns the unique Nothing object"; "returns nothing" could be
interpreted as "returns no values"
or "returns an unspecified value".</p></blockquote></description><dc:creator>John Cowan (text) and Wolfgang Corcoran-Mathe (sample implementation)</dc:creator><pubDate>Tue, 14 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 191: Procedure Arity Inspection</title><link>https://srfi.schemers.org/srfi-191/srfi-191.html</link><guid>https://srfi.schemers.org/srfi-191</guid><description>SRFI 191 is now in <em>withdrawn</em> status.<blockquote><p>Many Scheme systems provide mechanisms for inspecting the arity of a
procedural value, making it a common feature, however there is no
standard interface.  As a result there is no portable way to observe
the arity of a procedure without actually applying it.  This
SRFI proposes a simple interface that is consistent with existing
Scheme systems' facilities and prior proposals.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 05 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 180: JSON</title><link>https://srfi.schemers.org/srfi-180/srfi-180.html</link><guid>https://srfi.schemers.org/srfi-180</guid><description>SRFI 180 is now in <em>final</em> status.<blockquote><p>This library describes a JavaScript Object Notation (JSON) parser and printer.  It supports JSON that may be bigger than memory.</p></blockquote></description><dc:creator>Amirouche Boubekki</dc:creator><pubDate>Wed, 01 Jul 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 179: Nonempty Intervals and Generalized Arrays (Updated)</title><link>https://srfi.schemers.org/srfi-179/srfi-179.html</link><guid>https://srfi.schemers.org/srfi-179</guid><description>SRFI 179 is now in <em>final</em> status.<blockquote><p>This SRFI specifies an array mechanism for Scheme. Arrays as defined here are quite general; at their most basic, an array is simply a mapping, or function, from multi-indices of exact integers $i_0,\ldots,i_{d-1}$ to Scheme values.  The set of multi-indices $i_0,\ldots,i_{d-1}$ that are valid for a given array form the <i>domain</i> of the array.  In this SRFI, each array's domain consists  of the cross product of nonempty intervals of exact integers $[l_0,u_0)\times[l_1,u_1)\times\cdots\times[l_{d-1},u_{d-1})$ of $\mathbb Z^d$, $d$-tuples of integers.  Thus, we introduce a data type called $d$-<i>intervals</i>, or more briefly <i>intervals</i>, that encapsulates this notion. (We borrow this terminology from, e.g.,  Elias Zakon's <a href="http://www.trillia.com/zakon1.html">Basic Concepts of Mathematics</a>.) Specialized variants of arrays are specified to provide portable programs with efficient representations for common use cases.</p></blockquote></description><dc:creator>Bradley J. Lucier</dc:creator><pubDate>Tue, 30 Jun 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 190: Coroutine Generators</title><link>https://srfi.schemers.org/srfi-190/srfi-190.html</link><guid>https://srfi.schemers.org/srfi-190</guid><description>SRFI 190 is now in <em>final</em> status.<blockquote><p>This SRFI defines syntax to create
  <a href="https://srfi.schemers.org/srfi-121/">SRFI
    121</a>/<a href="https://srfi.schemers.org/srfi-158/">158</a>
  coroutine generators conveniently and in the flavor of Python
  generator functions.
</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Thu, 11 Jun 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 188: Splicing binding constructs for syntactic keywords</title><link>https://srfi.schemers.org/srfi-188/srfi-188.html</link><guid>https://srfi.schemers.org/srfi-188</guid><description>SRFI 188 is now in <em>final</em> status.<blockquote><p>Splicing binding constructs for syntactic keywords are versions
  of <code>let-syntax</code> and <code>letrec-syntax</code> that can
  be used in a definition context in the same way
  as <code>begin</code>.
</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Wed, 03 Jun 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 185: Linear adjustable-length strings</title><link>https://srfi.schemers.org/srfi-185/srfi-185.html</link><guid>https://srfi.schemers.org/srfi-185</guid><description>SRFI 185 is now in <em>final</em> status.<blockquote><p>
Scheme specifies mutable fixed-length strings.
<a href="https://srfi.schemers.org/srfi-118/srfi-118.html">SRFI 118</a>
adds two procedures, <code>string-append!</code> and
<code>string-replace!</code>, which allow the length of the string to change.
This SRFI provides two linear-update versions of these procedures:
that is, the implementation may change the string length or return a
new string instead.
In addition, two convenience macros are provided that make the
procedures somewhat easier to use.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 26 Apr 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 182: ADBMAL, ALET, and ALET*</title><link>https://srfi.schemers.org/srfi-182/srfi-182.html</link><guid>https://srfi.schemers.org/srfi-182</guid><description>SRFI 182 is now in <em>withdrawn</em> status.<blockquote><p>Unlike the VALUES and CALL-WITH-VALUES mechanism of R5RS, this one
uses an explicit representation for multiple return values as a single
value, namely a procedure.  Decomposition of multiple values is done
by simple application.  The macro, ADBMAL, evaluates to a procedure
that takes one procedure argument.  The ADBMAL macro can be compared
with LAMBDA.  While a LAMBDA expression that consists of
&lt;formals> and &lt;body> requires some actual arguments later
when the evaluated LAMBDA expression is called, an ADBMAL expression
that consists of &lt;expression>s corresponding to actual arguments
of LAMBDA requires &lt;formals> and &lt;body>, that is, an
evaluated LAMBDA expression, later when the evaluated ADBMAL
expression is called.</p>

<p>This SRFI also introduces the new LET-syntax ALET and ALET*, which
depend on ADBMAL to manipulate multiple values, and which are
compatible with LET and LET* of R5RS in single-value bindings.  They
also have a binding form making use of VALUES and CALL-WITH-VALUES to
handle multiple values, and new binding forms for list, cons, and
other multiple values.  In addition, they have several new binding
forms for useful functions such as escape, iteration, optional
arguments, etc.</p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Fri, 27 Mar 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 183: Another format procedure, Fox</title><link>https://srfi.schemers.org/srfi-183/srfi-183.html</link><guid>https://srfi.schemers.org/srfi-183</guid><description>SRFI 183 is now in <em>withdrawn</em> status.<blockquote><p>This SRFI introduces the formatting procedure Fox ("format of X"),
  which takes one required argument and a variable number of additional
  arguments and returns a formatted string.</p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Fri, 27 Mar 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 184: define-record-lambda</title><link>https://srfi.schemers.org/srfi-184/srfi-184.html</link><guid>https://srfi.schemers.org/srfi-184</guid><description>SRFI 184 is now in <em>withdrawn</em> status.<blockquote><p>This SRFI introduces a macro, DEFINE-RECORD-LAMBDA, that defines a
  set of procedures, that is, a group of constructors and a predicate.
  The constructors also make a group of procedures, namely record
  lambdas, that have no explicit field accessors and mutators.  They
  can have various kinds of fields, such as common fields, required
  fields, optional fields, automatic fields, read-only fields,
  read-write fields, invisible fields, immutable fields, and virtual
  fields.</p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Fri, 27 Mar 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 187: ALAMBDA and ADEFINE</title><link>https://srfi.schemers.org/srfi-187/srfi-187.html</link><guid>https://srfi.schemers.org/srfi-187</guid><description>SRFI 187 is now in <em>withdrawn</em> status.<blockquote><p>This SRFI introduces alambda, which creates a procedure that checks
its actual arguments, takes various types of required and optional
variables.<br> This SRFI is based on
<a href="https://srfi.schemers.org/srfi-92/">SRFI 92</a>
as an extension of the optional arguments of
<a href="https://srfi.schemers.org/srfi-182/">SRFI 182</a>.</p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Fri, 27 Mar 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 176: Version flag</title><link>https://srfi.schemers.org/srfi-176/srfi-176.html</link><guid>https://srfi.schemers.org/srfi-176</guid><description>SRFI 176 is now in <em>final</em> status.<blockquote><p>This SRFI defines a standard command-line flag to get version
  information from a Scheme implementation.  The output is
  Line-oriented S-expressions which are easy to parse from Scheme, C,
  and shell scripts and can co-exist with non-S-expression output.  A
  standard vocabulary is defined; extensions are easy to make.</p></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Mon, 24 Feb 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 216: SICP Prerequisites (Portable)</title><link>https://srfi.schemers.org/srfi-216/srfi-216.html</link><guid>https://srfi.schemers.org/srfi-216</guid><description>SRFI 216 is now in <em>final</em> status.<blockquote><p>
   This SRFI follows
    <a href="https://srfi.schemers.org/srfi-203/">
     SRFI 203
    </a>
   in providing "out-of-the-box" support for hosting the exercises suggested by
    <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">
     Structure and Interpretation of Computer Programs
    </a>
   in portable Scheme.
</p>

<p>
Whereas SRFI 203 focused on the necessarily non-portable aspects of the problem set (the graphics), this SRFI aims to provide support for the rest of the features, which are far more widespread, often already provided, and in reality mostly need just a common vocabulary.
</p>

<p>
This SRFI provides procedures for working with time data, multi-threading, and streams, as well as SICP names for <code>true</code> and <code>false</code>.
</p>

<p>
None of these procedures is fit for production use.  They are only designed for pedagogical purposes.
</p>

<p>
Students, however, are expected to be able to just write</p>
 <pre>
 (include (srfi sicp))</pre>
 <p>and have the code from the book run without problems (apart from those intended by the book authors).
</p></blockquote></description><dc:creator>Vladimir Nikishkin</dc:creator><pubDate>Tue, 21 Jan 2020 12:00:00 -0800</pubDate></item><item><title>SRFI 174: POSIX Timespecs</title><link>https://srfi.schemers.org/srfi-174/srfi-174.html</link><guid>https://srfi.schemers.org/srfi-174</guid><description>SRFI 174 is now in <em>final</em> status.<blockquote><p>This SRFI defines the trivial type <i>timespec</i>, which is used
to represent the <code>struct timespec</code> defined by the
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html">
P<small>OSIX</small> <code>&lt;time.h></code> header</a>.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sat, 21 Dec 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 175: ASCII character library</title><link>https://srfi.schemers.org/srfi-175/srfi-175.html</link><guid>https://srfi.schemers.org/srfi-175</guid><description>SRFI 175 is now in <em>final</em> status.<blockquote>  <p>This SRFI defines ASCII-only equivalents to many of the
  character procedures in standard Scheme plus a few extra ones.
  Recent Scheme standards are based around Unicode but the
  significant syntactic elements in many file formats and network
  protocols are all ASCII. Such low-level code can run faster and
  its behavior can be easier to understand when it uses ASCII
  primitives.</p></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Fri, 20 Dec 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 172: Two Safer Subsets of R7RS</title><link>https://srfi.schemers.org/srfi-172/srfi-172.html</link><guid>https://srfi.schemers.org/srfi-172</guid><description>SRFI 172 is now in <em>final</em> status.<blockquote><p>This SRFI provides two libraries for use with R7RS that provide a
way to sandbox the <code>eval</code> procedure to make it safer to use
in evaluating Scheme expressions of doubtful provenance.  The intention
is to call <code>eval</code>, passing it an S-expression representing a
Scheme procedure and the environment defined by one of these libraries.
Since code evaluated by <code>eval</code> runs in a null lexical
environment, the resulting procedure can then be invoked with less
concern about possible side effects.
</p>

<p><b>Use of these libraries does not provide any sort of safety
guarantee.  There are still many loopholes uncaught, including
attempts to process circular structure and over-allocation of memory.
The claim is only that the probability of such an attack is reduced,
not that it is eliminated.
However, using these libraries is a simple provision that is easy to
implement and easy to use.  For higher safety, it can readily be
combined with other provisions.
</b></p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 10 Nov 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 167: Ordered Key Value Store</title><link>https://srfi.schemers.org/srfi-167/srfi-167.html</link><guid>https://srfi.schemers.org/srfi-167</guid><description>SRFI 167 is now in <em>final</em> status.<blockquote><p>This library describes an interface for an ordered key-value store
  that is suitable for implementing a storage engine for the generic
  tuple-store SRFI.  It maps cleanly to existing ordered key-value
  databases that may or may not provide transactions.</p></blockquote></description><dc:creator>Amirouche Boubekki</dc:creator><pubDate>Fri, 08 Nov 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 168: Generic Tuple Store Database</title><link>https://srfi.schemers.org/srfi-168/srfi-168.html</link><guid>https://srfi.schemers.org/srfi-168</guid><description>SRFI 168 is now in <em>final</em> status.<blockquote><p>This library is a generic approach to the database abstractions
  known as triplestore and quadstore.  Generic Tuple Store Database
  implements n-tuple ordered sets and associated primitives for
  working with them in the context of data management.</p></blockquote></description><dc:creator>Amirouche Boubekki</dc:creator><pubDate>Fri, 08 Nov 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 171: Transducers</title><link>https://srfi.schemers.org/srfi-171/srfi-171.html</link><guid>https://srfi.schemers.org/srfi-171</guid><description>SRFI 171 is now in <em>final</em> status.<blockquote><p>A library implementing transducers &amp;mdash; composable algorithmic
  transformations.  Scheme has many different ways of expressing
  transformations over different collection types, but they are all
  unique to whatever base type they work on.  This SRFI proposes a new
  construct, the transducer, that is oblivious to the context in which
  it is being used.</p></blockquote></description><dc:creator>Linus Björnstam</dc:creator><pubDate>Sat, 26 Oct 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 173: Hooks</title><link>https://srfi.schemers.org/srfi-173/srfi-173.html</link><guid>https://srfi.schemers.org/srfi-173</guid><description>SRFI 173 is now in <em>final</em> status.<blockquote><p>This library describes a mechanism known as hooks.  Hooks are a
  certain kind of extension point in a program that allows
  interleaving the execution of arbitrary code with the execution of
  the program without introducing any coupling between the two.</p></blockquote></description><dc:creator>Amirouche Boubekki</dc:creator><pubDate>Thu, 24 Oct 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 165: The Environment Monad</title><link>https://srfi.schemers.org/srfi-165/srfi-165.html</link><guid>https://srfi.schemers.org/srfi-165</guid><description>SRFI 165 is now in <em>final</em> status.<blockquote>Monads model computations.  The environment monad models
computations that depend on values from a shared environment.
These computations can read values from the environment, pass
values to subsequent computations, execute sub-computations in an
extended environment, and modify the environment for future
computations.</blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Thu, 05 Sep 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 160: Homogeneous numeric vector libraries</title><link>https://srfi.schemers.org/srfi-160/srfi-160.html</link><guid>https://srfi.schemers.org/srfi-160</guid><description>SRFI 160 is now in <em>final</em> status.<blockquote><p>This SRFI describes a set of operations on SRFI 4 homogeneous vector
types (plus a few additional types) that are closely analogous
to the vector operations library,
<a href="http://srfi.schemers.org/srfi-133/srfi-133.html">
SRFI 133</a>.
An external representation is specified which may be supported by the
<code>read</code> and <code>write</code> procedures and by the program
parser so that programs can contain references to literal homogeneous
vectors.</p></blockquote></description><dc:creator>John Cowan and Shiro Kawai (contributed a major patch)</dc:creator><pubDate>Tue, 27 Aug 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 162: Comparators sublibrary</title><link>https://srfi.schemers.org/srfi-162/srfi-162.html</link><guid>https://srfi.schemers.org/srfi-162</guid><description>SRFI 162 is now in <em>final</em> status.<blockquote><p>
This SRFI provides a few extra procedures and comparators to go
with SRFI 128, Comparators.  Implementers are urged to add them to
their SRFI 128 libraries, for which reason they are not packaged
as a separate library.
</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Tue, 27 Aug 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 164: Enhanced multi-dimensional Arrays</title><link>https://srfi.schemers.org/srfi-164/srfi-164.html</link><guid>https://srfi.schemers.org/srfi-164</guid><description>SRFI 164 is now in <em>final</em> status.<blockquote><p>This SRFI describes the array data type (a generalization of
  vectors to multiple indexes or dimensions), along with a set of
  procedures for working on them.</p>
<p>This specification is an extension of <a href="http://srfi.schemers.org/srfi-25/srfi-25.html">SRFI 25</a>,
  with additions from Racket’s
  <a href="https://docs.racket-lang.org/math/array.html">math.array</a> package
  and other sources.  It has been implemented in the <a href="https://www.gnu.org/software/kawa/Arrays.html">Kawa dialect of Scheme</a>.</p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Thu, 08 Aug 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 169: Underscores in numbers</title><link>https://srfi.schemers.org/srfi-169/srfi-169.html</link><guid>https://srfi.schemers.org/srfi-169</guid><description>SRFI 169 is now in <em>final</em> status.<blockquote><p>Many people find that large numbers are easier to read when the
  digits are broken into small groups.  For example, the number
  <code>1582439</code> might be easier to read if written as <code>1
  582 439</code>.  This applies to source code as it does to other
  writing.  We propose an extension of Scheme syntax to allow the
  underscore as a digit separator in numerical constants.</p></blockquote></description><dc:creator>Lassi Kortela</dc:creator><pubDate>Fri, 26 Jul 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 121: Generators</title><link>https://srfi.schemers.org/srfi-121/srfi-121.html</link><guid>https://srfi.schemers.org/srfi-121</guid><description>SRFI 121 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI defines utility procedures that
      create, transform, and consume generators. A generator is simply a
      procedure with no arguments that works as a source of a series of values.
      Every time it is called, it yields a value. Generators may be finite or
      infinite; a finite generator returns an end-of-file object to indicate
      that it is exhausted. For example, <code>read-char</code>,
      <code>read-line</code>, and <code>read</code> are generators that
      generate characters, lines, and objects from the current input port.
      Generators provide lightweight laziness.</p></blockquote></description><dc:creator>Shiro Kawai, John Cowan, and Thomas Gilray</dc:creator><pubDate>Thu, 18 Jul 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 161: Unifiable Boxes</title><link>https://srfi.schemers.org/srfi-161/srfi-161.html</link><guid>https://srfi.schemers.org/srfi-161</guid><description>SRFI 161 is now in <em>final</em> status.<blockquote><p>
  Unifiable boxes are, like the boxes
  of <a href="https://srfi.schemers.org/srfi-111/srfi-111.html">SRFI
    111</a>, objects with a single mutable state.  A constructor,
  predicate, accessor, and mutator are provided.
</p>

<p>
In addition to this, an equality predicate and union operations (link,
union, unify) are provided.  Applying a union operation to two
unifiable boxes makes the two boxes equal (in the sense of the
equality predicate).  As a consequence, their state will also become
identical.  In the case of link and union, it will be the state of one
of the two unioned boxes.  In the case of unify, the state is
determined by a supplied unification procedure.
</p>

<p>
  Unifiable boxes are
  also known under the names <i>disjoint-set data
    structure</i>, <i>union–find data structure</i> or <i>merge–find
    set</i>.
</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Fri, 08 Feb 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 163: Enhanced array literals</title><link>https://srfi.schemers.org/srfi-163/srfi-163.html</link><guid>https://srfi.schemers.org/srfi-163</guid><description>SRFI 163 is now in <em>final</em> status.<blockquote><p>This is a specification of a reader form (literals)
for multi-dimensional arrays.
It is an extension of the Common Lisp array reader syntax to handle
non-zero lower bounds, optional explicit bounds,
and optional uniform element types (compatible with <a href="https://srfi.schemers.org/srfi-4">SRFI 4</a>).
It can be used in conjunction with <a href="https://srfi.schemers.org/srfi-25">SRFI 25</a>, <a href="https://srfi.schemers.org/srfi-122">SRFI 122</a>,
or  <a href="https://srfi.schemers.org/srfi-164">SRFI 164</a>.
These extensions were implemented in Guile (except the handling of rank-0 arrays),
and later in Kawa.
</p><p>There are recommendations for output formatting
and a suggested <code>format-array</code> procedure.</p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Fri, 18 Jan 2019 12:00:00 -0800</pubDate></item><item><title>SRFI 154: First-class dynamic extents</title><link>https://srfi.schemers.org/srfi-154/srfi-154.html</link><guid>https://srfi.schemers.org/srfi-154</guid><description>SRFI 154 is now in <em>final</em> status.<blockquote><p>Scheme has the notion of the <em>dynamic extent</em> of a
  procedure call.  A number of standard Scheme procedures and
  syntaxes
  like <code>dynamic-wind</code>, <code>call-with-current-continuation</code>,
  and <code>parameterize</code>
  deal with the dynamic extent indirectly.  The same holds true
  for the procedures and syntaxes dealing with continuation
  marks as defined by <a href="https://srfi.schemers.org/srfi-157/srfi-157.html">SRFI
  157</a>.</p>

<p>This SRFI reifies the dynamic extent into a first-class value
  together with a well-defined procedural interface and a syntax to
  create procedures that remember not only their environment at
  creation time but also their dynamic extent, which includes their
  dynamic environment.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sat, 15 Sep 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 155: Promises</title><link>https://srfi.schemers.org/srfi-155/srfi-155.html</link><guid>https://srfi.schemers.org/srfi-155</guid><description>SRFI 155 is now in <em>final</em> status.<blockquote>	<p>
	  Scheme, like ML, is a programming language with strict evaluation
	  while others, like Haskell, use lazy evaluation.  Scheme, however,
	  possesses the primitives <code>delay</code> and <code>force</code>
	  that make it possible to express lazy algorithms.

	</p><p>
	  Lazy evaluation does not go well in conjunction with imperative,
	  non-functional, side-effecting code.  It should, however, be
	  applicable in a purely functional setting.  This is the case for the
	  delayed evaluation model as described in the R7RS as long as no
	  dynamically bound variables, also known as parameter objects, are
	  present.  It is the purpose of this SRFI to rework the specification
	  in the R7RS so that lazy evaluation works with purely functional code
	  that makes use of dynamic environments or, more generally, the dynamic
	  extent.  This is done by remembering the dynamic extent in effect when
	  the <code>delay</code> expression is evaluated.

	</p><p>
	  Another perceived misfeature of the R7RS model of delayed evaluation
	  is the apparent need of the <code>delay-force</code> special form to
	  express iterative lazy algorithms.  It is shown that
	  the <code>delay-force</code> special form is unneeded and that the
	  implementation can (and should) handle iterative lazy algorithms
	  without space leaks.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sat, 15 Sep 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 153: Ordered Sets</title><link>https://srfi.schemers.org/srfi-153/srfi-153.html</link><guid>https://srfi.schemers.org/srfi-153</guid><description>SRFI 153 is now in <em>withdrawn</em> status.<blockquote><p><em>Osets</em> are immutable collections that can contain any Scheme
  object. Osets enforce the constraint that no two elements can be the same
  in the sense of the oset's associated <em>equality predicate</em>
  The elements in an oset appear in a fixed order determined by the
  comparator used to create it.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 08 Jul 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 146: Mappings</title><link>https://srfi.schemers.org/srfi-146/srfi-146.html</link><guid>https://srfi.schemers.org/srfi-146</guid><description>SRFI 146 is now in <em>final</em> status.<blockquote>      <p><em>Mappings</em> are finite sets of
      associations, where each association is a pair consisting of a key and an
      arbitrary Scheme value. The keys are elements of a suitable domain. Each
      mapping holds no more than one association with the same key. The
      fundamental mapping operation is retrieving the value of an association
      stored in the mapping when the key is given.</p></blockquote></description><dc:creator>Arthur A. Gleckler and Marc Nieper-Wißkirchen</dc:creator><pubDate>Thu, 24 May 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 157: Continuation marks</title><link>https://srfi.schemers.org/srfi-157/srfi-157.html</link><guid>https://srfi.schemers.org/srfi-157</guid><description>SRFI 157 is now in <em>final</em> status.<blockquote><p>
  Continuation marks are a programming language feature that allows
  one to attach information to and retrieve information from
  continuations, generalizing stack inspection.  Conceptually, a
  continuation consists of a number of frames where each frame stands
  for an active procedure call that is not a tail call.  A
  continuation mark is then a key-value pair associated with a frame,
  with keys compared using <code>eq?</code>.
  At most one mark for a given key can be attached to a single frame.
</p>

<p>
  Besides stack inspection, continuation marks can be used to
  implement dynamic scope, delimited continuations, or delayed
  evaluation that is able to handle iterative lazy algorithms.
</p>
<p>
  This SRFI proposes to add continuation marks to the Scheme
  programming language.  The interface defined here is modelled after
  Racket's continuation marks.  It does not include all forms and
  procedures provided by Racket but provides a compatible subset.
</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Mon, 29 Jan 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 150: Hygienic ERR5RS Record Syntax (reduced)</title><link>https://srfi.schemers.org/srfi-150/srfi-150.html</link><guid>https://srfi.schemers.org/srfi-150</guid><description>SRFI 150 is now in <em>final</em> status.<blockquote>	<p>
	  This SRFI provides a specification and portable implementation of an
	  extension of the ERR5RS record syntax
	  of <a href="https://srfi.schemers.org/srfi-131/srfi-131.html">SRFI
	  131</a>, where field names inserted by macro transformers are
	  effectively renamed as if the macro transformer inserted a binding.
	  This makes this SRFI compatible with the semantics of the record-type
	  definitions of
	  the <a href="https://bitbucket.org/cowan/r7rs/src/draft-10/rnrs/r7rs.pdf">R7RS</a>
	  as intended by
	  its <a href="https://groups.google.com/d/msg/scheme-reports-wg2/oKuhgwaM45w/KXgPrh8oAwAJ">authors</a>.
	  In addition, field names may also be other types of Scheme datums,
	  like numbers and strings, or
	  <a href="https://srfi.schemers.org/srfi-88/srfi-88.html">SRFI 88</a> keyword objects.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Tue, 16 Jan 2018 12:00:00 -0800</pubDate></item><item><title>SRFI 156: Syntactic combiners for binary predicates</title><link>https://srfi.schemers.org/srfi-156/srfi-156.html</link><guid>https://srfi.schemers.org/srfi-156</guid><description>SRFI 156 is now in <em>final</em> status.<blockquote><p>Recognizing binary predicates as a specific area
  in which the use of prefix operators is an impediment,
  we propose a thin layer of "syntactic stevia" for in-fixing
  such predicates. It can be implemented using regular Scheme
  macros. We suggest that the code <code>(is x &lt; y)</code> should
  be transformed to <code>(&lt; x y)</code>, and <code>(is x &lt; y &lt;= z)</code>
  -- to <code>(let ((y* y)) (and (&lt; x y*) (&lt;= y* z)))</code>.
  In addition, we suggest special meaning to the <code>_</code> symbol:
  <code>(is _ &lt; y)</code> and <code>(is x &lt; _)</code>
  should be transformed to <code>(lambda (_) (&lt; _ y))</code>
  and <code>(lambda (_) (&lt; x _))</code>, respectively.
  This SRFI document also describes some other uses of the
  <code>is</code> macro and its limitations.</p></blockquote></description><dc:creator>Panicz Maciej Godek</dc:creator><pubDate>Mon, 18 Dec 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 158: Generators and Accumulators</title><link>https://srfi.schemers.org/srfi-158/srfi-158.html</link><guid>https://srfi.schemers.org/srfi-158</guid><description>SRFI 158 is now in <em>final</em> status.<blockquote><p>This SRFI defines utility procedures that create, transform, and consume generators.
  A generator is simply a procedure with no arguments that works
  as a source of values.  Every time it is called,
  it yields a value.  Generators may be finite or infinite; a finite
  generator returns an end-of-file object to indicate that it is exhausted.
  For example, <code>read-char</code>, <code>read-line</code>,
  and <code>read</code> are generators that
  generate characters, lines, and objects from the current input port.
  Generators provide lightweight laziness.
</p>

<p>This SRFI also defines procedures that return accumulators.
  An accumulator is the inverse of a generator:  it is a procedure of one argument
  that works as a sink of values.
</p></blockquote></description><dc:creator>Shiro Kawai, John Cowan, and Thomas Gilray</dc:creator><pubDate>Fri, 27 Oct 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 152: String Library (reduced)</title><link>https://srfi.schemers.org/srfi-152/srfi-152.html</link><guid>https://srfi.schemers.org/srfi-152</guid><description>SRFI 152 is now in <em>final</em> status.<blockquote>      <p>Scheme has an impoverished set of
      string-processing utilities, which is a problem for authors of portable
      code. This SRFI proposes a coherent and comprehensive set of
      string-processing procedures. It is a reduced version of SRFI 13 that has
      been aligned with SRFI 135, Immutable Texts. Unlike SRFI 13, it has been
      made consistent with the R5RS, R6RS, and R7RS-small string
      procedures.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Wed, 04 Oct 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 40: A Library of Streams</title><link>https://srfi.schemers.org/srfi-40/srfi-40.html</link><guid>https://srfi.schemers.org/srfi-40</guid><description>SRFI 40 is now in <em>withdrawn</em> status.<blockquote>      <p>Along with higher-order functions, one of the
      hallmarks of functional programming is lazy evaluation. A primary
      manifestation of lazy evaluation is lazy lists, generally called streams
      by Scheme programmers, where evaluation of a list element is delayed
      until its value is needed.
      </p><p>The literature on lazy evaluation distinguishes
      two styles of laziness, called even and odd. Odd style streams are
      ubiquitous among Scheme programs and can be easily encoded with the
      Scheme primitives delay and force defined in R5RS. However, the even
      style delays evaluation in a manner closer to that of traditional lazy
      languages such as Haskell and avoids an "off by one" error that is
      symptomatic of the odd style.
      </p><p>This SRFI defines the stream data type in the
      even style, some essential procedures and syntax that operate on streams,
      and motivates our choice of the even style. A companion SRFI 41 Stream
      Library provides additional procedures and syntax which make for more
      convenient processing of streams and shows several examples of their
      use.</p></blockquote></description><dc:creator>Philip L. Bewig</dc:creator><pubDate>Thu, 10 Aug 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 114: Comparators</title><link>https://srfi.schemers.org/srfi-114/srfi-114.html</link><guid>https://srfi.schemers.org/srfi-114</guid><description>SRFI 114 is now in <em>withdrawn</em> status.<blockquote>      <p>This proposal is a rewrite of <a href="https://srfi.schemers.org/srfi-67/">SRFI 67</a>, Compare Procedures, extending it from procedures
      that represent a total order to procedure bundles that represent one or
      more of a total order, an equality predicate, and a hash function. By
      packaging these procedures together, along with a type test predicate,
      they can be treated as a single item for use in the implementation of
      data structures.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Thu, 10 Aug 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 142: Bitwise Operations</title><link>https://srfi.schemers.org/srfi-142/srfi-142.html</link><guid>https://srfi.schemers.org/srfi-142</guid><description>SRFI 142 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI proposes a coherent and comprehensive
      set of procedures for performing bitwise logical operations on integers;
      it is accompanied by a reference implementation of the spec in terms of a
      set of seven core operators. The sample implementation is portable, as
      efficient as practical with pure Scheme arithmetic (it is worthwhile
      replacing the core operators with C or assembly language if possible),
      and open source.
      </p><p>The precise semantics of these operators is
      almost never an issue. A consistent, portable set of <em>names</em> and
      <em>parameter conventions</em>, however, is. Hence this SRFI, which is
      based mainly on <a href="https://srfi.schemers.org/srfi-33/">SRFI 33</a>, with some changes and
      additions from <a href="http://srfi.schemers.org/srfi-33/mail-archive/msg00023.html">Olin's late
      revisions to SRFI 33</a> (which were never consummated). <a href="https://srfi.schemers.org/srfi-60/">SRFI 60</a> (based on SLIB) is smaller but has a few
      procedures of its own; some of its procedures have both native (often
      Common Lisp) and SRFI 33 names. They have been incorporated into this
      SRFI. <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4">
      R6RS</a> is a subset of SRFI 60, except that all procedure names begin
      with a <code>bitwise-</code> prefix. A few procedures have been added from
      the general vector <a href="https://srfi.schemers.org/srfi-133/">SRFI 133</a>.
      </p><p>Among the applications of bitwise operations
      are: hashing, Galois-field calculations of error-detecting and
      error-correcting codes, cryptography and ciphers, pseudo-random number
      generation, register-transfer-level modeling of digital logic designs,
      Fast-Fourier transforms, packing and unpacking numbers in persistent data
      structures, space-filling curves with applications to dimension reduction
      and sparse multi-dimensional database indexes, and generating approximate
      seed values for root-finders and transcendental function
      algorithms.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Thu, 10 Aug 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 148: Eager syntax-rules</title><link>https://srfi.schemers.org/srfi-148/srfi-148.html</link><guid>https://srfi.schemers.org/srfi-148</guid><description>SRFI 148 is now in <em>final</em> status.<blockquote>      <p>Writing powerful <code>syntax-rules</code>
      macros is hard because they do not compose well: The arguments of a macro
      expansion are not expanded. This SRFI defines an easy to comprehend
      high-level system for writing powerful, composable (or <em>eager</em>)
      macros, two of whose defining features are that its macro arguments are
      (in general) eagerly expanded and that it can be portably implemented in
      any Scheme implementation conforming to the R7RS.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Tue, 08 Aug 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 144: Flonums</title><link>https://srfi.schemers.org/srfi-144/srfi-144.html</link><guid>https://srfi.schemers.org/srfi-144</guid><description>SRFI 144 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes numeric procedures
      applicable to <em>flonums</em>, a subset of the inexact real numbers
      provided by a Scheme implementation. In most Schemes, the flonums and the
      inexact reals are the same. These procedures are semantically equivalent
      to the corresponding generic procedures, but allow more efficient
      implementations.</p></blockquote></description><dc:creator>John Cowan and Will Clinger</dc:creator><pubDate>Mon, 17 Jul 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 151: Bitwise Operations</title><link>https://srfi.schemers.org/srfi-151/srfi-151.html</link><guid>https://srfi.schemers.org/srfi-151</guid><description>SRFI 151 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes a coherent and comprehensive
      set of procedures for performing bitwise logical operations on integers;
      it is accompanied by a reference implementation of the spec in terms of a
      set of seven core operators. The sample implementation is portable, as
      efficient as practical with pure Scheme arithmetic (it is much more
      efficient to replace the core operators with C or assembly language if
      possible), and open source.
      </p><p>The precise semantics of these operators is
      almost never an issue. A consistent, portable set of <em>names</em> and
      <em>parameter conventions</em>, however, is. Hence this SRFI, which is
      based mainly on <a href="https://srfi.schemers.org/srfi-33/">SRFI 33</a>, with some changes and
      additions from <a href="http://srfi.schemers.org/srfi-33/mail-archive/msg00023.html">Olin's late
      revisions to SRFI 33</a> (which were never consummated). <a href="https://srfi.schemers.org/srfi-60/">SRFI 60</a> (based on SLIB) is smaller but has a few
      procedures of its own; some of its procedures have both native (often
      Common Lisp) and SRFI 33 names. They have been incorporated into this
      SRFI. <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4">
      R6RS</a> is a subset of SRFI 60, except that all procedure names begin
      with a <code>bitwise-</code> prefix. A few procedures have been added from
      the general vector <a href="https://srfi.schemers.org/srfi-133/">SRFI 133</a>.
      </p><p>Among the applications of bitwise operations
      are: hashing, Galois-field calculations of error-detecting and
      error-correcting codes, cryptography and ciphers, pseudo-random number
      generation, register-transfer-level modeling of digital logic designs,
      Fast-Fourier transforms, packing and unpacking numbers in persistent data
      structures, space-filling curves with applications to dimension reduction
      and sparse multi-dimensional database indexes, and generating approximate
      seed values for root-finders and transcendental function
      algorithms.
      </p><p>This SRFI differs from SRFI 142 in only two
      ways:
      <ol>
        <li>
          <p>The <code>bitwise-if</code> function has the
          argument ordering of SLIB, SRFI 60, and R6RS rather than the ordering
          of SRFI 33.
        <li>
          <p>The order in which bits are processed by
          the procedures listed in the "Bits conversion" section has been
          clarified and some of the procedures' names have been changed. See
          "Bit processing order" for details.
      <ol></ol></p></li></p></li></ol></p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Mon, 10 Jul 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 149: Basic Syntax-rules Template Extensions</title><link>https://srfi.schemers.org/srfi-149/srfi-149.html</link><guid>https://srfi.schemers.org/srfi-149</guid><description>SRFI 149 is now in <em>final</em> status.<blockquote>      <p>The rules for valid
      <code>&lt;template></code>s of <code>&lt;syntax rules></code> are
      slightly softened to allow for more than one consecutive
      <code>&lt;ellipsis></code> in subtemplates, and to allow pattern
      variables in subtemplates to be followed by more instances of the
      identifier <code>&lt;ellipsis></code> than they are followed in the
      subpattern in which they occur.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sat, 08 Jul 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 143: Fixnums</title><link>https://srfi.schemers.org/srfi-143/srfi-143.html</link><guid>https://srfi.schemers.org/srfi-143</guid><description>SRFI 143 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes arithmetic procedures
      applicable to a limited range of exact integers only. These procedures
      are semantically similar to the corresponding generic-arithmetic
      procedures, but allow more efficient implementations.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sat, 27 May 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 140: Immutable Strings</title><link>https://srfi.schemers.org/srfi-140/srfi-140.html</link><guid>https://srfi.schemers.org/srfi-140</guid><description>SRFI 140 is now in <em>final</em> status.<blockquote>      <p>This attempts to solve the same issues with
      R7RS strings raised by <a href="https://srfi.schemers.org/srfi-135/">SRFI-135</a>, but with better
      integration with the Scheme language.
      </p><p>We propose to retain the name <dfn>string</dfn>
      as the type of sequences of Unicode characters (scalar values). There are
      two standard subtypes of string:
      <ul>
        <li>Immutable strings, also called
        <dfn>istrings</dfn>, cannot be modified after they have been created.
        Calling <code>string-set!</code> on an istring throws an error. On the
        other hand, the core operations <code>string-ref</code> and
        <code>string-length</code> are guaranteed to be O(1).
        </li><li>Mutable strings can be modified
        <q>in-place</q> using <code>string-set!</code> and other operations.
        However, <code>string-ref</code>, <code>string-set!</code>, or
        <code>string-length</code> have no performance guarantees. On many
        implementation they may take time proportional to the length of the
        string.
      </li></ul><li>
      <p>An implementation may support other kinds of
      strings. For example on the Java platform it may be reasonable to
      consider any instance of <code>java.lang.CharSequence</code> to be a
      string.
      </p><p>The main part of the proposal specifies the
      default bindings of various procedure names, as might be pre-defined in a
      REPL. Specifically, some procedures that traditionally return mutable
      strings are changed to return istrings. We later discuss compatibility
      and other library issues.
      </p><p>This combines <a href="https://srfi.schemers.org/srfi-13/">SRFI-13</a>,
      <a href="https://srfi.schemers.org/srfi-135/">SRFI-135</a>, and <a href="/srfi-118/">SRFI-118</a>.</p></li></p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Wed, 24 May 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 145: Assumptions</title><link>https://srfi.schemers.org/srfi-145/srfi-145.html</link><guid>https://srfi.schemers.org/srfi-145</guid><description>SRFI 145 is now in <em>final</em> status.<blockquote>      <p>A means to denote the invalidity of certain
      code paths in a Scheme program is proposed. It allows Scheme code to turn
      the evaluation into a user-defined error that need not be signalled by
      the implementation. Optimizing compilers may use these denotations to
      produce better code and to issue better warnings about dead code.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Fri, 31 Mar 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 147: Custom macro transformers</title><link>https://srfi.schemers.org/srfi-147/srfi-147.html</link><guid>https://srfi.schemers.org/srfi-147</guid><description>SRFI 147 is now in <em>final</em> status.<blockquote>      <p>Each syntax definition assigns a macro
      transformer to a keyword. The macro transformer is specified by a
      transformer spec, which is either an instance of
      <code>syntax-rules</code>, an existing syntactic keyword (including macro
      keywords and the syntactic keywords that introduce the core forms, like
      <code>lambda</code>, <code>if</code>, or <code>define</code>), or a use
      of a macro that eventually expands into an instance of
      <code>syntax-rules</code>. In the latter case, the keyword of macro use
      is called a <em>custom macro transformer</em>.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Tue, 07 Mar 2017 12:00:00 -0800</pubDate></item><item><title>SRFI 136: Extensible record types</title><link>https://srfi.schemers.org/srfi-136/srfi-136.html</link><guid>https://srfi.schemers.org/srfi-136</guid><description>SRFI 136 is now in <em>final</em> status.<blockquote>      <p>SRFI 9 and the compatible R7RS-small provide
      Scheme with record types. The basic problem that is solved by these
      record types is that they allow the user to introduce new types, disjoint
      from all existing types. The record type system described in this
      document is a conservative extension to SRFI 9 and R7RS record types (in
      other words, the keyword <code>define-record-type</code> defined in this
      specification can serve as the equally named keyword from SRFI 9 and R7RS
      and can thus be safely exported from <code>(srfi 9)</code> and
      <code>(scheme base)</code>) that is intended to solve another fundamental
      problem, namely the introduction of subtypes.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sun, 25 Dec 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 122: Nonempty Intervals and Generalized Arrays</title><link>https://srfi.schemers.org/srfi-122/srfi-122.html</link><guid>https://srfi.schemers.org/srfi-122</guid><description>SRFI 122 is now in <em>final</em> status.<blockquote>      <p>This SRFI specifies an array mechanism for
      Scheme. Arrays as defined here are quite general; at their most basic, an
      array is simply a mapping, or function, from multi-indices of exact
      integers $i_0,\ldots,i_{d-1}$ to Scheme values. The set of multi-indices
      $i_0,\ldots,i_{d-1}$ that are valid for a given array form the
      <i>domain</i> of the array. In this SRFI, each array's domain consists of
      a rectangular interval
      $[l_0,u_0)\times[l_1,u_1)\times\cdots\times[l_{d-1},u_{d-1})$, a subset
      of $\mathbb Z^d$, $d$-tuples of integers. Thus, we introduce a data type
      called <i>intervals</i>, which encapsulate the cross product of nonempty
      intervals of exact integers. Specialized variants of arrays are specified
      to provide portable programs with efficient representations for common
      use cases.</p></blockquote></description><dc:creator>Bradley J. Lucier</dc:creator><pubDate>Sat, 24 Dec 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 141: Integer division</title><link>https://srfi.schemers.org/srfi-141/srfi-141.html</link><guid>https://srfi.schemers.org/srfi-141</guid><description>SRFI 141 is now in <em>final</em> status.<blockquote>      <p>This SRFI provides a fairly complete set of
      integral division and remainder operators.</p></blockquote></description><dc:creator>Taylor Campbell and John Cowan</dc:creator><pubDate>Wed, 14 Dec 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 137: Minimal Unique Types</title><link>https://srfi.schemers.org/srfi-137/srfi-137.html</link><guid>https://srfi.schemers.org/srfi-137</guid><description>SRFI 137 is now in <em>final</em> status.<blockquote>      <p>This SRFI is intended to standardize a
      primitive run-time mechanism to create disjoint types.</p></blockquote></description><dc:creator>John Cowan and Marc Nieper-Wißkirchen</dc:creator><pubDate>Tue, 04 Oct 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 139: Syntax parameters</title><link>https://srfi.schemers.org/srfi-139/srfi-139.html</link><guid>https://srfi.schemers.org/srfi-139</guid><description>SRFI 139 is now in <em>final</em> status.<blockquote>      <p>Syntax parameters are to the expansion process
      of a Scheme program what parameters are to the evaluation process of a
      Scheme program. They allow hygienic implementation of syntactic forms
      that would otherwise introduce implicit identifiers
      unhygienically.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Sun, 02 Oct 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 138: Compiling Scheme programs to executables</title><link>https://srfi.schemers.org/srfi-138/srfi-138.html</link><guid>https://srfi.schemers.org/srfi-138</guid><description>SRFI 138 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes, for sufficiently
      POSIX-compatible systems, a portable interface for compiling Scheme
      programs conforming to the R7RS to binaries that can be directly executed
      on the host system.</p></blockquote></description><dc:creator>Marc Nieper-Wißkirchen</dc:creator><pubDate>Wed, 28 Sep 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 135: Immutable Texts</title><link>https://srfi.schemers.org/srfi-135/srfi-135.html</link><guid>https://srfi.schemers.org/srfi-135</guid><description>SRFI 135 is now in <em>final</em> status.<blockquote>      <p>In Scheme, strings are a mutable data type.
      Although it "is an error" (<abbr title="Revised&lt;sup>5&lt;/sup> Report on Scheme">R5RS</abbr> and
      <abbr title="Revised&lt;sup>7&lt;/sup> Report on Scheme">R7RS</abbr>) to use
      <code>string-set!</code> on literal strings or on strings returned by
      <code>symbol->string</code>, and any attempt to do so "should raise an
      exception" (<abbr title="Revised&lt;sup>6&lt;/sup> Report on Scheme">R6RS</abbr>), all
      other strings are mutable.
      </p><p>Although many mutable strings are never
      actually mutated, the mere possibility of mutation complicates
      specifications of libraries that use strings, encourages precautionary
      copying of strings, and precludes structure sharing that could otherwise
      be used to make procedures such as <code>substring</code> and
      <code>string-append</code> faster and more space-efficient.
      </p><p>This <abbr title="Scheme Request for Implementation">SRFI</abbr> specifies a new data type
      of immutable texts. It comes with efficient and portable sample
      implementations that guarantee O(1) indexing for both sequential and
      random access, even in systems whose <code>string-ref</code> procedure
      takes linear time.
      </p><p>The operations of this new data type include
      analogues for all of the non-mutating operations on strings specified by
      the R7RS and most of those specified by <abbr title="String cursors"><a href="https://srfi.schemers.org/srfi-130/">SRFI 130</a></abbr>, but the
      immutability of texts and uniformity of character-based indexing simplify
      the specification of those operations while avoiding several
      inefficiencies associated with the mutability of Scheme's strings.</p></blockquote></description><dc:creator>William D Clinger</dc:creator><pubDate>Tue, 06 Sep 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 134: Immutable Deques</title><link>https://srfi.schemers.org/srfi-134/srfi-134.html</link><guid>https://srfi.schemers.org/srfi-134</guid><description>SRFI 134 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines immutable deques. A deque is
      a double-ended queue, a sequence which allows elements to be added or
      removed efficiently from either end. A structure is immutable when all
      its operations leave the structure unchanged. Note that none of the
      procedures specified here ends with an exclamation point.</p></blockquote></description><dc:creator>Kevin Wortman and John Cowan</dc:creator><pubDate>Fri, 01 Jul 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 130: Cursor-based string library</title><link>https://srfi.schemers.org/srfi-130/srfi-130.html</link><guid>https://srfi.schemers.org/srfi-130</guid><description>SRFI 130 is now in <em>final</em> status.<blockquote>      <p><abbr title="Revised&lt;sup>5&lt;/sup> Report on Scheme">R5RS</abbr> Scheme has
      an impoverished set of string-processing utilities, which is a problem
      for authors of portable code. Although <abbr title="Revised&lt;sup>7&lt;/sup> Report on Scheme">R7RS</abbr> provides
      some extensions and improvements, it is still very incomplete. This
      <abbr title="Scheme Request for Implementation">SRFI</abbr> proposes a
      coherent and comprehensive set of string-processing procedures; it is
      accompanied by a portable sample implementation of the spec.
      </p><p>This SRFI is derived from SRFI 13. The biggest
      difference is that it allows subsequences of strings to be specified by
      <em>cursors</em> as well as the traditional string indexes. In addition,
      it omits the comparison, case-mapping, and mutation operations of SRFI
      13, as well as all procedures already present in <abbr title="Revised&lt;sup>7&lt;/sup> Report on Scheme">R7RS</abbr>.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sat, 28 May 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 132: Sort Libraries</title><link>https://srfi.schemers.org/srfi-132/srfi-132.html</link><guid>https://srfi.schemers.org/srfi-132</guid><description>SRFI 132 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes the API for a full-featured
      sort toolkit.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Wed, 20 Apr 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 133: Vector Library (R7RS-compatible)</title><link>https://srfi.schemers.org/srfi-133/srfi-133.html</link><guid>https://srfi.schemers.org/srfi-133</guid><description>SRFI 133 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes a comprehensive library of
      vector operations accompanied by a freely available and complete
      reference implementation. The reference implementation is unencumbered by
      copyright, and useable with no modifications on any Scheme system that is
      R5RS-compliant. It also provides several hooks for
      implementation-specific optimization as well.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 20 Mar 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 129: Titlecase procedures</title><link>https://srfi.schemers.org/srfi-129/srfi-129.html</link><guid>https://srfi.schemers.org/srfi-129</guid><description>SRFI 129 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines R7RS-style
      <code>char-title-case?</code>, <code>char-titlecase</code>, and
      <code>string-titlecase</code> procedures.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Tue, 08 Mar 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 128: Comparators (reduced)</title><link>https://srfi.schemers.org/srfi-128/srfi-128.html</link><guid>https://srfi.schemers.org/srfi-128</guid><description>SRFI 128 is now in <em>final</em> status.<blockquote>      <p>This SRFI provides <i>comparators</i>, which
      bundle a type test predicate, an equality predicate, an ordering
      predicate, and a hash function (the last two are optional) into a single
      Scheme object. By packaging these procedures together, they can be
      treated as a single item for use in the implementation of data
      structures.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Sun, 14 Feb 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 131: ERR5RS Record Syntax (reduced)</title><link>https://srfi.schemers.org/srfi-131/srfi-131.html</link><guid>https://srfi.schemers.org/srfi-131</guid><description>SRFI 131 is now in <em>final</em> status.<blockquote>      <p>This SRFI is a reduced version of the SRFI 99
      syntactic layer that can be implemented with <code>syntax-rules</code>
      without requiring low-level macros. Like SRFI-99's syntax layer, it is
      backward compatible with the <code>define-record-type</code> macro from
      <a href="https://srfi.schemers.org/srfi-9/">SRFI 9</a> or R7RS-small. It is forward compatible with
      <a href="https://srfi.schemers.org/srfi-99/">SRFI 99</a>.</p></blockquote></description><dc:creator>John Cowan and Will Clinger</dc:creator><pubDate>Sat, 13 Feb 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 126: R6RS-based hashtables</title><link>https://srfi.schemers.org/srfi-126/srfi-126.html</link><guid>https://srfi.schemers.org/srfi-126</guid><description>SRFI 126 is now in <em>final</em> status.<blockquote>      <p>We provide a hashtable API that takes the R6RS
      hashtables API as a basis and makes backwards compatible additions such
      as support for weak hashtables, external representation, API support for
      double hashing implementations, and utility procedures.</p></blockquote></description><dc:creator>Taylan Ulrich Bayırlı/Kammer</dc:creator><pubDate>Mon, 01 Feb 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 127: Lazy Sequences</title><link>https://srfi.schemers.org/srfi-127/srfi-127.html</link><guid>https://srfi.schemers.org/srfi-127</guid><description>SRFI 127 is now in <em>final</em> status.<blockquote>      <p>Lazy sequences (or lseqs, pronounced
      "ell-seeks") are a generalization of lists. In particular, an lseq is
      either a proper list or a dotted list whose last cdr is a <a href="https://srfi.schemers.org/srfi-121/">SRFI 121</a> generator. A generator is a procedure that can
      be invoked with no arguments in order to lazily supply additional
      elements of the lseq. When a generator has no more elements to return, it
      returns an end-of-file object. Consequently, lazy sequences cannot
      reliably contain end-of-file objects.
      </p><p>This SRFI provides a set of procedures suitable
      for operating on lazy sequences based on <a href="https://srfi.schemers.org/srfi-1/">SRFI
      1</a>.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Mon, 18 Jan 2016 12:00:00 -0800</pubDate></item><item><title>SRFI 124: Ephemerons</title><link>https://srfi.schemers.org/srfi-124/srfi-124.html</link><guid>https://srfi.schemers.org/srfi-124</guid><description>SRFI 124 is now in <em>final</em> status.<blockquote>      <p>An ephemeron is an object with two components
      called its <em>key</em> and its <em>datum</em>. It differs from an
      ordinary pair as follows: if the garbage collector (GC) can prove that
      there are no references to the key except from the ephemeron itself and
      possibly from the datum, then it is free to <em>break</em> the ephemeron,
      dropping its reference to both key and datum. In other words, an
      ephemeron can be broken when nobody else cares about its key. Ephemerons
      can be used to construct weak vectors or lists and (possibly in
      combination with finalizers) weak hash tables.
      </p><p>Much of this specification is derived with
      thanks from the MIT Scheme Reference Manual.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Fri, 06 Nov 2015 12:00:00 -0800</pubDate></item><item><title>SRFI 123: Generic accessor and modifier operators</title><link>https://srfi.schemers.org/srfi-123/srfi-123.html</link><guid>https://srfi.schemers.org/srfi-123</guid><description>SRFI 123 is now in <em>final</em> status.<blockquote>      <p>Lisp dialects including Scheme have
      traditionally lacked short, simple, generic syntax for accessing and
      modifying the fields of arbitrary "collection" objects. We fill this gap
      for Scheme by defining generalized accessors, and an associated SRFI-17
      setter.</p></blockquote></description><dc:creator>Taylan Ulrich Bayırlı/Kammer</dc:creator><pubDate>Wed, 14 Oct 2015 12:00:00 -0800</pubDate></item><item><title>SRFI 117: Queues based on lists</title><link>https://srfi.schemers.org/srfi-117/srfi-117.html</link><guid>https://srfi.schemers.org/srfi-117</guid><description>SRFI 117 is now in <em>final</em> status.<blockquote>      <p>List queues are mutable ordered collections
      that can contain any Scheme object. Each list queue is based on an
      ordinary Scheme list containing the elements of the list queue by
      maintaining pointers to the first and last pairs of the list. It's cheap
      to add or remove elements from the front of the list or to add elements
      to the back, but not to remove elements from the back. List queues are
      disjoint from other types of Scheme objects.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Tue, 25 Aug 2015 12:00:00 -0800</pubDate></item><item><title>SRFI 120: Timer APIs</title><link>https://srfi.schemers.org/srfi-120/srfi-120.html</link><guid>https://srfi.schemers.org/srfi-120</guid><description>SRFI 120 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines interfaces to handle timer
      processes.</p></blockquote></description><dc:creator>Takashi Kato</dc:creator><pubDate>Thu, 06 Aug 2015 12:00:00 -0800</pubDate></item><item><title>SRFI 118: Simple adjustable-size strings</title><link>https://srfi.schemers.org/srfi-118/srfi-118.html</link><guid>https://srfi.schemers.org/srfi-118</guid><description>SRFI 118 is now in <em>final</em> status.<blockquote>      <p>Scheme specifies mutable fixed-length strings.
      We add two procedures <code>string-append!</code> and
      <code>string-replace!</code> which allow the size of the string to
      change. We also require that the standard Scheme procedures
      <code>make-string</code> and <code>string-copy</code> return
      variable-size strings.</p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Tue, 07 Jul 2015 12:00:00 -0800</pubDate></item><item><title>SRFI 119: wisp: simpler indentation-sensitive scheme</title><link>https://srfi.schemers.org/srfi-119/srfi-119.html</link><guid>https://srfi.schemers.org/srfi-119</guid><description>SRFI 119 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes a simple syntax which
      allows making scheme easier to read for newcomers while keeping the
      simplicity, generality and elegance of s-expressions. Similar to <a href="https://srfi.schemers.org/srfi-110/">SRFI 110</a>, <a href="/srfi-49/">SRFI 49</a> and Python it
      uses indentation to group expressions. Like <a href="https://srfi.schemers.org/srfi-110/">SRFI
      110</a> wisp is general and homoiconic.
      </p><p>Different from its predecessors, wisp only uses
      the absolute minimum of additional syntax-elements which are required for
      writing and exchanging arbitrary code-structures. As syntax elements it
      only uses a colon surrounded by whitespace, the period followed by
      whitespace as first code-character on the line and optional underscores
      followed by whitespace at the beginning of the line.
      </p><p>It resolves a limitation of <a href="https://srfi.schemers.org/srfi-110/">SRFI 110</a> and <a href="/srfi-49/">SRFI 49</a>, both of
      which force the programmer to use a single argument per line if the
      arguments to a procedure need to be continued after a
      procedure-call.
      </p><p>Wisp expressions can include arbitrary
      s-expressions and as such provide backwards compatibility.
      <blockquote>
        <table>
          <tr>
            <th>wisp
            <th>s-exp
          <tr>
            <td>
              <pre>
<b>define</b> : <i>factorial</i> n
__  <b>if</b> : <i>zero?</i> n
____   . 1
____   <i>*</i> n : <i>factorial</i> (- n 1)

<i>display</i> : <i>factorial</i> 5
<i>newline</i>
</pre>
            </td><td>
              <pre>
(<b>define</b> (<i>factorial</i> n)
    (<b>if</b> (<i>zero?</i> n)
       1
       (<i>*</i> n (<i>factorial</i> (- n 1)))))

(<i>display</i> (<i>factorial</i> 5))
(<i>newline</i>)
</pre>
        </td></tr></th></th></tr></table>
      </blockquote></p></blockquote></description><dc:creator>Arne Babenhauserheide</dc:creator><pubDate>Tue, 23 Jun 2015 12:00:00 -0800</pubDate></item><item><title>SRFI 125: Intermediate hash tables</title><link>https://srfi.schemers.org/srfi-125/srfi-125.html</link><guid>https://srfi.schemers.org/srfi-125</guid><description>SRFI 125 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines an interface to hash tables,
      which are widely recognized as a fundamental data structure for a wide
      variety of applications. A hash table is a data structure that:
      <ul>
        <li>Is disjoint from all other types.
        </li><li>
          Provides a mapping from objects known as
          <em>keys</em> to corresponding objects known as
          <em>values</em>.
          <ul>
            <li>Keys may be any Scheme objects in some
            kinds of hash tables, but are restricted in other kinds.
            </li><li>Values may be any Scheme objects.
          </li></ul><li>
        </li><li>Has no intrinsic order for the key-value
        <em>associations</em> it contains.
        </li><li>Provides an <em>equality predicate</em>
        which defines when a proposed key is the same as an existing key. No
        table may contain more than one value for a given key.
        </li><li>Provides a <em>hash function</em> which maps
        a candidate key into a non-negative exact integer.
        </li><li>Supports mutation as the primary means of
        setting the contents of a table.
        </li><li>Provides key lookup and destructive update
        in (expected) amortized constant time, provided a satisfactory hash
        function is available.
        </li><li>Does not guarantee that whole-table
        operations work in the presence of concurrent mutation of the whole
        hash table (values may be safely mutated).
      </li></li><li></li></ul></p></blockquote></description><dc:creator>John Cowan and Will Clinger</dc:creator><pubDate>Thu, 28 May 2015 12:00:00 -0800</pubDate></item><item><title>SRFI 113: Sets and bags</title><link>https://srfi.schemers.org/srfi-113/srfi-113.html</link><guid>https://srfi.schemers.org/srfi-113</guid><description>SRFI 113 is now in <em>final</em> status.<blockquote>      <p><em>Sets</em> and <em>bags</em> (also known as
      multisets) are unordered collections that can contain any Scheme object.
      Sets enforce the constraint that no two elements can be the same in the
      sense of the set's associated <em>equality predicate</em>; bags do
      not.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Fri, 28 Nov 2014 12:00:00 -0800</pubDate></item><item><title>SRFI 116: Immutable List Library</title><link>https://srfi.schemers.org/srfi-116/srfi-116.html</link><guid>https://srfi.schemers.org/srfi-116</guid><description>SRFI 116 is now in <em>final</em> status.<blockquote>      <p>Scheme currently does not provide immutable
      pairs corresponding to its existing mutable pairs, although most uses of
      pairs do not exploit their mutability. The <a href="http://www.racket-lang.org">Racket</a> system takes the radical approach
      of making Scheme's pairs immutable, and providing a minimal library of
      mutable pairs with procedures named <code>mpair?, mcons, mcar, mcdr,
      set-mcar!, set-mcdr!</code>. This SRFI takes the opposite approach of
      leaving Scheme's pairs unchanged and providing a full set of routines for
      creating and dealing with immutable pairs. The sample implementation is
      portable (to systems with SRFI 9) and efficient.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Fri, 28 Nov 2014 12:00:00 -0800</pubDate></item><item><title>SRFI 115: Scheme Regular Expressions</title><link>https://srfi.schemers.org/srfi-115/srfi-115.html</link><guid>https://srfi.schemers.org/srfi-115</guid><description>SRFI 115 is now in <em>final</em> status.<blockquote>      <p>This SRFI provides a library for matching
      strings with regular expressions described using the SRE "Scheme Regular
      Expression" notation first introduced by SCSH, and extended heavily by
      IrRegex.</p></blockquote></description><dc:creator>Alex Shinn</dc:creator><pubDate>Mon, 14 Jul 2014 12:00:00 -0800</pubDate></item><item><title>SRFI 107: XML reader syntax</title><link>https://srfi.schemers.org/srfi-107/srfi-107.html</link><guid>https://srfi.schemers.org/srfi-107</guid><description>SRFI 107 is now in <em>final</em> status.<blockquote>      <p>We specify a reader extension that reads data
      in a superset of XML/HTML format, and produces conventional
      S-expressions. We also suggest a possible semantics interpretation of how
      these forms may be evaluated to produce XML-node values, but this is
      non-normative.</p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Sun, 22 Dec 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 112: Environment Inquiry</title><link>https://srfi.schemers.org/srfi-112/srfi-112.html</link><guid>https://srfi.schemers.org/srfi-112</guid><description>SRFI 112 is now in <em>final</em> status.<blockquote>      <p>This is a proposal for environment inquiry,
      providing human-readable information <em>at run time</em> about the
      hardware and software configuration on which a Scheme program is being
      executed. They are mostly based on Common Lisp, with additions from the
      Posix <code>uname()</code> system call.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Thu, 12 Sep 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 110: Sweet-expressions (t-expressions)</title><link>https://srfi.schemers.org/srfi-110/srfi-110.html</link><guid>https://srfi.schemers.org/srfi-110</guid><description>SRFI 110 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes a set of syntax extensions
      for Scheme, called sweet-expressions (t-expressions), that has the same
      descriptive power as s-expressions but is designed to be easier for
      humans to read. The sweet-expression syntax enables the use of
      syntactically-meaningful indentation to group expressions (similar to
      Python), and it builds on the infix and traditional function notation
      defined in <a href="https://srfi.schemers.org/srfi-105/">SRFI-105 (curly-infix-expressions)</a>.
      Unlike nearly all past efforts to improve s-expression readability,
      sweet-expressions are general (the notation is independent from any
      underlying semantic) and homoiconic (the underlying data structure is
      clear from the syntax). This notation was developed by the “<a href="http://readable.sourceforge.net/">Readable Lisp S-expressions
      Project</a>” and can be used for both programs and data.
      </p><p>Sweet-expressions can be considered a set of
      additional abbreviations, just as <code>'x</code> already abbreviates
      <code>(quote x)</code>. Sweet-expressions and traditionally formatted
      s-expressions can be freely mixed; this provides backwards compatibility,
      simplifies transition, and enables developers to maximize readability.
      Here is an example of a sweet-expression and its equivalent s-expression
      (note that a sweet-expression reader would accept <em>either</em>
      format):
      <table border="1" cellpadding="4">
        <tr>
          <th>sweet-expression
          <th>s-expression
        <tr>
          <td>
            <pre>
define fibfast(n)   ; Typical function notation
  if {n &lt; 2}        ; Indentation, infix {...}
     n              ; Single expr = no new list
     fibup n 2 1 0  ; Simple function calls
</pre>
          </td><td>
            <pre>
(define (fibfast n)
  (if (&lt; n 2)
      n
      (fibup n 2 1 0)))
</pre>
      </td></tr></th></th></tr></table></p></blockquote></description><dc:creator>David A. Wheeler and Alan Manuel K. Gloria</dc:creator><pubDate>Mon, 09 Sep 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 106: Basic socket interface</title><link>https://srfi.schemers.org/srfi-106/srfi-106.html</link><guid>https://srfi.schemers.org/srfi-106</guid><description>SRFI 106 is now in <em>final</em> status.<blockquote>      <p>This document specifies basic socket
      interfaces.</p></blockquote></description><dc:creator>Takashi Kato</dc:creator><pubDate>Tue, 20 Aug 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 111: Boxes</title><link>https://srfi.schemers.org/srfi-111/srfi-111.html</link><guid>https://srfi.schemers.org/srfi-111</guid><description>SRFI 111 is now in <em>final</em> status.<blockquote>      <p>Boxes are objects with a single mutable state.
      Several Schemes have them, sometimes called <i>cells</i>. A constructor,
      predicate, accessor, and mutator are provided.</p></blockquote></description><dc:creator>John Cowan</dc:creator><pubDate>Wed, 03 Jul 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 108: Named quasi-literal constructors</title><link>https://srfi.schemers.org/srfi-108/srfi-108.html</link><guid>https://srfi.schemers.org/srfi-108</guid><description>SRFI 108 is now in <em>final</em> status.<blockquote>      <p>This specifies an extensible reader syntax for
      named value constructors. A reader prefix is followed by a <q>tag</q> (an
      identifier), and then expressions and literal text parameters. The tag
      can be though of as a class name, and the expression and literal text are
      arguments to an object constructor call. The reader translates
      <code>&amp;<var>tag</var>{...}</code> to a list
      <code>($construct$:<var>tag</var> ...)</code>, where
      <code>$construct$:<var>tag</var></code> is normally bound to a predefined
      macro.
      </p><p>This propsal depends on <a href="https://srfi.schemers.org/srfi-109/">SRFI-109 (extended string quasi-literals)</a> (in spite of
      having a lower number). It also shares quite of bit of syntax with
      <a href="https://srfi.schemers.org/srfi-107/">SRFI-107 (XML reader syntax)</a>.</p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Fri, 21 Jun 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 109: Extended string quasi-literals</title><link>https://srfi.schemers.org/srfi-109/srfi-109.html</link><guid>https://srfi.schemers.org/srfi-109</guid><description>SRFI 109 is now in <em>final</em> status.<blockquote>      <p>This specifies a reader extension for extended
      string quasi-literals, including nicer multi-line strings, and enclosed
      unquoted expressions.
      </p><p>This proposal is related to <a href="https://srfi.schemers.org/srfi-108/">SRFI-108 (named quasi-literal constructors)</a> and <a href="/srfi-107/">SRFI-107 (XML reader syntax)</a>, as they share quite a bit
      of syntax.</p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Fri, 21 Jun 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 103: Library Files</title><link>https://srfi.schemers.org/srfi-103/srfi-103.html</link><guid>https://srfi.schemers.org/srfi-103</guid><description>SRFI 103 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI defines a standard for locating files
      containing libraries with list-of-symbols library names, for unixes and
      Windows. It defines a standard for files containing R6RS libraries. It
      supports different Scheme dialects.</p></blockquote></description><dc:creator>Derick Eddington</dc:creator><pubDate>Wed, 08 May 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 101: Purely Functional Random-Access Pairs and Lists</title><link>https://srfi.schemers.org/srfi-101/srfi-101.html</link><guid>https://srfi.schemers.org/srfi-101</guid><description>SRFI 101 is now in <em>final</em> status.<blockquote>      <p>Random-access lists [1] are a purely functional
      data structure for representing lists of values. A random-access list may
      act as a drop in replacement for the usual linear-access pair and list
      data structures (<code>pair?</code>, <code>cons</code>, <code>car</code>,
      <code>cdr</code>), which additionally supports fast index-based
      addressing and updating (<code>list-ref</code>, <code>list-set</code>).
      The impact is a whole class of purely-functional algorithms expressed in
      terms of index-based list addressing become feasible compared with their
      linear-access list counterparts.
      </p><p>This document proposes a library API for purely
      functional random-access lists consistent with the R<sup>6</sup>RS [2]
      base library and list utility standard library [3].</p></blockquote></description><dc:creator>David Van Horn</dc:creator><pubDate>Sun, 24 Feb 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 102: Procedure Arity Inspection</title><link>https://srfi.schemers.org/srfi-102/srfi-102.html</link><guid>https://srfi.schemers.org/srfi-102</guid><description>SRFI 102 is now in <em>withdrawn</em> status.<blockquote>      <p>Many Scheme systems provide mechanisms for
      inspecting the arity of a procedural value, making it a common feature,
      however there is no standard interface. As a result there is no portable
      way to observe the arity of a procedure <em>without actually applying
      it</em>. This SRFI proposes a simple interface that is consistent with
      existing Scheme systems' facilities and prior proposals.</p></blockquote></description><dc:creator>David Van Horn</dc:creator><pubDate>Sun, 24 Feb 2013 12:00:00 -0800</pubDate></item><item><title>SRFI 105: Curly-infix-expressions</title><link>https://srfi.schemers.org/srfi-105/srfi-105.html</link><guid>https://srfi.schemers.org/srfi-105</guid><description>SRFI 105 is now in <em>final</em> status.<blockquote>      <p>Lisp-based languages, like Scheme, are almost
      the only programming languages in modern use that do not support infix
      notation. In addition, most languages allow infix expressions to be
      combined with function call notation of the form
      <code><var>f</var>(<var>x</var>)</code>. This SRFI provides these
      capabilities, both for developers who already use Scheme and want these
      conveniences, and also for other developers who may choose to use other
      languages in part because they miss these conveniences. Scheme currently
      reserves <code>{</code>...<code>}</code> “for possible future extensions
      to the language”. We propose that <code>{</code>...<code>}</code> be used
      to support “curly-infix-expression” notation as a homoiconic infix
      abbreviation, as a modification of the Scheme reader. It is an
      abbreviation in much the same way that <samp>'x</samp> is an abbreviation
      for <samp>(quote x)</samp>.
      </p><p>A <dfn>curly-infix list</dfn> introduces a list
      whose visual presentation can be in infix order instead of prefix order.
      For example, <samp>{n > 5}</samp> ⇒
      <samp>(> n 5)</samp>, and
      <samp>{a + b + c}</samp> ⇒
      <samp>(+ a b c)</samp>. By intent, there is no precedence,
      but e.g., <samp>{x + {y * z}}</samp> maps cleanly to
      <samp>(+ x (* y z))</samp>. Forms with mixed infix
      operators and other complications have “<code>$nfx$</code>” prepended to
      enable later processing, e.g.,
      <samp>{4 + 5 * 6}</samp> ⇒
      <samp>($nfx$ 4 + 5 * 6)</samp>. Also, inside a
      curly-infix list (recursively), expressions of the form
      <code><var>f</var>(</code>...<code>)</code> are simply an abbreviation
      for <code>(<var>f</var> </code>...<code>)</code>.
      </p><p>Note that this is derived from the “<a href="http://readable.sourceforge.net/">readable</a>” project. We intend to
      later submit at least one additional SRFI that will build on top of this
      SRFI, but curly-infix-expressions are useful on their own.</p></blockquote></description><dc:creator>David A. Wheeler and Alan Manuel K. Gloria</dc:creator><pubDate>Tue, 06 Nov 2012 12:00:00 -0800</pubDate></item><item><title>SRFI 100: define-lambda-object</title><link>https://srfi.schemers.org/srfi-100/srfi-100.html</link><guid>https://srfi.schemers.org/srfi-100</guid><description>SRFI 100 is now in <em>final</em> status.<blockquote>      <p>This SRFI introduces a macro,
      DEFINE-LAMBDA-OBJECT which defines a set of procedures, that is, a group,
      two constructors, and a predicate. The constructors also make a group of
      procedures, namely lambda objects. The macro extends DEFINE-RECORD-TYPE
      (SRFI 9) in being more general but much less general than DEFCLASS
      (CLOS). The macro has no explicit field accessors and mutators but parent
      groups, required fields, optional fields, automatic fields, read-write
      fields, read-only fields, inaccessible hidden fields, immutable virtual
      fields, and common sharing fields.</p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Mon, 21 Jun 2010 12:00:00 -0800</pubDate></item><item><title>SRFI 104: Library Files Utilities</title><link>https://srfi.schemers.org/srfi-104/srfi-104.html</link><guid>https://srfi.schemers.org/srfi-104</guid><description>SRFI 104 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI implements <a href="https://srfi.schemers.org/srfi-103/">SRFI 103: Library Files</a> as a library. It is useful
      for working with library files.</p></blockquote></description><dc:creator>Derick Eddington</dc:creator><pubDate>Sun, 23 May 2010 12:00:00 -0800</pubDate></item><item><title>SRFI 99: ERR5RS Records</title><link>https://srfi.schemers.org/srfi-99/srfi-99.html</link><guid>https://srfi.schemers.org/srfi-99</guid><description>SRFI 99 is now in <em>final</em> status.<blockquote>      <p>Many Scheme programmers have considered records
      to be one of the most important features missing from the R5RS. The R6RS
      proposed a record system, but its design has been widely criticized and
      it was not intended for use in R5RS programs anyway.
      </p><p>This SRFI proposes a better record system for
      use in R5RS, ERR5RS, and R6RS programs. The syntactic layer of this
      SRFI's record system is an extension of SRFI 9. The procedural and
      inspection layers of this SRFI's record system are perfectly compatible
      with its syntactic layer. This entire SRFI is compatible with the
      procedural and inspection layers of the R6RS record system, but offers
      several worthwhile improvements over the R6RS system.</p></blockquote></description><dc:creator>William D Clinger</dc:creator><pubDate>Wed, 07 Oct 2009 12:00:00 -0800</pubDate></item><item><title>SRFI 97: SRFI Libraries</title><link>https://srfi.schemers.org/srfi-97/srfi-97.html</link><guid>https://srfi.schemers.org/srfi-97</guid><description>SRFI 97 is now in <em>final</em> status.<blockquote>      <p>Over the past ten years, numerous libraries
      have been specified via the Scheme Requests for Implementation process.
      Yet until the recent ratification of the Revised<sup>6</sup> Report on
      the Algorithmic Language Scheme, there has been no standardized way of
      distributing or relying upon library code. Now that such a library system
      exists, there is a real need to organize these existing SRFI libraries so
      that they can be portably referenced.
      </p><p>This SRFI is designed to facilitate the writing
      and distribution of code that relies on SRFI libraries. It identifies a
      subset of existing SRFIs that specify features amenable to provision (and
      possibly implementation) as libraries (SRFI Libraries) and proposes a
      naming convention for this subset so that these libraries may be referred
      to by name or by number. <*COMMENT*>
This convention represents a consensus among current R&lt;sup>6&lt;/sup>RS
implementors.
      </*COMMENT*></p></blockquote></description><dc:creator>David Van Horn</dc:creator><pubDate>Mon, 22 Dec 2008 12:00:00 -0800</pubDate></item><item><title>SRFI 98: An interface to access environment variables</title><link>https://srfi.schemers.org/srfi-98/srfi-98.html</link><guid>https://srfi.schemers.org/srfi-98</guid><description>SRFI 98 is now in <em>final</em> status.<blockquote>      <p>This SRFI specifies the procedure
      get-environment-variable, which gets the value of the specified
      environment variable, and the procedure get-environment-variables, which
      gets an association list of all environment variables.</p></blockquote></description><dc:creator>Taro Minowa (Higepon)</dc:creator><pubDate>Fri, 19 Sep 2008 12:00:00 -0800</pubDate></item><item><title>SRFI 96: SLIB Prerequisites</title><link>https://srfi.schemers.org/srfi-96/srfi-96.html</link><guid>https://srfi.schemers.org/srfi-96</guid><description>SRFI 96 is now in <em>final</em> status.<blockquote>      <p>This SRFI specifies a set of procedures and
      macros presenting a uniform interface sufficient to host the <a href="http://swiss.csail.mit.edu/~jaffer/SLIB">SLIB Scheme Library</a>
      system.</p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Mon, 07 Jul 2008 12:00:00 -0800</pubDate></item><item><title>SRFI 41: Streams</title><link>https://srfi.schemers.org/srfi-41/srfi-41.html</link><guid>https://srfi.schemers.org/srfi-41</guid><description>SRFI 41 is now in <em>final</em> status.<blockquote>      <p><span class="c1">Streams, sometimes called
      lazy lists, are a sequential data structure containing elements computed
      only on demand. A stream is either null or is a pair with a stream in its
      cdr. Since elements of a stream are computed only when accessed, streams
      can be infinite. Once computed, the value of a stream element is cached
      in case it is needed again.</span>
      </p><p><span class="c1">Streams without memoization
      were first described by Peter Landin in 1965. Memoization became accepted
      as an essential feature of streams about a decade later. Today, streams
      are the signature data type of functional programming languages such as
      Haskell.</span>
      </p><p><span class="c1">This Scheme Request for
      Implementation describes two libraries for operating on streams: a
      canonical set of stream primitives and a set of procedures and syntax
      derived from those primitives that permits convenient expression of
      stream operations. They rely on facilities provided by R6RS, including
      libraries, records, and error reporting. To load both stream libraries,
      say:</span>
      </p><p><span class="c2">(import (streams))</span></p></blockquote></description><dc:creator>Philip L. Bewig</dc:creator><pubDate>Thu, 24 Jan 2008 12:00:00 -0800</pubDate></item><item><title>SRFI 89: Optional positional and named parameters</title><link>https://srfi.schemers.org/srfi-89/srfi-89.html</link><guid>https://srfi.schemers.org/srfi-89</guid><description>SRFI 89 is now in <em>final</em> status.<blockquote>      <p>This SRFI specifies the <code>define*</code> and
      <code>lambda*</code> special forms. These forms extend the R5RS
      <code>define</code> and <code>lambda</code> special forms to simplify the use of
      optional positional and named parameters. Optional positional parameters,
      optional named parameters and required named parameters are covered by
      this SRFI. The formal parameter list syntax specified in this SRFI is
      different from the syntax used by Common Lisp and the DSSSL languages but
      nevertheless offers similar functionality and a nicer syntax. Formal
      parameter lists which conform to the R5RS syntax have the same meaning as
      in R5RS.</p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Tue, 10 Jul 2007 12:00:00 -0800</pubDate></item><item><title>SRFI 90: Extensible hash table constructor</title><link>https://srfi.schemers.org/srfi-90/srfi-90.html</link><guid>https://srfi.schemers.org/srfi-90</guid><description>SRFI 90 is now in <em>final</em> status.<blockquote>      <p>This SRFI specifies the procedure
      <code>make-table</code>, a hash table constructor compatible with <a href="https://srfi.schemers.org/srfi-69/">SRFI 69 (Basic hash tables)</a>. The procedure
      <code>make-table</code> allows various parameters of the hash table to be
      specified with optional named parameters when it is constructed. These
      parameters are: the initial size, the minimum and maximum load factor,
      the key equivalence function, the key hashing function, whether the
      references to the keys are weak, and similarly for the values. By using
      optional named parameters, as specified in <a href="https://srfi.schemers.org/srfi-89/">SRFI 89
      (Optional positional and named parameters)</a>, the constructor's API can
      be easily extended in a backward compatible way by other SRFIs and Scheme
      implementations.</p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Tue, 10 Jul 2007 12:00:00 -0800</pubDate></item><item><title>SRFI 91: Extended ports</title><link>https://srfi.schemers.org/srfi-91/srfi-91.html</link><guid>https://srfi.schemers.org/srfi-91</guid><description>SRFI 91 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI specifies an extension to the R5RS
      ports that supports several useful features: binary I/O and text I/O,
      bulk I/O, file opening attributes, and bidirectional ports. Binary I/O is
      provided through byte ports which are ports whose fundamental I/O unit is
      an 8 bit byte. Because characters can be encoded with bytes using a
      character encoding such as ISO 8859-1, UTF-8, and UTF-16BE, any byte port
      is also a character port (a port that supports the character level I/O of
      R5RS). A byte port's character encoding and various other attributes are
      specified when the port is opened. Because reasonable defaults exist,
      these attributes are specified using a named optional parameter syntax.
      All procedures which have the same name as in R5RS are compatible with
      R5RS but may provide additional functionality.</p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Tue, 10 Jul 2007 12:00:00 -0800</pubDate></item><item><title>SRFI 88: Keyword objects</title><link>https://srfi.schemers.org/srfi-88/srfi-88.html</link><guid>https://srfi.schemers.org/srfi-88</guid><description>SRFI 88 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines <i>keyword</i> objects, a
      data type similar to Scheme symbols. Keyword objects have the same
      lexical syntax as symbols but they must end in a colon. Moreover keyword
      objects are self-evaluating. Procedures for converting between strings
      and keyword objects (<code>string->keyword</code> and
      <code>keyword->string</code>) and a type predicate (<code>keyword?</code>) are
      defined. Finally this SRFI specifies the changes to the Scheme lexical
      syntax required to accomodate keywords.</p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Tue, 03 Jul 2007 12:00:00 -0800</pubDate></item><item><title>SRFI 92: ALAMBDA and ALAMBDA*</title><link>https://srfi.schemers.org/srfi-92/srfi-92.html</link><guid>https://srfi.schemers.org/srfi-92</guid><description>SRFI 92 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI introduces ALAMBDA and ALAMBDA*, each
      of which has two modes of operation:
      <ol>
        <li>it creates a procedure that checks actual
        arguments and takes optional arguments,
        </li><li>it returns a different procedure by checking
        each of actual arguments and the number of them.
      </li></ol><li></li></p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Mon, 09 Apr 2007 12:00:00 -0800</pubDate></item><item><title>SRFI 94: Type-Restricted Numerical Functions</title><link>https://srfi.schemers.org/srfi-94/srfi-94.html</link><guid>https://srfi.schemers.org/srfi-94</guid><description>SRFI 94 is now in <em>final</em> status.<blockquote>      <p>In the coding of numerial calculations in
      latent-typed languages it is good practice to assure that those
      calculations are using the intended number system. The most common number
      systems for programmatic calculations are the integers, reals, and
      complexes. This SRFI introduces 14 real-only and 3 integer-only variants
      of R5RS procedures to facilitate numerical type checking and
      declaration.</p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Tue, 30 Jan 2007 12:00:00 -0800</pubDate></item><item><title>SRFI 95: Sorting and Merging</title><link>https://srfi.schemers.org/srfi-95/srfi-95.html</link><guid>https://srfi.schemers.org/srfi-95</guid><description>SRFI 95 is now in <em>final</em> status.<blockquote>      <p>Sorting and Merging are useful operations
      deserving a common API.</p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Mon, 29 Jan 2007 12:00:00 -0800</pubDate></item><item><title>SRFI 80: Stream I/O</title><link>https://srfi.schemers.org/srfi-80/srfi-80.html</link><guid>https://srfi.schemers.org/srfi-80</guid><description>SRFI 80 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI defines an I/O layer for lazy, mostly
      functional buffered streams.
      </p><p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      </p><p>In particular, this layer provides
      <ul>
        <li>buffered reading and writing
        </li><li>arbitrary lookahead
        </li><li>dynamic redirection of input or
        output
        </li><li>binary and text I/O, mixed if needed
        </li><li>translated data streams
        </li><li>the ability to create I/O streams from
        arbitrary readers and writers
      </li></ul><li>
      <p>It builds on the Primitive I/O layer specified
      in <a href="https://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</p></li></p></blockquote></description><dc:creator>Michael Sperber</dc:creator><pubDate>Mon, 20 Nov 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 81: Port I/O</title><link>https://srfi.schemers.org/srfi-81/srfi-81.html</link><guid>https://srfi.schemers.org/srfi-81</guid><description>SRFI 81 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI defines an I/O layer similar in
      nature to the ports subsystem in R5RS, and provides conventional,
      imperative buffered input and output.
      </p><p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      </p><p>In particular, the subsystem fulfills the
      following requirements:
      <ul>
        <li>buffered reading and writing
        </li><li>binary and text I/O, mixed if needed
        </li><li>the ability to create arbitrary I/O ports
        from readers and writers
      </li></ul><li>
      <p>It builds on the Primitive I/O layer specified
      in <a href="https://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</p></li></p></blockquote></description><dc:creator>Michael Sperber</dc:creator><pubDate>Mon, 20 Nov 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 82: Stream Ports</title><link>https://srfi.schemers.org/srfi-82/srfi-82.html</link><guid>https://srfi.schemers.org/srfi-82</guid><description>SRFI 82 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI augments <a href="https://srfi.schemers.org/srfi-81/">SRFI 81
      (Port I/O)</a> by allowing ports to be constructed from streams as
      described in <a href="https://srfi.schemers.org/srfi-80/">SRFI 80 (Stream I/O)</a>.</p></blockquote></description><dc:creator>Michael Sperber</dc:creator><pubDate>Mon, 20 Nov 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 79: Primitive I/O</title><link>https://srfi.schemers.org/srfi-79/srfi-79.html</link><guid>https://srfi.schemers.org/srfi-79</guid><description>SRFI 79 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI defines a simple, primitive I/O
      subsystem for Scheme that is intended to function as the lowest layer of
      a more comprehensive suite of I/O layers. It provides unbuffered I/O, and
      is close to what a typical operating system offers. Thus, its interface
      is suitable for implementing high-throughput and zero-copy I/O.
      </p><p>The Primitive I/O layer also allows clients to
      implement custom data sources and sinks via a simple interface.
      </p><p>Moreover, this SRFI defines a condition
      hierarchy specifying common I/O-related exceptional situations.
      </p><p>The Primitive I/O layer only handles
      blocking-I/O. Non-blocking and selective I/O is left for another
      SRFI.
      </p><p>This I/O layer was designed in conjunction with
      two other layers that can be built on top of it: <a href="https://srfi.schemers.org/srfi-80/">SRFI
      80 (Stream I/O)</a> and <a href="https://srfi.schemers.org/srfi-81/">SRFI 81 (Port I/O)</a>.</p></blockquote></description><dc:creator>Michael Sperber</dc:creator><pubDate>Thu, 16 Nov 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 84: Universal Identifiers</title><link>https://srfi.schemers.org/srfi-84/srfi-84.html</link><guid>https://srfi.schemers.org/srfi-84</guid><description>SRFI 84 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI proposes a social convention to allow
      programmers to easily create short, simple Scheme symbols which are
      guaranteed to be universally unique: No other programmer also following
      this SRFI will accidentally create a symbol eq? to yours.
      </p><p>Universally unique symbols are useful to
      identify standards, languages, libraries, types, classes, and other
      resources.</p></blockquote></description><dc:creator>Andrew Wilcox</dc:creator><pubDate>Thu, 09 Nov 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 85: Recursive Equivalence Predicates</title><link>https://srfi.schemers.org/srfi-85/srfi-85.html</link><guid>https://srfi.schemers.org/srfi-85</guid><description>SRFI 85 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI defines two related equivalence
      predicates that are recursive, not just partial recursive: they terminate
      on all arguments. One of these predicates, <code>equiv?</code>, is
      consistent with the <code>equal?</code> procedure described in the R5RS:
      Whenever <code>equal?</code> terminates, <code>equiv?</code> returns the
      same value as <code>equal?</code>.</p></blockquote></description><dc:creator>William D Clinger</dc:creator><pubDate>Sat, 21 Oct 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 87: => in case clauses</title><link>https://srfi.schemers.org/srfi-87/srfi-87.html</link><guid>https://srfi.schemers.org/srfi-87</guid><description>SRFI 87 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes an extension to the
      <code>case</code> syntax to allow the <code>=></code> clauses as in
      <code>cond</code>.</p></blockquote></description><dc:creator>Chongkai Zhu</dc:creator><pubDate>Wed, 18 Oct 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 77: Preliminary Proposal for R6RS Arithmetic</title><link>https://srfi.schemers.org/srfi-77/srfi-77.html</link><guid>https://srfi.schemers.org/srfi-77</guid><description>SRFI 77 is now in <em>withdrawn</em> status.<blockquote>      <p>Scheme's arithmetic system was designed to
      allow a wide variety of implementations. After many years of
      implementation experience, however, most implementations now fall into a
      small number of categories, and the benefits of continued experimentation
      no longer justify the confusion and portability problems that have
      resulted from giving implementations so much freedom in this area.
      Moreover, the R5RS generic arithmetic is difficult to implement as
      efficiently as purely fixnum or purely flonum arithmetic. (Fixnum
      arithmetic is typically limited-precision integer arithmetic implemented
      using one or more representations that may be especially efficient on the
      executing machine; flonum arithmetic is typically limited-precision
      floating-point arithmetic using one or more representations that may be
      especially efficient on the executing machine.)
      </p><p>This SRFI is an effort to extend and clarify
      the R5RS arithmetic to make it more portable, more comprehensive, and
      enable faster programs.
      </p><p>Furthermore, one of us (Sperber) has argued
      that Scheme's arithmetic requires radical overhaul. The other (Clinger)
      agrees that revisions are needed. Whether these revisions qualify as
      radical is best left to the judgement of individual readers.
      </p><p>This SRFI proposes to revise section 6.2
      ("Numbers") of R5RS by:
      <ul>
        <li>requiring a Scheme implementation to provide
        the full tower, including exact rationals of arbitrary precision, exact
        rectangular complex numbers with rational real and imaginary parts, and
        inexact real and complex arithmetic
        </li><li>defining fixnum arithmetic (parameterized by
        precision)
        </li><li>defining flonum arithmetic
        (inexactly)
        </li><li>defining new procedures for performing exact
        arithmetic
        </li><li>defining new procedures for performing
        inexact arithmetic
        </li><li>describing the external representation and
        semantics of 0.0, -0.0, infinities and NaNs for systems that implement
        inexact real arithmetic using IEEE binary floating point&lt;?
        </li><li>changing the specification of
        <code>eqv?</code> to behave more sensibly with inexact numbers
        </li><li>defining Scheme's real numbers to be the
        complex numbers whose imaginary part is an exact zero
        </li><li>adding an external representation for
        inexact numbers that expresses the precision of a binary floating point
        representation
        </li><li>defining procedures for some new operations,
        including integer division and remainder on real numbers, and bitwise
        operations,
        </li><li>restricting the domains of some R5RS
        procedures
        </li><li>clarifying the semantics of some R5RS
        procedures
        </li><li>possibly changing the semantics of some R5RS
        procedures
      </li></ul><li></li></p></blockquote></description><dc:creator>William D Clinger and Michael Sperber</dc:creator><pubDate>Wed, 13 Sep 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 83: R6RS Library Syntax</title><link>https://srfi.schemers.org/srfi-83/srfi-83.html</link><guid>https://srfi.schemers.org/srfi-83</guid><description>SRFI 83 is now in <em>withdrawn</em> status.<blockquote>      <p>The module system presented here is designed to
      let programmers share libraries, i.e., code that is intended to be
      incorporated into larger programs, and especially into programs that use
      library code from multiple sources. The module system supports macro
      definitions within modules, allows macro exports, and distinguishes the
      phases in which definitions and imports are needed. This SRFI defines a
      standard notation for libraries, a semantics for library expansion and
      execution, and a simple format for sharing libraries.
      <*COMMENT*> ISSUES </*COMMENT*></p></blockquote></description><dc:creator>Matthew Flatt and Kent Dybvig</dc:creator><pubDate>Wed, 13 Sep 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 93: R6RS Syntax-Case Macros</title><link>https://srfi.schemers.org/srfi-93/srfi-93.html</link><guid>https://srfi.schemers.org/srfi-93</guid><description>SRFI 93 is now in <em>withdrawn</em> status.<blockquote>      <p>The syntactic abstraction system described here
      extends the R5RS macro system with support for writing low-level macros
      in a high-level style, with automatic syntax checking, input
      destructuring, output restructuring, maintenance of lexical scoping and
      referential transparency (hygiene), and support for controlled identifier
      capture, with constant expansion overhead. Because it does not require
      literals, including quoted lists or vectors, to be copied or even
      traversed, it preserves sharing and cycles within and among the constants
      of a program. It also supports source-object correlation, i.e., the
      maintenance of ties between the original source code and expanded output,
      allowing implementations to provide source-level support for debuggers
      and other tools.</p></blockquote></description><dc:creator>Kent Dybvig</dc:creator><pubDate>Wed, 23 Aug 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 86: MU and NU simulating VALUES &amp; CALL-WITH-VALUES, and their related LET-syntax</title><link>https://srfi.schemers.org/srfi-86/srfi-86.html</link><guid>https://srfi.schemers.org/srfi-86</guid><description>SRFI 86 is now in <em>final</em> status.<blockquote>      <p>Unlike the
      <code>values</code>/<code>call-with-values</code> mechanism of R5RS, this
      SRFI uses an explicit representation for multiple return values as a
      single value, namely a procedure. Decomposition of multiple values is
      done by simple application. Each of the two macros, <code>mu</code> and
      <code>nu</code>, evaluates to a procedure that takes one procedure
      argument. The <code>mu</code> and <code>nu</code> can be compared with
      <code>lambda</code>. While <code>lambda</code> expression that consists
      of &lt;formals> and &lt;body> requires some actual arguments later
      when the evaluated <code>lambda</code> expression is called,
      <code>mu</code> and <code>nu</code> expressions that consist of
      &lt;expression>s corresponding to actual arguments of
      <code>lambda</code> require &lt;formals> and &lt;body>, that is, an
      evaluated <code>lambda</code> expression, later when the evaluated
      <code>mu</code> and <code>nu</code> expressions are called.
      </p><p>This SRFI also introduces new
      <code>let</code>-syntax depending on <code>mu</code> and <code>nu</code>
      to manipulate multiple values, <code>alet</code> and <code>alet*</code>
      that are compatible with <code>let</code> and <code>let*</code> of R5RS
      in single value bindings. They also have a binding form making use of
      <code>values</code> and <code>call-with-values</code> to handle multiple
      values. In addition, they have several new binding forms for useful
      functions such as escape, recursion, etc.</p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Tue, 20 Jun 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 64: A Scheme API for test suites</title><link>https://srfi.schemers.org/srfi-64/srfi-64.html</link><guid>https://srfi.schemers.org/srfi-64</guid><description>SRFI 64 is now in <em>final</em> status.<blockquote>      <p>This defines an API for writing <dfn>test
      suites</dfn>, to make it easy to portably test Scheme APIs, libraries,
      applications, and implementations. A test suite is a collection of
      <dfn>test cases</dfn> that execute in the context of a
      <dfn>test-runner</dfn>. This specifications also supports writing new
      test-runners, to allow customization of reporting and processing the
      result of running test suites.</p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Sun, 18 Jun 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 75: R6RS Unicode data</title><link>https://srfi.schemers.org/srfi-75/srfi-75.html</link><guid>https://srfi.schemers.org/srfi-75</guid><description>SRFI 75 is now in <em>withdrawn</em> status.<blockquote>      <p>Unicode is a widespread universal character
      code that supports most of the world's (natural) languages. The
      extensions to Scheme specified in this SRFI concern the support of
      Unicode in Scheme's character, string, and symbol datatypes. This SRFI
      does not (fully) specify how I/O of Unicode data is performed or how
      Scheme source code is encoded in files; these aspects are left for other
      SRFIs to specify.</p></blockquote></description><dc:creator>Matthew Flatt and Marc Feeley</dc:creator><pubDate>Sat, 27 May 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 76: R6RS Records</title><link>https://srfi.schemers.org/srfi-76/srfi-76.html</link><guid>https://srfi.schemers.org/srfi-76</guid><description>SRFI 76 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI describes abstractions for creating
      new data types representing records - data structures with named fields.
      This SRFI comes in four parts:
      <ul>
        <li>a procedural layer for creating and
        manipulating record types and record instances
        </li><li>an explicit-naming syntactic layer for
        defining the various entities associated with a record type -
        construction procedure, predicate, field accessors, mutators, etc. - at
        once
        </li><li>an implicit-naming syntactic layer built on
        top of the explicit-naming syntactic layer, which chooses the names for
        the various products based on the names of the record type and
        fields
        </li><li>a set of reflection procedures
      </li></ul><li></li></p></blockquote></description><dc:creator>Will Clinger, R. Kent Dybvig, Michael Sperber, and Anton van Straaten</dc:creator><pubDate>Mon, 24 Apr 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 78: Lightweight testing</title><link>https://srfi.schemers.org/srfi-78/srfi-78.html</link><guid>https://srfi.schemers.org/srfi-78</guid><description>SRFI 78 is now in <em>final</em> status.<blockquote>      <p>A simple mechanism is defined for testing
      Scheme programs. As a most primitive example, the expression
      <pre>
   (check (+ 1 1) => 3)
</pre>evaluates the expression <code>(+ 1
1)</code> and compares the result with the expected result 3 provided after the
syntactic keyword <code>=></code>. Then the outcome of this comparison is
reported in human-readable form by printing a message of the form
      <pre>
   (+ 1 1) => 2 ; *** failed ***
   ; expected result: 3
</pre>Moreover, the outcome of any executed check
is recorded in a global state counting the number of correct and failed checks
and storing the first failed check. At the end of a file, or at any other
point, the user can print a summary using <code>check-report</code>.
      </p><p>In addition to the simple test above, it is
      also possible to execute a parametric sequence of checks. Syntactically,
      this takes the form of an eager comprehension in the sense of <a href="https://srfi.schemers.org/srfi-42/">SRFI 42</a> [5]. For example,
      <pre>
   (check-ec (:range e 100)
             (:let x (expt 2.0 e))
             (= (+ x 1) x) => #f (e x))
</pre>This statement runs the variable <code>
      e</code> through {0..99} and for each binding defines <code>x</code> as
      <code>(expt 2.0 e)</code>. Then it is checked if <code>(+ x 1)</code> is
      equal to <code>x</code>, and it is expected that this is not the case
      (i.e. expected value is <code>#f</code>). The trailing <code>(e x)</code>
      tells the reporting mechanism to print the values of both <code>e</code>
      and <code>x</code> in case of a failed check. The output could look like
      this:
      <pre>
   (let ((e 53) (x 9007199254740992.0)) (= (+ x 1) x)) => #t ; *** failed ***
    ; expected result: #f
</pre>The specification of bindings to report,
<code>(e x)</code> in the example, is optional but very informative. Other
features of this SRFI are:
      <ul>
        <li>A way to specify a different equality
        predicate (default is <code>equal?</code>).
        </li><li>Controlling the amount of reporting being
        printed.
        </li><li>Switching off the execution and reporting of
        checks entriely.
        </li><li>Retrieving a boolean if all checks have been
        executed and passed.
      </li></ul><li></li></p></blockquote></description><dc:creator>Sebastian Egner</dc:creator><pubDate>Mon, 06 Mar 2006 12:00:00 -0800</pubDate></item><item><title>SRFI 50: Mixing Scheme and C</title><link>https://srfi.schemers.org/srfi-50/srfi-50.html</link><guid>https://srfi.schemers.org/srfi-50</guid><description>SRFI 50 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI describes an interface for calling C
      functions from Scheme, calling Scheme functions from C, and allocating
      storage in the Scheme heap. Scheme manages stub functions in C that
      negotiate between the calling conventions of Scheme and C and the memory
      allocation policies of both worlds.
      </p><p>The following facilities are available for
      interfacing between Scheme and C:
      <ul>
        <li>Scheme code can call C functions.
        </li><li>The external interface provides full
        introspection for all Scheme objects. External code may inspect,
        modify, and allocate Scheme objects arbitrarily.
        </li><li>External code may signal errors to the
        Scheme system.
        </li><li>External code may call back into Scheme.
        Scheme correctly unrolls the process stack on non-local exits.
        </li><li>External modules may register bindings of
        names to values with a central registry accessible from Scheme.
        Conversely, Scheme code can register shared bindings for access by C
        code.
      </li></ul><li>
      <p>The interface is closely based on that of
      <a href="http://www.s48.org/">Scheme 48</a> and <a href="http://www.scsh.net/">scsh</a>.</p></li></p></blockquote></description><dc:creator>Richard Kelsey and Michael Sperber</dc:creator><pubDate>Tue, 20 Dec 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 66: Octet Vectors</title><link>https://srfi.schemers.org/srfi-66/srfi-66.html</link><guid>https://srfi.schemers.org/srfi-66</guid><description>SRFI 66 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines a set of procedures for
      creating, accessing, and manipulating uniform vectors of octets.</p></blockquote></description><dc:creator>Michael Sperber</dc:creator><pubDate>Thu, 15 Dec 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 74: Octet-Addressed Binary Blocks</title><link>https://srfi.schemers.org/srfi-74/srfi-74.html</link><guid>https://srfi.schemers.org/srfi-74</guid><description>SRFI 74 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines a set of procedures for
      creating, accessing, and manipulating octet-addressed blocks of binary
      data, in short, <i>blobs</i>. The SRFI provides access primitives for
      fixed-length integers of arbitrary size, with specified endianness, and a
      choice of unsigned and two's complement representations.</p></blockquote></description><dc:creator>Michael Sperber</dc:creator><pubDate>Thu, 15 Dec 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 73: Exact Infinities</title><link>https://srfi.schemers.org/srfi-73/srfi-73.html</link><guid>https://srfi.schemers.org/srfi-73</guid><description>SRFI 73 is now in <em>withdrawn</em> status.<blockquote>      <p>Many Scheme implementations support exact
      arbitrary-precision integer arithmetic as well as exact rational number
      computation. This SRFI extends the rational numbers of R5RS by adding two
      rational infinities (1/0, -1/0).
      </p><p>With infinities added to the number system we
      find that division by zero "works". It lets initialization of variables
      precede bounds checks and gives flexibility in placement of those
      checks.</p></blockquote></description><dc:creator>Chongkai Zhu</dc:creator><pubDate>Wed, 30 Nov 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 68: Comprehensive I/O</title><link>https://srfi.schemers.org/srfi-68/srfi-68.html</link><guid>https://srfi.schemers.org/srfi-68</guid><description>SRFI 68 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI defines a comprehensive I/O subsystem
      for Scheme with three layers, where each layer is built on top of the one
      below it:
      <ul>
        <li>The lowest, primitive layer provides
        unbuffered I/O, and is close to what a typical operating system
        offers.
        </li><li>The middle layer builds on lazy, mostly
        functional buffered streams.
        </li><li>The upper layer is similar in nature to the
        ports subsystem in R5RS, and provides conventional, imperative buffered
        input and output.
      </li></ul><li>
      <p>The layer architecture is similar to the upper
      three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis
      Library</a>.
      </p><p>In particular, the subsystem provides
      <ul>
        <li>buffered reading and writing
        </li><li>arbitrary lookahead at the streams
        level
        </li><li>dynamic redirection of input or output at
        the ports level
        </li><li>binary and text I/O, mixed if needed
        </li><li>translated data streams
        </li><li>unbuffered I/O at the primitive layer
        </li><li>the ability to create arbitrary I/O streams,
        such as to and from blobs and strings
      </li></ul><li>
      <p>The subsystem does <em>not</em> provide
      <ul>
        <li>formatted I/O
        </li><li>non-blocking or selective I/O
        </li><li>portable filenames, or any functionality for
        manipulating filenames
        </li><li>filesystem operations
        </li><li>socket I/O
        </li><li>extremely high-throughput or zero-copy
        I/O
      </li></ul><li>
      <p>However, all of these could be added on top of
      one or several of the layers specified in this SRFI.</p></li></p></li></p></li></p></blockquote></description><dc:creator>Michael Sperber</dc:creator><pubDate>Tue, 29 Nov 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 56: Binary I/O</title><link>https://srfi.schemers.org/srfi-56/srfi-56.html</link><guid>https://srfi.schemers.org/srfi-56</guid><description>SRFI 56 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI extends Scheme with procedures to
      read and write binary data to and from ports, including utility
      procedures for writing various integer and floating point values in both
      big and little endian formats. Predicates are provided to test if binary
      I/O is allowed on a port, along with new procedures for creating such
      ports.</p></blockquote></description><dc:creator>Alex Shinn</dc:creator><pubDate>Mon, 31 Oct 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 72: Hygienic macros</title><link>https://srfi.schemers.org/srfi-72/srfi-72.html</link><guid>https://srfi.schemers.org/srfi-72</guid><description>SRFI 72 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes a procedural macro proposal
      for Scheme with the following features:
      <ul>
        <li>
          <h3>Improved hygiene:</h3>
          <p>We argue that conventional hygiene
          algorithms may lead to accidental variable capture errors in
          procedural macros. We propose an improved algorithm that avoids these
          problems.
        <li>
          <h3>Reflective tower:</h3>
          <p>We specify a reflective tower of arbitrary
          height, and propose a refinement of lexical scoping that takes into
          account the phase of use of an identifier in determining its
          meaning.
        <li>
          <h3>Syntax-case:</h3>
          <p>In the current proposal, the
          <code>syntax-case</code> form is expressible as a macro in terms of a
          simpler set of primitives and is specified as library syntax.
        <li>
          <h3>Procedural interface:</h3>
          <p>The primitive interface for manipulating
          compound syntax objects consists of procedures rather than special
          forms. In particular, the traditional abstractions <code>car</code>,
          <code>cdr</code>, <code>cons</code> , <code>...</code> can be used on syntactic
          data.
        <li>
          <h3>Fast hygiene algorithm:</h3>
          <p>The reference implementation documents a
          fast imperative hygiene algorithm that is eager and linear in
          expression size.
        <li>
          <h3>Capturing identifiers:</h3>
          <p>A primitive
          <code>make-capturing-identifier</code> is provided for intentional
          variable capture and for building expansion-time fluid binding
          constructs.
      <ul></ul></p></li></p></li></p></li></p></li></p></li></p></li></ul></p></blockquote></description><dc:creator>André van Tonder</dc:creator><pubDate>Wed, 21 Sep 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 69: Basic hash tables</title><link>https://srfi.schemers.org/srfi-69/srfi-69.html</link><guid>https://srfi.schemers.org/srfi-69</guid><description>SRFI 69 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines basic hash tables. Hash
      tables are widely recognised as a fundamental data structure for a wide
      variety of applications. A hash table is a data structure that:
      <ol>
        <li>provides a mapping from some set of keys to
        some set of values associated to those keys
        </li><li>has no intrinsic order for the (key, value)
        associations it contains
        </li><li>supports in-place modification as the
        primary means of setting the contents of a hash table
        </li><li>provides key lookup and destructive update
        in amortised constant time, provided that a good hash function is
        used.
      </li></ol><li>
      <p>This SRFI aims to accomplish these
      goals:
      <ol>
        <li>to provide a consistent, generic and widely
        applicable API for hash tables
        </li><li>to improve code portability by providing a
        standard hash table facility with guaranteed behaviour
        </li><li>to help the programmer by defining utility
        routines that account for the most common situations of using hash
        tables.
      </li></ol><li></li></p></li></p></blockquote></description><dc:creator>Panu Kalliokoski</dc:creator><pubDate>Wed, 14 Sep 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 67: Compare Procedures</title><link>https://srfi.schemers.org/srfi-67/srfi-67.html</link><guid>https://srfi.schemers.org/srfi-67</guid><description>SRFI 67 is now in <em>final</em> status.<blockquote>      <p>This SRFI can be seen as an extension of the
      standard procedures <code>=</code>, <code>&lt;</code>, <code>char&lt;?</code> etc. of
      R<sup>5</sup>RS -- or even as a replacement. The primary design aspect in
      this SRFI is the separation of <em>representing</em> a total order and
      <em>using it.</em> For representing the order, we have chosen for truly
      3-way comparisons. For using it we provide an extensive set of
      operations, each of which accepts a procedure used for comparison. Since
      these compare procedures are often optional, comparing built-in types is
      as convenient as R<sup>5</sup>RS , sometimes more convenient: For
      example, testing if the integer index <em>i</em> lies in the integer
      range {0, <code>...</code>, <em>n</em> <code>-</code> 1} can be written as
      <code>(&lt;=/&lt;? 0 i n)</code>, implicitly invoking
      <code>default-compare</code>.
      </p><p>As soon as new total orders are required, the
      infrastructure provided by this SRFI is far more convenient and often
      even more efficient than building each total order from scratch.
      </p><p>Moreover, in case Scheme users and implementors
      find this mechanism useful and adopt it, the benefit of having a uniform
      interface to total orders to be used in data structures will manifest
      itself. Most concretely, a new sorting procedure in the spirit of this
      SRFI would have the interface <code>(my-sort [ <i>compare</i> ]
      <i>xs</i>)</code>, using <code>default-compare</code> if the optional
      <i>compare</i> was not provided. Then <code>my-sort</code> could be defined
      using the entire infrastructure of this SRFI: Efficient 2- and 3-way
      branching, testing for chains and pairwise inequality, min/max, and
      general order statistics.</p></blockquote></description><dc:creator>Sebastian Egner and Jens Axel Søgaard</dc:creator><pubDate>Sun, 11 Sep 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 70: Numbers</title><link>https://srfi.schemers.org/srfi-70/srfi-70.html</link><guid>https://srfi.schemers.org/srfi-70</guid><description>SRFI 70 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes text to replace section 6.2
      "Numbers" of R5RS in order to extend its capabilities, correct errors in
      its specification, make it more explicit about limitations of precision
      and magnitude, and improve portability between implementations. More
      specifically, this new text:
      <ul>
        <li>incorporates an inexact real positive
        infinity and an inexact real negative infinity,
        </li><li>extends number syntax to incorporate inexact
        real infinities,
        </li><li>adapts Common-Lisp semantics for
        <samp>`expt'</samp> and extends them to include inexact real
        infinities,
        </li><li>corrects the description of
        <samp>`sqrt'</samp>,
        </li><li>sharpens the distinction between exact and
        inexact numbers,
        </li><li>removes a contradiction related to
        exactness,
        </li><li>extends <samp>`gcd'</samp> and
        <samp>`lcm'</samp> to exact rational numbers,
        </li><li>extends <samp>`quotient'</samp>,
        <samp>`modulo'</samp>, and <samp>`remainder'</samp> to finite real
        numbers,
        </li><li>clarifies the behavior of
        <samp>`inexact->exact'</samp> applied to an exact argument,
        </li><li>clarifies the behavior of
        <samp>`exact->inexact'</samp> applied to an inexact argument,
        </li><li>adds convenience procedures
        <samp>`exact-round'</samp>, <samp>`exact-ceiling'</samp>,
        <samp>`exact-floor'</samp>, and <samp>`exact-truncate'</samp>,
        </li><li>and adds examples.
      </li></ul><li></li></p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Sun, 11 Sep 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 71: Extended LET-syntax for multiple values</title><link>https://srfi.schemers.org/srfi-71/srfi-71.html</link><guid>https://srfi.schemers.org/srfi-71</guid><description>SRFI 71 is now in <em>final</em> status.<blockquote>      <p>This SRFI is a proposal for extending
      <code>let</code>, <code>let*</code>, and <code>letrec</code> for
      receiving multiple values. The syntactic extension is fully compatible
      with the existing syntax. It is the intention that single-value bindings,
      i.e. <code>(let ((var expr)) ...)</code>, and multiple-value binding can
      be mixed freely and conveniently.
      </p><p>The most simple form of the new syntax is best
      explained by an example:
      <pre>
(define (quo-rem x y)
  (values (quotient x y) (remainder x y)))

(define (quo x y)
  (let ((q r (quo-rem x y)))
    q))
</pre>
      </p><p>The procedure <code>quo-rem</code> delivers two
      values to its continuation. These values are received as <code>q</code>
      and <code>r</code> in the <code>let</code>-expression of the procedure
      <code>quo</code>. In other words, the syntax of <code>let</code> is
      extended such that several variables can be specified---and these
      variables receive the values delivered by the expression <code>(quo-rem x
      y)</code>.
      </p><p>The syntax of <code>let</code> is further
      extended to cases in which a rest argument receives the list of all
      residual values. Again by example,
      <pre>
(let (((values y1 y2 . y3+) (foo x)))
   body)
</pre>In this example, <code>values</code> is a
syntactic keyword indicating the presence of multiple values to be received,
and <code>y1</code>, <code>y2</code>, and <code>y3+</code>, resp., are
variables bound to the first value, the second value, and the list of the
remaining values, resp., as produced by <code>(foo x)</code>. The syntactic
keyword <code>values</code> allows receiving all values as in <code>(let
(((values . xs) (foo x))) body)</code>. It also allows receiving no values at
all as in <code>(let (((values) (for-each foo list))) body)</code>.<br>
      <br>
      </p><p>A common application of binding multiple values
      is decomposing data structures into their components. This mechanism is
      illustrated in its most primitive form as follows: The procedure
      <code>uncons</code> (defined below) decomposes a pair <code>x</code> into
      its car and its cdr and delivers them as two values to its continuation.
      Then an extended <code>let</code> can receive these values:
      <pre>
(let ((car-x cdr-x (uncons x)))
  (foo car-x cdr-x))
</pre>
      </p><p>Of course, for pairs this method is probably
      neither faster nor clearer than using the procedures <code>car</code> and
      <code>cdr</code>. However, for data structures doing substantial work
      upon decomposition this is different: Extracting the element of highest
      priority from a priority queue, while at the same time constructing the
      residual queue, can both be more efficient and more convenient than doing
      both operations independently. In fact, the <code>quo-rem</code> example
      illustrates this point already as both quotient and remainder are
      probably computed by a common exact division algorithm. (And often
      caching is used to avoid executing this algorithm twice as often as
      needed.)
      </p><p>As the last feature of this SRFI, a mechanism
      is specified to store multiple values in heap-allocated data structures.
      For this purpose, <code>values->list</code> and
      <code>values->vector</code> construct a list (a vector, resp.) storing
      all values delivered by evaluating their argument expression. Note that
      these operations cannot be procedures.</p></blockquote></description><dc:creator>Sebastian Egner</dc:creator><pubDate>Fri, 12 Aug 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 49: Indentation-sensitive syntax</title><link>https://srfi.schemers.org/srfi-49/srfi-49.html</link><guid>https://srfi.schemers.org/srfi-49</guid><description>SRFI 49 is now in <em>final</em> status.<blockquote>      <p>This SRFI descibes a new syntax for Scheme,
      called I-expressions, whith equal descriptive power as S-expressions. The
      syntax uses indentation to group expressions, and has no special cases
      for semantic constructs of the language. It can be used both for program
      and data input.
      </p><p>It also allows mixing S-expressions and
      I-expressions freely, giving the programmer the ability to layout the
      code as to maximize readability.</p></blockquote></description><dc:creator>Egil Möller</dc:creator><pubDate>Fri, 22 Jul 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 61: A more general cond clause</title><link>https://srfi.schemers.org/srfi-61/srfi-61.html</link><guid>https://srfi.schemers.org/srfi-61</guid><description>SRFI 61 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes an extension to the
      <code>cond</code> syntax to allow a more general clause, one that allows
      binding the results of tests as in the <code>=></code> clauses and
      user-defined meaning of the success &amp; failure of tests.</p></blockquote></description><dc:creator>Taylor Campbell</dc:creator><pubDate>Thu, 21 Jul 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 62: S-expression comments</title><link>https://srfi.schemers.org/srfi-62/srfi-62.html</link><guid>https://srfi.schemers.org/srfi-62</guid><description>SRFI 62 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes a simple extension to
      Scheme's lexical syntax that allows individual S-expressions to be made
      into comments, ignored by the reader. This contrasts with the standard
      Lisp semicolon comments, which make the reader ignore the remainder of
      the line, and the slightly less common block comments, as <a href="https://srfi.schemers.org/srfi-30/srfi-30.html">SRFI
      30</a> defines: both of these mechanisms comment out slices of text, not
      S-expressions.</p></blockquote></description><dc:creator>Taylor Campbell</dc:creator><pubDate>Thu, 21 Jul 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 65: define-immutable: A Syntax to Define Identifiers With Immutable Values</title><link>https://srfi.schemers.org/srfi-65/srfi-65.html</link><guid>https://srfi.schemers.org/srfi-65</guid><description>SRFI 65 is now in <em>withdrawn</em> status.<blockquote>      <p>The <code>define-immutable</code> form defines an
      identifier whose value never changes.
      </p><p>The expression part of the definition is
      evaluated lazily: it is not evaluated unless and until the identifier is
      evaluated. This permits an immutable definition to use other definitions
      in more ways than is possible when using <code>define</code> in internal
      definitions.
      </p><p>A series of immutable definitions have simple
      semantics, making them easy to program and understand.
      <pre>
    (let ()
      (define-immutable x (+ z 5))
      (define-immutable y (/ 100 4))
      (define-immutable z (add-10 y))
      (define-immutable add-10 (add-n 10))
      (define-immutable (add-n n)
        (lambda (x)
          (+ n x)))
      x)
  =>
    40
</pre></p></blockquote></description><dc:creator>Andrew Wilcox</dc:creator><pubDate>Tue, 17 May 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 63: Homogeneous and Heterogeneous Arrays</title><link>https://srfi.schemers.org/srfi-63/srfi-63.html</link><guid>https://srfi.schemers.org/srfi-63</guid><description>SRFI 63 is now in <em>final</em> status.<blockquote>      <p>The SRFI, which is to supersede <a href="https://srfi.schemers.org/srfi-47/">SRFI-47</a>, "Array",
      <ul>
        <li>synthesizes array concepts from Common-Lisp
        and Alan Bawden's "array.scm";
        </li><li>incorporates all the uniform vector types
        from <a href="https://srfi.schemers.org/srfi-4/">SFRI-4</a> "Homogeneous numeric vector
        datatypes";
        </li><li>adds a boolean uniform array type;
        </li><li>adds 16.bit and 128.bit floating-point
        uniform-array types;
        </li><li>adds decimal floating-point uniform-array
        types; and
        </li><li>adds array types of (dual) floating-point
        complex numbers.
      </li></ul><li>Multi-dimensional arrays subsume homogeneous
      vectors as the one-dimensional case, obviating the need for SRFI-4.<br>
      <br>
      <p>SRFI-58 gives a read/write invariant syntax for
      the homogeneous and heterogeneous arrays described here.</p></li></p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Wed, 27 Apr 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 58: Array Notation</title><link>https://srfi.schemers.org/srfi-58/srfi-58.html</link><guid>https://srfi.schemers.org/srfi-58</guid><description>SRFI 58 is now in <em>final</em> status.<blockquote>      <p><a href="https://srfi.schemers.org/srfi-47/">SRFI-47</a> and its
      successor <a href="https://srfi.schemers.org/srfi-63/">SRFI-63</a> provide both homogeneous numeric
      and heterogeneous multidimensional arrays which subsume Scheme vectors.
      The notation presented here builds upon Common-Lisp array syntax to
      represent heterogeneous arrays; and introduces a new Scheme-based
      notation for denoting homogeneous numeric arrays.</p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Tue, 08 Mar 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 59: Vicinity</title><link>https://srfi.schemers.org/srfi-59/srfi-59.html</link><guid>https://srfi.schemers.org/srfi-59</guid><description>SRFI 59 is now in <em>final</em> status.<blockquote>      <p>A vicinity is a descriptor for a place in the
      file system. Vicinities hide from the programmer the concepts of host,
      volume, directory, and version. Vicinities express only the concept of a
      file environment where a file name can be resolved to a file in a system
      independent manner.
      </p><p>All of these procedures are file-system
      dependent. Use of these vicinity procedures can make programs file-system
      <em>in</em>dependent.</p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Tue, 08 Mar 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 60: Integers as Bits</title><link>https://srfi.schemers.org/srfi-60/srfi-60.html</link><guid>https://srfi.schemers.org/srfi-60</guid><description>SRFI 60 is now in <em>final</em> status.<blockquote>      <p>Treating integers as two's-complement strings
      of bits is an arcane but important domain of computer science. It is used
      for:
      <ul>
        <li>hashing;
        </li><li>Galois-field[2] calculations of
        error-detecting and error-correcting codes;
        </li><li>cryptography and ciphers;
        </li><li>pseudo-random number generation;
        </li><li>register-transfer-level modeling of digital
        logic designs;
        </li><li>Fast-Fourier transforms;
        </li><li>packing and unpacking numbers in persistant
        data structures;
        </li><li>space-filling curves with applications to
        dimension reduction and sparse multi-dimensional database indexes;
        and
        </li><li>generating approximate seed values for
        root-finders and transcendental function algorithms.
      </li></ul><li></li></p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Tue, 08 Mar 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 57: Records</title><link>https://srfi.schemers.org/srfi-57/srfi-57.html</link><guid>https://srfi.schemers.org/srfi-57</guid><description>SRFI 57 is now in <em>final</em> status.<blockquote>      <p>We describe a syntax for defining record types.
      A predicate, constructor, and field accessors and modifiers may be
      specified for each record type. We also introduce a syntax for declaring
      record type schemes, representing families of record types that share a
      set of field labels. A polymorphic predicate and polymorphic field
      accessors and modifiers may be specified for each record type scheme. A
      syntax is provided for constructing records by field label, for in-place
      and for functional record update, and for composing records.</p></blockquote></description><dc:creator>André van Tonder</dc:creator><pubDate>Mon, 07 Mar 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 46: Basic Syntax-rules Extensions</title><link>https://srfi.schemers.org/srfi-46/srfi-46.html</link><guid>https://srfi.schemers.org/srfi-46</guid><description>SRFI 46 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes two extensions to the
      R5RS<sup>1</sup> <code>syntax-rules</code> pattern language: the first
      allows <code>syntax-rules</code> macros to generate macros, where the
      macro-generated macros use ellipsis that is not used by the
      macro-generating macros; the second allows for 'tail patterns.'</p></blockquote></description><dc:creator>Taylor Campbell</dc:creator><pubDate>Mon, 28 Feb 2005 12:00:00 -0800</pubDate></item><item><title>SRFI 55: require-extension</title><link>https://srfi.schemers.org/srfi-55/srfi-55.html</link><guid>https://srfi.schemers.org/srfi-55</guid><description>SRFI 55 is now in <em>final</em> status.<blockquote>      <p>This SRFI specifies an extremely simple
      facility for making an extension or library available to a Scheme
      toplevel environment.</p></blockquote></description><dc:creator>Felix L. Winkelmann and D.C. Frost</dc:creator><pubDate>Fri, 05 Nov 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 43: Vector library</title><link>https://srfi.schemers.org/srfi-43/srfi-43.html</link><guid>https://srfi.schemers.org/srfi-43</guid><description>SRFI 43 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes a comprehensive and complete
      library of vector operations accompanied by a freely available and
      complete reference implementation. The reference implementation is
      unencumbered by copyright, and useable with no modifications on any
      Scheme system that is R5RS-compliant. It also provides several hooks for
      implementation-specific optimization as well.
      </p><p>Because this SRFI is more of a library or
      module specification than a request for additions to readers or any other
      internal implementation detail, in an implementation that supports a
      module or structure or package or library or unit (et cetera) systems,
      these procedures should be contained in a module / structure / package /
      library / unit called <code>vector-lib</code>.</p></blockquote></description><dc:creator>Taylor Campbell</dc:creator><pubDate>Tue, 26 Oct 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 53: Syntactic computations with computation-rules</title><link>https://srfi.schemers.org/srfi-53/srfi-53.html</link><guid>https://srfi.schemers.org/srfi-53</guid><description>SRFI 53 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI provides a portable framework for
      writing complex high-level macros that perform nontrivial computations
      during expansion.</p></blockquote></description><dc:creator>André van Tonder</dc:creator><pubDate>Mon, 06 Sep 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 54: Formatting</title><link>https://srfi.schemers.org/srfi-54/srfi-54.html</link><guid>https://srfi.schemers.org/srfi-54</guid><description>SRFI 54 is now in <em>final</em> status.<blockquote>      <p>This SRFI introduces the CAT procedure that
      converts any object to a string. It takes one object as the first
      argument and accepts a variable number of optional arguments, unlike the
      procedure called FORMAT.</p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Thu, 24 Jun 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 52: Permitting and Supporting Extended Character Sets</title><link>https://srfi.schemers.org/srfi-52/srfi-52.html</link><guid>https://srfi.schemers.org/srfi-52</guid><description>SRFI 52 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI describes how to modify the
      <i>Revised Report</i> (<a href="http://www.schemers.org/Documents/Standards/R5RS/">R5RS</a>) in order to
      enable conforming implementations to use an extended character set such
      as (but not limited to) <a href="http://www.unicode.org">Unicode</a>.
      </p><p>Changes to some requirements of the report are
      recommended. Currently, the <i>Revised Report</i> contains requirements
      which are difficult or impossible to satisfy with some extended character
      sets.
      </p><p>New required procedures are proposed,
      specified, and included in the reference implementation. These procedures
      enable portable Scheme programs to manipulate Scheme source texts and
      source data accurately, even in implementations using extended character
      sets.
      </p><p>This SRFI concludes with some suggestions for
      implementors interested in providing good Unicode support, using these
      suggestions to illustrate how the proposed changes to the <i>Revised
      Report</i> can "play out" in Unicode-based Scheme.
      </p><p>This SRFI does <b>not</b> attempt to provide a
      comprehensive library for global text processing. For example, one issue
      in global text processing is the need for linguistically-sensitive,
      locale-sensitive procedures for sorting strings. Such procedures are
      beyond the scope of this SRFI. On the other hand, by making Scheme
      compatible with extended character sets, this SRFI is a step in the
      direction of permitting global text processing standard libraries to be
      developed in a form portable across all conforming
      implementations.
      </p><p>This SRFI does <b>not</b> propose that
      implementations be required to support Unicode or any other extended
      character set. It does not specify a representation for Unicode
      characters or strings. It <b>does</b> revise the specifications of the
      report so that <code>char?</code> values <i>may be</i> Unicode (or other)
      characters.
      </p><p>The reference implementation included should
      prove to be easily ported to and effective for all ASCII-only
      implementations and for many implementations using an 8-bit character set
      which is an extension of ASCII (it will require very minor modifications
      for each particular implementation). Other implementations may need to
      use a different implementation.</p></blockquote></description><dc:creator>Thomas Lord</dc:creator><pubDate>Thu, 17 Jun 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 47: Array</title><link>https://srfi.schemers.org/srfi-47/srfi-47.html</link><guid>https://srfi.schemers.org/srfi-47</guid><description>SRFI 47 is now in <em>final</em> status.<blockquote>      <p>"slib/array.scm" synthesizes array ideas from
	Common-Lisp and Alan Bawden with homogeneous vector ideas from <a href="https://srfi.schemers.org/srfi-4/">SRFI-4</a>
	and <a href="http://swissnet.ai.mit.edu/~jaffer/SCM">SCM</a>. The result portably
      integrates homogeneous and heterogeneous arrays into Scheme.</p></blockquote></description><dc:creator>Aubrey Jaffer</dc:creator><pubDate>Mon, 14 Jun 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 51: Handling rest list</title><link>https://srfi.schemers.org/srfi-51/srfi-51.html</link><guid>https://srfi.schemers.org/srfi-51</guid><description>SRFI 51 is now in <em>final</em> status.<blockquote>      <p>This SRFI introduces the
      <code>rest-values</code> procedure which has three modes of
      operation:
      <ol>
        <li>it processes a rest list after checking its
        elements with default values or predicate procedures,
        </li><li>it processes a rest list with default values
        without checking its elements,
        </li><li>it processes a default list whose elements
        are lists or pairs, after checking their elements that are default
        values or predicate procedures with the elements of a rest list,
      </li></ol><li>
      <p>and eight macros which additionally check the
      rest arguments that are returned by <code>rest-values</code>.</p></li></p></blockquote></description><dc:creator>Joo ChurlSoo</dc:creator><pubDate>Mon, 07 Jun 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 45: Primitives for Expressing Iterative Lazy Algorithms</title><link>https://srfi.schemers.org/srfi-45/srfi-45.html</link><guid>https://srfi.schemers.org/srfi-45</guid><description>SRFI 45 is now in <em>final</em> status.<blockquote>      <p>Lazy evaluation is traditionally simulated in
      Scheme using <code>delay</code> and <code>force</code>. However, these
      primitives are not powerful enough to express a large class of lazy
      algorithms that are iterative. Indeed, it is folklore in the Scheme
      community that typical iterative lazy algorithms written using
      <code>delay</code> and <code>force</code> will often require unbounded
      memory.
      </p><p>Although varous modifications of
      <code>delay</code> and <code>force</code> had been proposed to resolve
      this problem (see e.g., the SRFI-40 discussion list) they all fail some
      of the benchmarks provided below. To our knowledge, the current SRFI
      provides the first exhaustive solution to this problem.
      </p><p>As motivation, we first explain how the usual
      laziness encoding using only <code>delay</code> and <code>force</code>
      will break the iterative behavior of typical algorithms that would have
      been properly tail-recursive in a true lazy language, causing the
      computation to require unbounded memory.
      </p><p>The problem is then resolved by introducing a
      set of three operations:
      <pre>
    {<code>lazy</code>, <code>delay</code>, <code>force</code>}
</pre>which allow the programmer to succinctly
express lazy algorithms while retaining bounded space behavior in cases that
are properly tail-recursive. A general recipe for using these primitives is
provided. An additional procedure <code>{eager}</code> is provided for the
construction of eager promises in cases where efficiency is a concern.<br>

      <br>
      </p><p>Although this SRFI redefines <code>delay</code>
      and <code>force</code>, the extension is conservative in the sense that
      the semantics of the subset {<code>delay</code>, <code>force</code>} in
      isolation (i.e., as long as the program does not use <code>lazy</code>)
      agrees with that in R5RS. In other words, no program that uses the R5RS
      definitions of delay and force will break if those definition are
      replaced by the SRFI-45 definitions of delay and force.</p></blockquote></description><dc:creator>André van Tonder</dc:creator><pubDate>Mon, 05 Apr 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 44: Collections</title><link>https://srfi.schemers.org/srfi-44/srfi-44.html</link><guid>https://srfi.schemers.org/srfi-44</guid><description>SRFI 44 is now in <em>final</em> status.<blockquote>      <p>A Collections API which defines a common naming
      scheme and set of operations for creating, accessing, and manipulating
      common datastructures in Scheme. The API defines accessors, a common
      protocol for value access via generic and specific enumeration, and
      functions for inter-datastructure cooperation. Finally, a concrete
      specification of a compliant set of operators for the standard Scheme
      heterogenous datastructures (lists and vectors) and for the homogeneous
      Scheme string is provided.</p></blockquote></description><dc:creator>Scott G. Miller</dc:creator><pubDate>Sun, 07 Mar 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 48: Intermediate Format Strings</title><link>https://srfi.schemers.org/srfi-48/srfi-48.html</link><guid>https://srfi.schemers.org/srfi-48</guid><description>SRFI 48 is now in <em>final</em> status.<blockquote>      <p>This document specifies Format Strings, a
      method of interpreting a Scheme string which contains a number of format
      directives that are replaced with other string data according to the
      semantics of each directive. This SRFI extends <a href="https://srfi.schemers.org/srfi-28">SRFI-28</a> in being more generally useful but is less general
      than advanced format strings in that it does not allow, aside from ~F,
      for controlled positioning of text within fields.</p></blockquote></description><dc:creator>Ken Dickey</dc:creator><pubDate>Tue, 02 Mar 2004 12:00:00 -0800</pubDate></item><item><title>SRFI 32: Sort Libraries</title><link>https://srfi.schemers.org/srfi-32/srfi-32.html</link><guid>https://srfi.schemers.org/srfi-32</guid><description>SRFI 32 is now in <em>withdrawn</em> status.<blockquote>      <p>Current Scheme sorting packages are, every one
      of them, surprisingly bad. I've designed the API for a full-featured sort
      toolkit, which I propose as an SRFI. The spec comes with 1200 lines of
      high-quality reference code: tightly written, highly commented, portable
      code, available for free. Implementors want this code. It's better than
      what you have.</p></blockquote></description><dc:creator>Olin Shivers</dc:creator><pubDate>Thu, 17 Jul 2003 12:00:00 -0800</pubDate></item><item><title>SRFI 33: Integer Bitwise-operation Library</title><link>https://srfi.schemers.org/srfi-33/srfi-33.html</link><guid>https://srfi.schemers.org/srfi-33</guid><description>SRFI 33 is now in <em>withdrawn</em> status.<blockquote>      <p>R5RS Scheme has no utilities for performing
      bitwise logical operations on integers or bitstrings, which is a problem
      for authors of portable code. This SRFI proposes a coherent and
      comprehensive set of these functions; it is accompanied by a reference
      implementation of the spec in terms of a set of seven core operators. The
      reference implementation is
      <ul>
        <li>portable
        </li><li>efficient
        </li><li>completely open, public-domain source
      </li></ul><li>
      <p>The precise semantics of these operators is
      almost never an issue. A consistent, portable set of <b>names</b> and
      <b>parameter conventions</b>, however, is. Hence this SRFI.</p></li></p></blockquote></description><dc:creator>Olin Shivers</dc:creator><pubDate>Thu, 17 Jul 2003 12:00:00 -0800</pubDate></item><item><title>SRFI 42: Eager Comprehensions</title><link>https://srfi.schemers.org/srfi-42/srfi-42.html</link><guid>https://srfi.schemers.org/srfi-42</guid><description>SRFI 42 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines a modular and portable
      mechanism for eager comprehensions extending the algorithmic language
      Scheme [R5RS]. An eager comprehension is a convenient notation for one or
      more nested or parallel loops generating a sequence of values, and
      accumulating this sequence into a result.</p></blockquote></description><dc:creator>Sebastian Egner</dc:creator><pubDate>Mon, 07 Jul 2003 12:00:00 -0800</pubDate></item><item><title>SRFI 39: Parameter objects</title><link>https://srfi.schemers.org/srfi-39/srfi-39.html</link><guid>https://srfi.schemers.org/srfi-39</guid><description>SRFI 39 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines <i>parameter</i> objects, the
      procedure <code>make-parameter</code> to create parameter objects and the
      <code>parameterize</code> special form to dynamically bind parameter
      objects. In the dynamic environment, each parameter object is bound to a
      cell containing the value of the parameter. When a procedure is called
      the called procedure inherits the dynamic environment from the caller.
      The <code>parameterize</code> special form allows the binding of a
      parameter object to be changed for the dynamic extent of its body.</p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Mon, 30 Jun 2003 12:00:00 -0800</pubDate></item><item><title>SRFI 38: External Representation for Data With Shared Structure</title><link>https://srfi.schemers.org/srfi-38/srfi-38.html</link><guid>https://srfi.schemers.org/srfi-38</guid><description>SRFI 38 is now in <em>final</em> status.<blockquote>      <p>This SRFI proposes
      <code>(write-with-shared-structure)</code> and
      <code>(read-with-shared-structure)</code>, procedures for writing and reading
      external representations of data containing shared structure. These
      procedures implement a proposed standard external notation for data
      containing shared structure.
      </p><p>This SRFI permits but does not require
      replacing the standard <code>(write)</code> and <code>(read)</code> functions.
      These functions may be implemented without the overhead in time and space
      required to detect and specify shared structure.
      </p><p>An implementation conforms to this SRFI if it
      provides procedures named <code>(write-with-shared-structure)</code> and
      <code>(read-with-shared-structure)</code>, which produce and read the same
      notation as produced by the reference implementation. It may also provide
      <code>(read/ss)</code> and <code>(write/ss)</code>, equivalent functions with
      shorter names.</p></blockquote></description><dc:creator>Ray Dillinger</dc:creator><pubDate>Wed, 02 Apr 2003 12:00:00 -0800</pubDate></item><item><title>SRFI 37: args-fold: a program argument processor</title><link>https://srfi.schemers.org/srfi-37/srfi-37.html</link><guid>https://srfi.schemers.org/srfi-37</guid><description>SRFI 37 is now in <em>final</em> status.<blockquote>      <p>Many operating systems make the set of argument
      strings used to invoke a program available (often following the program
      name string in an array called argv). Most programs need to parse and
      process these argument strings in one way or another. This SRFI describes
      a set of procedures that support processing program arguments according
      to POSIX and GNU C Library Reference Manual guidelines.</p></blockquote></description><dc:creator>Anthony Carrico</dc:creator><pubDate>Mon, 13 Jan 2003 12:00:00 -0800</pubDate></item><item><title>SRFI 31: A special form `rec' for recursive evaluation</title><link>https://srfi.schemers.org/srfi-31/srfi-31.html</link><guid>https://srfi.schemers.org/srfi-31</guid><description>SRFI 31 is now in <em>final</em> status.<blockquote>      <p>We propose the implementation of a special form
      called <code>rec</code>. This form is a generalization and combination of
      the forms <code>rec</code> and <code>named-lambda</code> of
      [Clinger1985]. It allows the simple and non-imperative construction of
      self-referential expressions. As an important special case, it extends
      the A. Church form <code>lambda</code> such that it allows the direct
      definition of recursive procedures without using further special forms
      like <code>let</code> or <code>letrec</code>, without using advanced
      constructions like the H. B. Curry combinator and, unlike
      <code>define</code>, without introducing variable bindings into the
      external environment.</p></blockquote></description><dc:creator>Mirko Luedde</dc:creator><pubDate>Mon, 02 Dec 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 34: Exception Handling for Programs</title><link>https://srfi.schemers.org/srfi-34/srfi-34.html</link><guid>https://srfi.schemers.org/srfi-34</guid><description>SRFI 34 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines exception-handling and
      exception-raising constructs for Scheme, including
      <ul>
        <li>a <code>with-exception-handler</code>
        procedure and a <code>guard</code> form for installing
        exception-handling procedures,
        </li><li>a <code>raise</code> procedure for invoking
        the current exception handler.
      </li></ul><li>
      <p>This SRFI is based on (withdrawn) <a href="https://srfi.schemers.org/srfi-12/">SRFI 12: Exception Handling</a> by William Clinger, R. Kent
      Dybvig, Matthew Flatt, and Marc Feeley.</p></li></p></blockquote></description><dc:creator>Richard Kelsey and Michael Sperber</dc:creator><pubDate>Sun, 01 Dec 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 35: Conditions</title><link>https://srfi.schemers.org/srfi-35/srfi-35.html</link><guid>https://srfi.schemers.org/srfi-35</guid><description>SRFI 35 is now in <em>final</em> status.<blockquote>      <p>The SRFI defines constructs for creating and
      inspecting <i>condition</i> types and values. A condition value
      encapsulates information about an exceptional situation, or exception.
      This SRFI also defines a few basic condition types.</p></blockquote></description><dc:creator>Richard Kelsey and Michael Sperber</dc:creator><pubDate>Sun, 01 Dec 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 36: I/O Conditions</title><link>https://srfi.schemers.org/srfi-36/srfi-36.html</link><guid>https://srfi.schemers.org/srfi-36</guid><description>SRFI 36 is now in <em>final</em> status.<blockquote>      <p>This SRFI specifies a set of condition types
      for I/O errors. The condition types are defined in terms of <a href="https://srfi.schemers.org/srfi-35/">SRFI 35</a>. Moreover, this SRFI requires a Scheme system
      implementing it to raise exceptions in the sense of <a href="http://srfi.schemers.org/srfi-34/">SRFI 34</a> for errors occurring
      during the execution of the R5RS <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.6">
      I/O operations</a>.</p></blockquote></description><dc:creator>Michael Sperber</dc:creator><pubDate>Sun, 01 Dec 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 30: Nested Multi-line Comments</title><link>https://srfi.schemers.org/srfi-30/srfi-30.html</link><guid>https://srfi.schemers.org/srfi-30</guid><description>SRFI 30 is now in <em>final</em> status.<blockquote>      <p>This SRFI extends R5RS by possibly nested,
      multi-line comments. Multi-line comments start with <code>#|</code> and
      end with <code>|#</code>.</p></blockquote></description><dc:creator>Martin Gasbichler</dc:creator><pubDate>Wed, 07 Aug 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 29: Localization</title><link>https://srfi.schemers.org/srfi-29/srfi-29.html</link><guid>https://srfi.schemers.org/srfi-29</guid><description>SRFI 29 is now in <em>final</em> status.<blockquote>      <p>This document specifies an interface to
      retrieving and displaying locale sensitive messages. A Scheme program can
      register one or more translations of templated messages, and then write
      Scheme code that can transparently retrieve the appropriate message for
      the locale under which the Scheme system is running.</p></blockquote></description><dc:creator>Scott G. Miller</dc:creator><pubDate>Thu, 01 Aug 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 28: Basic Format Strings</title><link>https://srfi.schemers.org/srfi-28/srfi-28.html</link><guid>https://srfi.schemers.org/srfi-28</guid><description>SRFI 28 is now in <em>final</em> status.<blockquote>      <p>This document specifies Format Strings, a
      method of interpreting a Scheme string which contains a number of escape
      sequences that are replaced with other string data according to the
      semantics of each sequence.</p></blockquote></description><dc:creator>Scott G. Miller</dc:creator><pubDate>Tue, 25 Jun 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 27: Sources of Random Bits</title><link>https://srfi.schemers.org/srfi-27/srfi-27.html</link><guid>https://srfi.schemers.org/srfi-27</guid><description>SRFI 27 is now in <em>final</em> status.<blockquote>      <p>This document specifies an interface to sources
      of random bits, or "random sources" for brevity. In particular, there are
      three different ways to use the interface, with varying demands on the
      quality of the source and the amount of control over the production
      process:
      <ul>
        <li>The "no fuss" interface specifies that
        <code>(random-integer</code> <i>n</i><code>)</code> produces the next
        random integer in {0, ..., <i>n</i>-1} and <code>(random-real)</code>
        produces the next random real number between zero and one. The details
        of how these random values are produced may not be very relevant, as
        long as they appear to be sufficiently random.
        </li><li>For simulation purposes, on the contrary, it
        is usually necessary to know that the numbers are produced
        deterministically by a pseudo random number generator of high quality
        and to have explicit access to its state. In addition, one might want
        to use several independent sources of random numbers at the same time
        and it can be useful to have some simple form of randomization.
        </li><li>For security applications a serious form of
        true randomization is essential, in the sense that it is difficult for
        an adversary to exploit or introduce imperfections into the
        distribution of random bits. Moreover, the linear complexity of the
        stream of random bits is more important than its statistical
        properties. In these applications, an entropy source (producing truely
        random bits at a low rate) is used to randomize a pseudo random number
        generator to increase the rate of available bits.
      </li></ul><li>
      <p>Once random sources provide the infrastructure
      to obtain random bits, these can be used to construct other random
      deviates. Most important are floating point numbers of various
      distributions and random discrete structures, such as permutations or
      graphs. As there is an essentially unlimited number of such objects (with
      limited use elsewhere), we do not include them in this SRFI. In other
      words, this SRFI is <em>not</em> about making all sorts of random
      objects---it is about obtaining random bits in a portable, flexible,
      reliable, and efficient way.</p></li></p></blockquote></description><dc:creator>Sebastian Egner</dc:creator><pubDate>Mon, 03 Jun 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 25: Multi-dimensional Array Primitives</title><link>https://srfi.schemers.org/srfi-25/srfi-25.html</link><guid>https://srfi.schemers.org/srfi-25</guid><description>SRFI 25 is now in <em>final</em> status.<blockquote>      <p>A core set of procedures for creating and
      manipulating heterogeneous multidimensional arrays is proposed. The
      design is consistent with the rest of Scheme and independent of other
      container data types. It provides easy sharing of parts of an array as
      other arrays without copying, encouraging a declarative style of
      programming.
      </p><p>The specification is based on an original
      contribution by Alan Bawden in 1993.</p></blockquote></description><dc:creator>Jussi Piitulainen</dc:creator><pubDate>Tue, 21 May 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 24: Define-syntax in local lexical scopes</title><link>https://srfi.schemers.org/srfi-24/srfi-24.html</link><guid>https://srfi.schemers.org/srfi-24</guid><description>SRFI 24 is now in <em>withdrawn</em> status.<blockquote>      <p>This document specifies a proper extension to
      Scheme which allows <b>define-syntax</b> forms to appear in those places
      where local definitions can appear (R5RS, 5.2.2). A corresponding
      letrec-variant is described.</p></blockquote></description><dc:creator>Antti Huima</dc:creator><pubDate>Fri, 12 Apr 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 26: Notation for Specializing Parameters without Currying</title><link>https://srfi.schemers.org/srfi-26/srfi-26.html</link><guid>https://srfi.schemers.org/srfi-26</guid><description>SRFI 26 is now in <em>final</em> status.<blockquote>      <p>When programming in functional style, it is
      frequently necessary to specialize some of the parameters of a
      multi-parameter procedure. For example, from the binary operation
      <code>cons</code> one might want to obtain the unary operation
      <code>(lambda (x) (cons 1 x))</code>. This specialization of parameters
      is also known as "partial application", "operator section" or
      "projection".
      </p><p>The mechanism proposed here allows to write
      this sort of specialization in a simple and compact way. The mechanism is
      best explained by a few examples:
      <table>
        <tr>
          <td><code>(cut cons (+ a 1) &lt;>)</code>
          </td><td>is the same as
          </td><td><code>(lambda (x2) (cons (+ a 1) x2))</code>
        <tr>
          <td><code>(cut list 1 &lt;> 3 &lt;> 5)</code>
          </td><td>is the same as
          </td><td><code>(lambda (x2 x4) (list 1 x2 3 x4 5))</code>
        <tr>
          <td><code>(cut list)</code>
          </td><td>is the same as
          </td><td><code>(lambda () (list))</code>
        <tr>
          <td><code>(cut list 1 &lt;> 3 &lt;...>)</code>
          </td><td>is the same as
          </td><td><code>(lambda (x2 . xs) (apply list 1 x2 3 xs))</code>
        <tr>
          <td><code>(cut &lt;> a b)</code>
          </td><td>is the same as
          </td><td><code>(lambda (f) (f a b))</code>
      </td></tr></td></tr></td></tr></td></tr></td></tr></table>
      </p><p>As you see, the macro <code>cut</code>
      specializes some of the parameters of its first argument. The parameters
      that are to show up as formal variables of the result are indicated by
      the symbol <code>&lt;></code>, pronouced as "slot". In addition, the
      symbol <code>&lt;...></code>, pronounced as "rest-slot", matches all
      residual arguments of a variable argument procedure. As you can see from
      the last example above, the first argument can also be a slot, as one
      should expect in Scheme.
      </p><p>In addition to <code>cut</code>, there is a
      variant called <code>cute</code> (a mnemonic for "<code>cut</code> with
      evaluated non-slots") which evaluates the non-slot expressions at the
      time the procedure is specialized, not at the time the specialized
      procedure is called. For example,
      <table>
        <tr>
          <td><code>(cute cons (+ a 1) &lt;>)</code>
          </td><td>is the same as
          </td><td><code>(let ((a1 (+ a 1))) (lambda (x2) (cons a1 x2)))</code>
      </td></tr></table>
      </p><p>As you see from comparing this example with the
      first example above, the <code>cute</code>-variant will evaluate <code>(+
      a 1)</code> once, while the <code>cut</code>-variant will evaluate it
      during every invokation of the resulting procedure.
      </p><p>The mechanism proposed in this SRFI allows
      specializing any subset of the variables of a procedure. The result can
      be of fixed arity or of variable arity. The mechanism does not allow
      permutation, omission, duplication or any other processing of the
      arguments; for this it is necessary to write to use a different mechanism
      such as <code>lambda</code>.</p></blockquote></description><dc:creator>Sebastian Egner</dc:creator><pubDate>Thu, 14 Feb 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 22: Running Scheme Scripts on Unix</title><link>https://srfi.schemers.org/srfi-22/srfi-22.html</link><guid>https://srfi.schemers.org/srfi-22</guid><description>SRFI 22 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes basic prerequisites for
      running Scheme programs as Unix scripts in a uniform way. Specifically,
      it describes:
      <ul>
        <li>the syntax of Unix scripts written in
        Scheme,
        </li><li>a uniform convention for calling the Scheme
        script interpreter, and
        </li><li>a method for accessing the Unix command line
        arguments from within the Scheme script.
      </li></ul><li></li></p></blockquote></description><dc:creator>Martin Gasbichler and Michael Sperber</dc:creator><pubDate>Sun, 20 Jan 2002 12:00:00 -0800</pubDate></item><item><title>SRFI 23: Error reporting mechanism</title><link>https://srfi.schemers.org/srfi-23/srfi-23.html</link><guid>https://srfi.schemers.org/srfi-23</guid><description>SRFI 23 is now in <em>final</em> status.<blockquote>      <p>A mechanism is proposed to allow Scheme code to
      report errors and abort execution. The proposed mechanism is already
      implemented in several Scheme systems and can be implemented, albeit
      imperfectly, in any R5RS conforming Scheme.</p></blockquote></description><dc:creator>Stephan Houben</dc:creator><pubDate>Fri, 22 Jun 2001 12:00:00 -0800</pubDate></item><item><title>SRFI 20: Simple object system</title><link>https://srfi.schemers.org/srfi-20/srfi-20.html</link><guid>https://srfi.schemers.org/srfi-20</guid><description>SRFI 20 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI presents an object system to define
      classes, generic functions as well as to support some level of
      introspection. This object system is based on Meroon-V3 which is itself
      inspired by CLOS. <a href="http://www-spi.lip6.fr/~queinnec/WWW/Meroon.html">Meroon-V3</a> is
      distributed and used since 1992.</p></blockquote></description><dc:creator>Christian Queinnec</dc:creator><pubDate>Sun, 29 Apr 2001 12:00:00 -0800</pubDate></item><item><title>SRFI 18: Multithreading support</title><link>https://srfi.schemers.org/srfi-18/srfi-18.html</link><guid>https://srfi.schemers.org/srfi-18</guid><description>SRFI 18 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines the following multithreading
      datatypes for Scheme
      <ul>
        <li>Thread
        </li><li>Mutex
        </li><li>Condition variable
        </li><li>Time
      </li></ul><li>
      <p>It also defines a mechanism to handle
      exceptions and some multithreading exception datatypes.</p></li></p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Wed, 14 Mar 2001 12:00:00 -0800</pubDate></item><item><title>SRFI 21: Real-time multithreading support</title><link>https://srfi.schemers.org/srfi-21/srfi-21.html</link><guid>https://srfi.schemers.org/srfi-21</guid><description>SRFI 21 is now in <em>final</em> status.<blockquote>      <p>This SRFI defines the following multithreading
      datatypes for Scheme
      <ul>
        <li>Thread
        </li><li>Mutex
        </li><li>Condition variable
        </li><li>Time
      </li></ul><li>
      <p>It also defines a mechanism to handle
      exceptions and some multithreading exception datatypes.</p></li></p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Fri, 02 Mar 2001 12:00:00 -0800</pubDate></item><item><title>SRFI 13: String Libraries</title><link>https://srfi.schemers.org/srfi-13/srfi-13.html</link><guid>https://srfi.schemers.org/srfi-13</guid><description>SRFI 13 is now in <em>final</em> status.<blockquote>      <p><abbr title="Revised^5 Report on Scheme">R5RS</abbr> Scheme has an impoverished set
      of string-processing utilities, which is a problem for authors of
      portable code. This <abbr title="Scheme Request for Implementation">SRFI</abbr> proposes a coherent and
      comprehensive set of string-processing procedures; it is accompanied by a
      reference implementation of the spec. The reference implementation
      is
      <ul>
        <li>portable
        </li><li>efficient
        </li><li>open source
      </li></ul><li>
      <p>The routines in this SRFI are
      backwards-compatible with the string-processing routines of <abbr title="Revised^5 Report on Scheme">R5RS</abbr>.</p></li></p></blockquote></description><dc:creator>Olin Shivers</dc:creator><pubDate>Thu, 28 Dec 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 14: Character-set Library</title><link>https://srfi.schemers.org/srfi-14/srfi-14.html</link><guid>https://srfi.schemers.org/srfi-14</guid><description>SRFI 14 is now in <em>final</em> status.<blockquote>      <p>The ability to efficiently represent and
      manipulate sets of characters is an unglamorous but very useful
      capability for text-processing code -- one that tends to pop up in the
      definitions of other libraries. Hence it is useful to specify a general
      substrate for this functionality early. This SRFI defines a general
      library that provides this functionality.
      </p><p>It is accompanied by a reference implementation
      for the spec. The reference implementation is fairly efficient,
      straightforwardly portable, and has a "free software" copyright. The
      implementation is tuned for "small" 7 or 8 bit character types, such as
      ASCII or Latin-1; the data structures and algorithms would have to be
      altered for larger 16 or 32 bit character types such as Unicode --
      however, the specs have been carefully designed with these larger
      character types in mind.
      </p><p>Several forthcoming SRFIs can be defined in
      terms of this one:
      <ul>
        <li>string library
        </li><li>delimited input procedures (<em>e.g.</em>,
        <code>read-line</code>)
        </li><li>regular expressions
      </li></ul><li></li></p></blockquote></description><dc:creator>Olin Shivers</dc:creator><pubDate>Thu, 28 Dec 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 19: Time Data Types and Procedures</title><link>https://srfi.schemers.org/srfi-19/srfi-19.html</link><guid>https://srfi.schemers.org/srfi-19</guid><description>SRFI 19 is now in <em>final</em> status.<blockquote>      <p>Points in time are represented as the number of
      seconds (with nanosecond precision) since "the epoch," a zero point in
      time. Several standard variants are defined, including UTC (universal
      coordinated time), TAI (international atomic time), and monotonic time. A
      point in time can also be represented as a Julian Day or Modified Julian
      Day number. Time durations, including time spent in a process or thread,
      are defined. Conversion routines are provided. The procedure CURRENT-TIME
      queries the current time in a specified variant, with a system-dependent
      resolution. Procedures for time arithmetic and time comparisons are also
      provided.
      </p><p>A date is a representation of a point in time
      in the Gregorian calendar, a 24 hour clock (with nanosecond precision)
      and a time zone offset from UTC. Procedures for converting between time
      and dates are provided, as well as for reading and writing string
      representations of dates.</p></blockquote></description><dc:creator>Will Fitzgerald</dc:creator><pubDate>Thu, 31 Aug 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 17: Generalized set!</title><link>https://srfi.schemers.org/srfi-17/srfi-17.html</link><guid>https://srfi.schemers.org/srfi-17</guid><description>SRFI 17 is now in <em>final</em> status.<blockquote>      <p>This is a proposal to allow procedure calls
      that evaluate to the "value of a location" to be used to <em>set</em> the
      value of the location, when used as the first operand of
      <code>set!</code>.For example:
      <pre>
(set! (car x) (car y))
</pre>becomes equivalent to
      <pre>
(set-car! x (car y))
</pre>
      </p><p>Many programming languages have the concept of
      an <i>lvalue</i>. that is an "expression" that "evaluates" to a location,
      and which can appear on the left-hand-side of an assignment. Common Lisp
      has a related concept of "generalized variables" which can be used in
      <code>setf</code> and some other special forms. However, the Common Lisp
      concept is based on the idea of compile-time recognition of special
      "location-producing" functions; this does not seem to be in the "spirit
      of Scheme".
      </p><p>This SRFI proposes an extension of
      <code>set!</code> so that it provides similar functionality as Common
      Lisp's <code>setf</code>, except that the updater is associated with a
      procedure value, rather than a name.</p></blockquote></description><dc:creator>Per Bothner</dc:creator><pubDate>Mon, 24 Jul 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 11: Syntax for receiving multiple values</title><link>https://srfi.schemers.org/srfi-11/srfi-11.html</link><guid>https://srfi.schemers.org/srfi-11</guid><description>SRFI 11 is now in <em>final</em> status.<blockquote>      <p>The SRFI introduces syntactic forms LET-VALUES
      and LET*-VALUES that bind the values of expressions that return multiple
      values.</p></blockquote></description><dc:creator>Lars T Hansen</dc:creator><pubDate>Wed, 15 Mar 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 15: Syntax for dynamic scoping</title><link>https://srfi.schemers.org/srfi-15/srfi-15.html</link><guid>https://srfi.schemers.org/srfi-15</guid><description>SRFI 15 is now in <em>withdrawn</em> status.<blockquote>      <p>FLUID-LET, a binding syntax for dynamic
      scoping, is introduced.</p></blockquote></description><dc:creator>Lars T Hansen</dc:creator><pubDate>Fri, 10 Mar 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 16: Syntax for procedures of variable arity</title><link>https://srfi.schemers.org/srfi-16/srfi-16.html</link><guid>https://srfi.schemers.org/srfi-16</guid><description>SRFI 16 is now in <em>final</em> status.<blockquote>      <p>CASE-LAMBDA, a syntax for procedures with a
      variable number of arguments, is introduced.</p></blockquote></description><dc:creator>Lars T Hansen</dc:creator><pubDate>Fri, 10 Mar 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 12: Exception Handling</title><link>https://srfi.schemers.org/srfi-12/srfi-12.html</link><guid>https://srfi.schemers.org/srfi-12</guid><description>SRFI 12 is now in <em>withdrawn</em> status.<blockquote>      <p>The SRFI defines exception-handling constructs
      for Scheme, including
      <ul>
        <li>the CURRENT-EXCEPTION-HANDLER procedure for
        obtaining the current exception-handling procedure,
        </li><li>the WITH-EXCEPTION-HANDLER procedure and
        HANDLE-EXCEPTIONS form for installing an exception-handling
        procedure,
        </li><li>the ABORT and SIGNAL procedures for raising
        exceptions, and
        </li><li>constructs for creating and inspecting
        <em>condition</em> values, which encapsulate information about an
        exception.
      </li></ul><li>
      <p>This SRFI requires a Scheme implementation to
      raise an exception whenever an error is to be signaled or whenever the
      system determines that evaluation cannot proceed in a manner consistent
      with the semantics of Scheme. However, this SRFI does not define the
      information to be supplied by an implementation for each possible kind of
      exception; such a specification is left open for future SRFIs.</p></li></p></blockquote></description><dc:creator>William Clinger, R. Kent Dybvig, Matthew Flatt, and Marc Feeley</dc:creator><pubDate>Sat, 22 Jan 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 10: #, external form</title><link>https://srfi.schemers.org/srfi-10/srfi-10.html</link><guid>https://srfi.schemers.org/srfi-10</guid><description>SRFI 10 is now in <em>final</em> status.<blockquote>      <p>The present SRFI proposes an extensible
      external representation of Scheme values, a notational convention for
      future SRFIs. This SRFI adds <code>#,(</code> as a new token and extends
      production rules of the grammar for a Scheme reader. The
      <code>#,()</code> form can be used for example to denote values that do
      not have a convenient printed representation, as well for conditional
      code compilation. It is proposed that future SRFIs that contain new read
      syntax for values use the <code>#,()</code> notation with an appropriate
      tag symbol.
      </p><p>As a particular example and the reference
      implementation for the <code>#,()</code> convention, this SRFI describes
      an interpretation of the <code>#,()</code> external form as a read-time
      application.</p></blockquote></description><dc:creator>Oleg Kiselyov</dc:creator><pubDate>Thu, 13 Jan 2000 12:00:00 -0800</pubDate></item><item><title>SRFI 1: List Library</title><link>https://srfi.schemers.org/srfi-1/srfi-1.html</link><guid>https://srfi.schemers.org/srfi-1</guid><description>SRFI 1 is now in <em>final</em> status.<blockquote>      <p><abbr title="Revised^5 Report on Scheme">R5RS</abbr> Scheme has an impoverished set
      of list-processing utilities, which is a problem for authors of portable
      code. This <abbr title="Scheme Request for Implementation">SRFI</abbr>
      proposes a coherent and comprehensive set of list-processing procedures;
      it is accompanied by a reference implementation of the spec. The
      reference implementation is
      <ul>
        <li>portable
        </li><li>efficient
        </li><li>completely open, public-domain source
      </li></ul><li></li></p></blockquote></description><dc:creator>Olin Shivers</dc:creator><pubDate>Sat, 09 Oct 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 9: Defining Record Types</title><link>https://srfi.schemers.org/srfi-9/srfi-9.html</link><guid>https://srfi.schemers.org/srfi-9</guid><description>SRFI 9 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes syntax for creating new
      data types, called record types. A predicate, constructor, and field
      accessors and modifiers are defined for each record type. Each new record
      type is distinct from all existing types, including other record types
      and Scheme's predefined types.</p></blockquote></description><dc:creator>Richard Kelsey</dc:creator><pubDate>Thu, 09 Sep 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 8: receive: Binding to multiple values</title><link>https://srfi.schemers.org/srfi-8/srfi-8.html</link><guid>https://srfi.schemers.org/srfi-8</guid><description>SRFI 8 is now in <em>final</em> status.<blockquote>      <p>The only mechanism that R<sup>5</sup>RS
      provides for binding identifiers to the values of a multiple-valued
      expression is the primitive <code>call-with-values</code>. This SRFI
      proposes a more concise, more readable syntax for creating such
      bindings.</p></blockquote></description><dc:creator>John David Stone</dc:creator><pubDate>Mon, 30 Aug 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 3: List-Set Library</title><link>https://srfi.schemers.org/srfi-3/srfi-3.html</link><guid>https://srfi.schemers.org/srfi-3</guid><description>SRFI 3 is now in <em>withdrawn</em> status.<blockquote>      <p>This SRFI proposes a coherent and comprehensive
      set of procedures for manipulating lists as sets; it is accompanied by a
      reference implementation of the spec. The reference implementation
      is
      <ul>
        <li>portable
        </li><li>efficient
        </li><li>completely open, public-domain source
      </li></ul><li>
      <p>Be aware that these procedures are inherently
      O(n^2) in the lengths of their parameter lists - serious set operations
      on large lists should use alternate techniques.</p></li></p></blockquote></description><dc:creator>Olin Shivers</dc:creator><pubDate>Thu, 26 Aug 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 7: Feature-based program configuration language</title><link>https://srfi.schemers.org/srfi-7/srfi-7.html</link><guid>https://srfi.schemers.org/srfi-7</guid><description>SRFI 7 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes a configuration language to
      be used for specifying the set of Scheme features or extensions required
      to run a program. In addition to a list of required features, a program
      may also contain Scheme code to be used only when a particular feature or
      combination of features is available.
      </p><p>The configuration language is entirely distinct
      from Scheme; it is neither embedded in Scheme nor includes Scheme as a
      subset.</p></blockquote></description><dc:creator>Richard Kelsey</dc:creator><pubDate>Thu, 19 Aug 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 6: Basic String Ports</title><link>https://srfi.schemers.org/srfi-6/srfi-6.html</link><guid>https://srfi.schemers.org/srfi-6</guid><description>SRFI 6 is now in <em>final</em> status.<blockquote>      <p>Scheme's i/o primitives are extended by adding
      three new procedures that
      <ul>
        <li>create an input port from a string,
        </li><li>create an output port whose contents are
        accumulated in Scheme's working memory instead of an external file,
        and
        </li><li>extract the accumulated contents of an
        in-memory output port and return them in the form of a string.
      </li></ul><li></li></p></blockquote></description><dc:creator>William D Clinger</dc:creator><pubDate>Thu, 01 Jul 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 4: Homogeneous numeric vector datatypes</title><link>https://srfi.schemers.org/srfi-4/srfi-4.html</link><guid>https://srfi.schemers.org/srfi-4</guid><description>SRFI 4 is now in <em>final</em> status.<blockquote>      <p>This SRFI describes a set of datatypes for
      vectors whose elements are of the same numeric type (signed or unsigned
      exact integer or inexact real of a given precision). These datatypes
      support operations analogous to the Scheme vector type, but they are
      distinct datatypes. An external representation is specified which must be
      supported by the <code>read</code> and <code>write</code> procedures and
      by the program parser (i.e. programs can contain references to literal
      homogeneous vectors).</p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Sat, 22 May 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 0: Feature-based conditional expansion construct</title><link>https://srfi.schemers.org/srfi-0/srfi-0.html</link><guid>https://srfi.schemers.org/srfi-0</guid><description>SRFI 0 is now in <em>final</em> status.<blockquote>      <p>It is desirable that programs which depend on
      additions to standard Scheme name those additions. SRFIs provide the
      specifications of these additions ("features"), and SRFI 0 provides the
      means to actually check that these features are present in the Scheme
      system by means of the <code>cond-expand</code> construct. It is
      anticipated that there will be two main classes of features:
      <ul>
        <li>sets of value and syntax bindings
        </li><li>reader syntax extensions
      </li></ul><li>
      <p>("Reader syntax" refers to aspects of the
      syntax described by the grammars in the Scheme reports.)
      </p><p>The former class of features will probably
      include most SRFIs, exemplified by the list library specified in <a href="https://srfi.schemers.org/srfi-1/">SRFI 1</a>. The latter class includes Unicode source code
      support and different kinds of parentheses.
      </p><p>Control over the presence of individual
      features will vary over different Scheme systems. A given feature may be
      absent or provided by default in some Scheme systems and in others some
      mechanism (such as an "import" clause in the code or a program
      configuration file, a command line option, a dependency declaration in a
      module definition, etc.) will be required for the feature to be present
      in the system.
      </p><p>Moreover, in some systems a given feature may
      be in effect throughout the entire program if it is in effect anywhere at
      all. Other systems may have more precise mechanisms to control the scope
      of a feature (this might be the case for example when a module system is
      supported). In general it is thus possible that a feature is in effect in
      some parts of the program and not in others. This allows conflicting
      SRFIs to be present in a given program as long as their scope do not
      intersect.
      </p><p>SRFI 0 does not prescribe a particular
      mechanism for controlling the presence of a feature as it is our opinion
      that this should be the role of a module system. We expect that future
      module system SRFIs will need to extend the semantics of SRFI 0 for their
      purposes, for example by defining feature scoping rules or by
      generalizing the feature testing construct.</p></li></p></blockquote></description><dc:creator>Marc Feeley</dc:creator><pubDate>Fri, 07 May 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 5: A compatible let form with signatures and rest arguments</title><link>https://srfi.schemers.org/srfi-5/srfi-5.html</link><guid>https://srfi.schemers.org/srfi-5</guid><description>SRFI 5 is now in <em>final</em> status.<blockquote>      <p>The <i>named-let</i> incarnation of the
      <code>let</code> form has two slight inconsistencies with the
      <code>define</code> form. As defined, the <code>let</code> form makes no
      accommodation for rest arguments, an issue of functionality and
      consistency. As defined, the <code>let</code> form does not accommodate
      signature-style syntax, an issue of aesthetics and consistency. Both
      issues are addressed here in a manner which is compatible with the
      traditional <code>let</code> form but for minor extensions.</p></blockquote></description><dc:creator>Andy Gaynor</dc:creator><pubDate>Mon, 26 Apr 1999 12:00:00 -0800</pubDate></item><item><title>SRFI 2: AND-LET*: an AND with local bindings, a guarded LET* special form</title><link>https://srfi.schemers.org/srfi-2/srfi-2.html</link><guid>https://srfi.schemers.org/srfi-2</guid><description>SRFI 2 is now in <em>final</em> status.<blockquote>      <p>Like an ordinary AND, an AND-LET* special form
      evaluates its arguments -- expressions -- one after another in order,
      till the first one that yields #f. Unlike AND, however, a non-#f result
      of one expression can be bound to a fresh variable and used in the
      subsequent expressions. AND-LET* is a cross-breed between LET* and
      AND.</p></blockquote></description><dc:creator>Oleg Kiselyov</dc:creator><pubDate>Mon, 01 Mar 1999 12:00:00 -0800</pubDate></item></channel></rss>